<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>51单片机开发例程-2</title>
    <url>/p/e743207f.html</url>
    <content><![CDATA[<h1 id="内容概述"><a href="#内容概述" class="headerlink" title="内容概述"></a>内容概述</h1><p>此章学习到单片机上的一个重要部件：蜂鸣器</p>
<p>蜂鸣器通过发出声音来达到提示以及播放音乐的功能，可以让使用者能够简单地判断单片机是否实现了自己想要的效果比如：开始工作，输出结果，程序故障等等，而蜂鸣器又分为有源蜂鸣器和无源蜂鸣器，在此单片机上使用的是无源蜂鸣器</p>
<a id="more"></a>

<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>1.使用<code>STC89C52</code>的普中51-单核-A2单片机（本文以该单片机为样本）</li>
<li>2.能够正常下载驱动以及Keil等开发软件的Windows10.0系统PC</li>
<li>3.一根micro USB to USB A数据线</li>
</ul>
<h1 id="驱动蜂鸣器发声"><a href="#驱动蜂鸣器发声" class="headerlink" title="驱动蜂鸣器发声"></a>驱动蜂鸣器发声</h1><h2 id="蜂鸣器原理"><a href="#蜂鸣器原理" class="headerlink" title="蜂鸣器原理"></a>蜂鸣器原理</h2><p>单片机上使用的蜂鸣器是无源蜂鸣器，这种蜂鸣器又被称为压电蜂鸣器，原因是这种蜂鸣器发声的原理是压电效应</p>
<blockquote>
<p>当对压电材料施以物理压强时，材料体内之<a href="https://bk.tw.lvfukeji.com/baike-%E7%94%B5%E5%81%B6%E6%9E%81%E7%9F%A9">电偶极矩</a>会因压缩而变短，此时压电材料为抵抗这变化会在材料相对的表面上产生等量正负电荷，以保持原状。这种由于<a href="https://bk.tw.lvfukeji.com/baike-%E5%BD%A2%E8%AE%8A">形变</a>而产生<a href="https://bk.tw.lvfukeji.com/baike-%E9%9B%BB%E6%A5%B5%E5%8C%96">电极化</a>的现象称为“正压电效应”。若欲持续产生电能，须使材料振动。</p>
<p>正压电效应实质上是机械能转化为电能的过程。</p>
<p>当在压电材料表面施加<a href="https://bk.tw.lvfukeji.com/baike-%E9%9B%BB%E5%A0%B4">电场</a>（电压），因电场作用时电偶极矩会被拉长，压电材料为抵抗变化，会沿电场方向伸长。这种通过电场作用而产生机械形变的过程称为“逆压电效应”。</p>
<p>逆压电效应实质上是电能转化为机械能的过程。</p>
<p>——引用自<a href="https://bk.tw.lvfukeji.com/wiki/%E5%A3%93%E9%9B%BB%E6%95%88%E6%87%89">Wikipedia</a></p>
</blockquote>
<p>如何使得蜂鸣器发生且发出不同声音？我们可以通过改变蜂鸣器连接到单片机引脚输出交变电压波形的频率来调整控制蜂鸣器的音调，也可以改变输出交变电压占空比来控制蜂鸣器声音的大小</p>
<blockquote>
<p>Un buzzer (transducteur) piézoélectrique est typiquement composé d’un diaphragme piézoélectrique, d’une cavité avec un orifice et de connexions pour les bornes électriques. Il nécessite une tension alternative pour fonctionner, de quelques volts à quelques dizaines de volts (3 V à 30 V par exemple). C’est ce type de <a href="https://fr.wikipedia.org/wiki/Transducteur">transducteur</a> que l’on retrouve au dos des montres ayant une fonction alarme.Il présente une fréquence de résonance optimale de quelques kilohertz, entre 1 kHz et 5 kHz en général, par exemple 2,8 kHz ou 3 kHz, mais il peut atteindre des fréquences plus hautes jusqu’à 80 kHz. Il faut donc un oscillateur chargé de produire un signal rectangulaire, ce dernier pouvant facilement être construit avec des portes logiques ou avec des transistors. Si on applique au transducteur piézoélectrique un signal donné sur une de ses bornes, et le même signal mais en opposition de phase sur son autre borne, il sera en mesure de délivrer une puissance quadruple, avec une tension d’alimentation identique (montage en pont, même principe que celui adopté pour certains amplificateurs audio de puissance).</p>
<p>压电蜂鸣器通常由压电隔膜，带孔的空腔和电气端子的连接组成。它需要交替电压才能运行，从几伏特到几十伏特（例如3伏到30伏特）。这种<a href="https://fr.wikipedia.org/wiki/Transducteur">传感器</a>可以在手表背面找到，具有报警功能。它的最佳共振频率为几千赫，一般在1千赫至5千赫之间，例如2.8千赫或3千赫2，但它可以达到高达80千赫3的更高频率。因此，有必要有一个振荡器来负责产生矩形信号，该信号可以很容易地使用逻辑门或晶体管构建。如果给定的信号被施加到其一个终端上的压电传感器上，并且信号相同，但与另一个终端相位相反，它将能够以相同的电源电压（桥接安装，与某些功率音频放大器采用的原理相同）提供四倍功率。</p>
<p>——引用自<a href="https://fr.wikipedia.org/wiki/Bipeur">Wikipedia</a></p>
</blockquote>
<p>了解了蜂鸣器的工作原理后，现在回到单片机原理图对实际情况进行分析</p>
<p><img src="/p/BEEP.png" alt="蜂鸣器"></p>
<p>从原理图中可以看到，蜂鸣器的一端接VCC，另一段接BZ，之前在LED灯模块我们也遇到过VCC这个管脚，并且通过二极管原理推断出了VCC处是高电平，那么VCC到底有什么含义呢</p>
<ul>
<li>VCC（Volt Current Condenser）电路的供电电压</li>
<li>GND（Ground）电线接地端</li>
</ul>
<p>以上两个在电路中常用的简写一个代表高电平，一个代表低电平，这样我们就能通过原理图更加明确地读出各个元器件工作时对应<code>I/O</code>口应该输出高电平还是低电平了</p>
<p>而BZ又是什么含义呢？</p>
<p><img src="/p/ULN2003D.png" alt="ULN2003D"></p>
<p>仔细观察原理图，我们还可以在<code>ULN2003D</code>这个芯片的管脚处看到BZ的身影：<code>P1^5</code>连接<code>IN5</code>，<code>IN5</code>连接<code>OUT5</code>，<code>OUT5</code>连接<code>BZ</code>，因此，我们可以通过控制<code>P1^5</code>输出的高低电平来控制BZ的高低电平进而控制蜂鸣器，那么为什么需要使用<code>ULN2003D</code>芯片对蜂鸣器进行驱动呢，这是因为该元件内含7个达林顿管，在电子电路里的主要特点是大电流容量和高电压输出，常作为驱动器使用，可以直接驱动蜂鸣器，继电器，步进马达等负载</p>
<blockquote>
<p>ULN2003是一种高压大电流的<a href="https://bk.tw.lvfukeji.com/baike-%E5%85%B1%E5%B0%84%E6%A5%B5">共发射极</a><a href="https://bk.tw.lvfukeji.com/baike-%E9%81%94%E6%9E%97%E9%A0%93%E9%9B%BB%E6%99%B6%E9%AB%94">达林顿晶体管</a>数组<a href="https://bk.tw.lvfukeji.com/baike-%E7%A9%8D%E9%AB%94%E9%9B%BB%E8%B7%AF">集成电路</a>，内含7组达林顿对管，每组对管的<a href="https://bk.tw.lvfukeji.com/baike-%E9%9B%BB%E6%B5%81">电流</a>容量是500mA，输出的<a href="https://bk.tw.lvfukeji.com/baike-%E9%9B%BB%E5%A3%93">电压</a>最高50V。该集成电路还集成了7只共阴极形式连接的<a href="https://bk.tw.lvfukeji.com/baike-%E7%BB%AD%E6%B5%81%E4%BA%8C%E6%9E%81%E7%AE%A1">续流二极管</a>，用于电感性负载的开关动作的电流续流。</p>
<p>——引用自<a href="https://bk.tw.lvfukeji.com/baike-ULN2003A?wprov=srpw1_0">Wikipedia</a></p>
<p>达灵顿晶体管是<a href="https://bk.tw.lvfukeji.com/baike-%E7%94%B5%E5%AD%90%E5%AD%A6">电子学</a>中由两个（甚至多个）<a href="https://bk.tw.lvfukeji.com/baike-%E5%8F%8C%E6%9E%81%E6%80%A7%E6%99%B6%E4%BD%93%E7%AE%A1">双极性晶体管</a>（或者其他类似的集成电路或分立元件）组成的复合结构，通过这样的结构，经第一个双极性晶体管放大的电流可以进一步被放大。]这样的结构可以提供一个比其中任意一个双极性晶体管高得多的电流<a href="https://bk.tw.lvfukeji.com/baike-%E5%A2%9E%E7%9B%8A">增益</a>。在使用集成电流芯片的情况里，达灵顿晶体管可以使得芯片比使用两个分立晶体管元件占用更少的空间，因为两个晶体管可以共用一个<a href="https://bk.tw.lvfukeji.com/w/index.php?title=%E9%9B%86%E7%94%B5%E6%9E%81&action=edit&redlink=1">集电极</a>。达灵顿晶体管通常被封装在单一的芯片里，从外面看就像一个双极性晶体管。有时，集成电路芯片中会包含8个这样的结构方便使用。</p>
<p>——引用自<a href="https://bk.tw.lvfukeji.com/baike-%E9%81%94%E6%9E%97%E9%A0%93%E9%9B%BB%E6%99%B6%E9%AB%94">Wikipedia</a></p>
</blockquote>
<h2 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h2><p>有了以上知识，我们很容易就可以得知只需在程序中让<code>P1^5</code>管脚输出的电平以一定频率在高低电平间切换就可以控制蜂鸣器发出声音的音调</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit beep = P1^<span class="number">5</span>; <span class="comment">//定义控制蜂鸣器的I/O口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> time)</span></span>; <span class="comment">//延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    beep = ~beep; <span class="comment">//控制高低电平来回切换</span></span><br><span class="line">    delay(<span class="number">100</span>); <span class="comment">//延时0.9ms，使得发出声音的频率约为0.55KHz</span></span><br><span class="line">    <span class="comment">//高低电平之间切换时间相同，占空比为50%</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> time)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行，单片机成功发出声音，但是需要注意，在使用之前建议将蜂鸣器上的保护贴纸撕掉，不然可能会一定程度上影响发声的频率</p>
<p>如果要改变蜂鸣器发生的频率，只需要改变延时函数参数即可</p>
<p>那么如果要改变占空比来改变蜂鸣器发声的大小又该如何修改程序，其实只需要将<code>while</code>循环中的代码复制一下后再改一下<code>beep</code>的赋值即可，这样就可以通过修改两个延时函数延时之和所占比例来调节占空比进而调节声音大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit beep = P1^<span class="number">5</span>; <span class="comment">//定义控制蜂鸣器的I/O口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> time)</span></span>; <span class="comment">//延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    beep = <span class="number">1</span>; <span class="comment">//控制高电平</span></span><br><span class="line">    delay(<span class="number">50</span>); <span class="comment">//延时0.45ms</span></span><br><span class="line">     beep = <span class="number">0</span>; <span class="comment">//控制低电平</span></span><br><span class="line">    delay(<span class="number">150</span>); <span class="comment">//延时1.35ms</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> time)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但实际上通过调节占空比来调节蜂鸣器响度的方法效果并不好，在房间内进行135s持续响度测试得出以下数据</p>
<table>
<thead>
<tr>
<th></th>
<th><a href="mailto:&#x30;&#46;&#x31;&#49;&#75;&#72;&#x7a;&#64;&#x30;&#x2e;&#x31;">&#x30;&#46;&#x31;&#49;&#75;&#72;&#x7a;&#64;&#x30;&#x2e;&#x31;</a>%</th>
<th><a href="mailto:&#x30;&#x2e;&#x31;&#49;&#x4b;&#x48;&#122;&#x40;&#57;&#57;&#46;&#57;">&#x30;&#x2e;&#x31;&#49;&#x4b;&#x48;&#122;&#x40;&#57;&#57;&#46;&#57;</a>%</th>
<th>无蜂鸣器</th>
</tr>
</thead>
<tbody><tr>
<td>平均响度</td>
<td>26dB</td>
<td>33dB</td>
<td>11dB</td>
</tr>
</tbody></table>
<p>当然，增大响度的方法还有增大电压，但是在前期学习中难以实现增大电压的方法，并且在学习过程中蜂鸣器的响度对学习以及程序的正常运行没有影响，因此只需要知道改变占空比与电压都可以改变蜂鸣器的占空比即可</p>
<hr>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>通过本章的内容，我们又学习到了一种数据输出的方法，蜂鸣器的原理较为复杂，涉及到一部分电子知识，之前没有基础的同学也完全可以暂且忽略原理，只需要知道驱动蜂鸣器需要脉冲波，且在单片机上还需要通过一个大电流高电压的元器件来驱动即可，同时我们也发现要实现一项功能可能不止需要单个元件，还需要其他芯片配合使用，所以当遇到不熟悉的管脚不妨到其他元件上找找是否有这个管脚</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>单片机</tag>
        <tag>STC89C52</tag>
      </tags>
  </entry>
  <entry>
    <title>51单片机开发例程-1</title>
    <url>/p/7e4a71c5.html</url>
    <content><![CDATA[<h1 id="内容概述"><a href="#内容概述" class="headerlink" title="内容概述"></a>内容概述</h1><p>此文章致力于了解单片机开发的基础内容，需要能够读懂单片机原理图，具备一定C语言知识储备，能够使用Keil uVision对程序进行编译生成<code>.hex</code>文件，以及能够将编译好<code>.hex</code>文件通过烧录软件烧录进单片机中进行运行</p>
<p>由于撰写该文章时知识储备尚不足以及不具备数电模电知识的入门用户难以理解一部分知识，因此本文章不进行单片机原理以及各部件原理功能的分析，如有需要可自行从网络上查询相关教学视频进行学习</p>
<a id="more"></a>

<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>1.使用<code>STC89C52</code>的普中51-单核-A2单片机（本文以该单片机为样本）</li>
<li>2.能够正常下载驱动以及Keil等开发软件的Windows10.0系统PC</li>
<li>3.一根micro USB to USB A数据线</li>
</ul>
<h1 id="点亮第一个LED"><a href="#点亮第一个LED" class="headerlink" title="点亮第一个LED"></a>点亮第一个LED</h1><h2 id="LED模块原理"><a href="#LED模块原理" class="headerlink" title="LED模块原理"></a>LED模块原理</h2><p>在点亮LED前，我们首先需要知道点亮LED的原理以及如何点亮LED</p>
<img src="/p/7e4a71c5/LED.png" class title="LED灯">

<p>从原理图中我们可以看到，单片机上的LED模块是由8个LED灯电阻串联后并联而成，并且通过LED灯的方向我们可以得知，VCC处为高电平，<code>P2*</code>处为低电平时LED灯才会被点亮，反之由于二极管的单向导通性则LED灯不会被点亮，控制VCC处的电平无法控制单个LED灯，所以要控制LED灯就要通过<code>P20-P27</code>这8个<code>I/O</code>口的电平为低电平才能控制并点亮LED灯</p>
<h2 id="单片机核心原理"><a href="#单片机核心原理" class="headerlink" title="单片机核心原理"></a>单片机核心原理</h2><p>单片机核心控制外部电路的原理简单来说就是控制各个<code>I/O</code>口的高低电平来实现的，从单片机核心原理图中可以看到在核心引出的管脚中也有<code>P20-P27</code>这8个<code>I/O</code>口，那么我们只需要通过程序控制单片机<code>I/O</code>口输出的高低电平就可以直接控制LED灯</p>
<p><img src="/p/Core.png" alt="单片机核心"></p>
<h2 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h2><p>单片机使用的语言是C语言，编写程序需要一定C语言基础但是对C语言要求并不是特别高，基础薄弱也可以从最基础的例程中学习到C语言知识，并且由于单片机相比于在电脑上运行能够更好地锻炼实际应用能力，所以从单片机开始学习巩固C语言也是很好的选择</p>
<p>众所周知，在之前的C语言学习中，在写代码之前都要调用头文件以及<code>main</code>函数构建起代码基本的框架</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//代码内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理，在单片机开发中同样需要用到这些内容，但是由于电脑CPU核心的工作原理与单片机核心工作原理不同，我们需要调用的头文件也不同，并且我们需要让程序一直运行，那么就需要在<code>main</code>函数内添加一个<code>while</code>循环来实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt; //STC89C52单片机头文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//代码内容</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搭建好程序的框架之后就可以开始写程序了，从前面的原理分析可知，要让单片机上的LED灯发光，就要向P20-P27这8个<code>I/O</code>口中输出低电平，对应的LED灯就会被点亮</p>
<p>那么如何在程序中表示这些<code>I/O</code>口呢，只需要在P2与之后的数字中加入符号<code>^</code>就可以直接以变量的形式调用表示的端口，我们首先来尝试点亮第一个（D1）和最后一个（D8）LED灯</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    P2^<span class="number">0</span> = <span class="number">0</span>; <span class="comment">//点亮D1</span></span><br><span class="line">    P2^<span class="number">7</span> = <span class="number">0</span>; <span class="comment">//点亮D8</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行上述代码，编译器会报错</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MAIN.C(错误代码的行数):errer C141: syntax error near <span class="string">&#x27;=&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上述代码的含义为：在“=”附近的代码有语法错误，这是为什么呢？因为在<code>main</code>函数中，<code>^</code>是一个二进制逻辑运算符，代表异或运算，也就是参与运算的两个变量如果相同那么输出<code>0</code>，如果不同那么输出<code>1</code>，由于异或运算符已经进行了运算，所以在其之后不能加“=”号了，如果加了“=”号，那么这一行代码的错误就与<code>1+1=2</code>一样，把赋值运算符<code>=</code>与数学中的等于号<code>=</code>混淆了，编译器自然会报错</p>
<p>那么在程序中我们如何修改<code>P2^0</code>与<code>P2^7</code>这两个<code>I/O</code>口的电平呢，此时，我们就需要定义单个<code>I/O</code>口<code>sbit</code>来重新定义这两个<code>I/O</code>口</p>
<p>定义特殊寄存器的位变量<code>sbit</code>（在单片机开发中，说人话就是定义单个<code>I/O</code>口的指令），它的功能是定义单个<code>I/O</code>口，因此sbit的存储位数只有1位（如char：8位）即只有1和0两种情况，分别对应<code>I/O</code>口的高低电平</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//特殊寄存器的位变量定义格式 sbit 变量名 = 变量；</span></span><br><span class="line">sbit LED1 = P2^<span class="number">0</span>；</span><br></pre></td></tr></table></figure>
<p>知道了以上知识，就可以写出正确的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit LED1 = P2^<span class="number">0</span>;</span><br><span class="line">sbit LED8 = P2^<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  LED1 = <span class="number">0</span>;</span><br><span class="line">  LED8 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行后单片机LED灯模块只有D1和D8两个LED灯持续亮起，证明程序正确</p>
<h1 id="控制LED灯闪烁"><a href="#控制LED灯闪烁" class="headerlink" title="控制LED灯闪烁"></a>控制LED灯闪烁</h1><h2 id="LED灯闪烁原理"><a href="#LED灯闪烁原理" class="headerlink" title="LED灯闪烁原理"></a>LED灯闪烁原理</h2><p>要使LED灯不断闪烁，我们就需要让控制LED灯亮起的<code>I/O</code>口在1和0之前来回切换，并且每次切换后都有一定的延时来保证人眼能够看到闪烁的效果，此时就需要用到一个函数：延时函数</p>
<h2 id="晶振原理"><a href="#晶振原理" class="headerlink" title="晶振原理"></a>晶振原理</h2><p>延时函数要控制的参数必然是延时的时常，要使得单片机能够控制时长，我们就需要用到单片机上计时的重要组件：晶振</p>
<blockquote>
<p>晶体是指其中的原子、分子、或离子以规则、重复的模式朝各方向延伸的一种固体。</p>
<p>晶体与几乎所有的<a href="https://bk.tw.lvfukeji.com/baike-%E5%BD%88%E6%80%A7">弹性</a>物质都具有自然共振频率，透过适当的<a href="https://bk.tw.lvfukeji.com/baike-%E4%BC%A0%E6%84%9F%E5%99%A8">传感器</a>可加以利用。例如<a href="https://bk.tw.lvfukeji.com/baike-%E9%92%A2">钢铁</a>具有良好弹性、音速快，在石英晶体大量应用以前，钢铁被用作<a href="https://bk.tw.lvfukeji.com/baike-%E6%A9%9F%E6%A2%B0%E6%BF%BE%E6%B3%A2%E5%99%A8">机械式滤波器</a>。共振频率取决于晶体的尺寸、形状、弹性、与物质内的音速。高频用的晶体通常是切成简单的形状，如方形片状。典型的低频用晶体则常切成<a href="https://bk.tw.lvfukeji.com/baike-%E9%9F%B3%E5%8F%89">音叉</a>形，例如手表所使用的。如不需要太高的精确度，则也可以使用<a href="https://bk.tw.lvfukeji.com/w/index.php?title=%E9%99%B6%E7%93%B7%E8%AB%A7%E6%8C%AF%E5%99%A8&action=edit&redlink=1">陶瓷谐振器</a>取代石英晶体谐振器。</p>
<p>运用石英晶体上的电极对一颗被适当切割并安置的石英晶体施以<a href="https://bk.tw.lvfukeji.com/baike-%E9%9B%BB%E5%A0%B4">电场</a>时，晶体会产生变形。这就是逆压电效应。当外加电场移除时，石英晶体会恢复原状并发出电场，因而在电极上产生电压。这样的特性造成石英晶体在电路中的行为，类似于某种<a href="https://bk.tw.lvfukeji.com/baike-%E9%9B%BB%E6%84%9F%E5%99%A8">电感器</a>、<a href="https://bk.tw.lvfukeji.com/baike-%E9%9B%BB%E5%AE%B9%E5%99%A8">电容器</a>、与<a href="https://bk.tw.lvfukeji.com/baike-%E9%9B%BB%E9%98%BB%E5%99%A8">电阻器</a>所组合成的<a href="https://bk.tw.lvfukeji.com/baike-RLC%E7%94%B5%E8%B7%AF">RLC电路</a>。组合中的<a href="https://bk.tw.lvfukeji.com/baike-%E9%9B%BB%E6%84%9F">电感</a><a href="https://bk.tw.lvfukeji.com/baike-%E9%9B%BB%E5%AE%B9">电容</a>谐振频率则反映了石英晶体的实体共振频率。</p>
<p>石英晶体的优点是在温度变化时，影响震荡频率的弹性系数与尺寸变化轻微，因而在频率特性上表现稳定。共振的特性还取决于振动模式与石英的切割角度（相对于晶轴而言），目前常用的是AT切割，它的振荡是厚度剪切（thickness shear）振荡模式。此外，在需要高精密度与稳定性的严格场合，石英晶体会放置于<a href="https://bk.tw.lvfukeji.com/w/index.php?title=%E6%81%86%E6%BA%AB%E7%AE%B1&action=edit&redlink=1">恒温箱</a>与吸振容器内，以防止外部温度与震动的干扰。</p>
<p>——引用自<a href="https://bk.tw.lvfukeji.com/wiki/%E6%99%B6%E6%8C%AF#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">Wikipedia</a></p>
</blockquote>
<p>简而言之就是晶振会以一个固定频率进行震荡，从而输出一个周期等于振荡周期的脉冲波，单片机通过这个固定频率的脉冲波来实现对时间的控制，单片机上使用的晶振频率为11.0592MHz，而一个机器周期（单片机运行一句代码的时长）是12个震荡周期，通过计算可以大致求得运行100,000（10万）条代码所需的时长为0.9216s，为了便于计算，可以四舍五入求得运行10w条代码所需的时间为0.9s</p>
<h2 id="延时函数"><a href="#延时函数" class="headerlink" title="延时函数"></a>延时函数</h2><p>要控制延时的时长就要控制延时函数内所执行的代码的数量，通过输入要执行代码的条数在函数内进行减法运算是实现延时函数最好的方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span> <span class="params">(<span class="keyword">int</span> time)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(time --)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们需要的延时超过了int的范围怎么办？此时可以使用<code>long</code>等能够存储位数较长的变量，由于延时函数所用到的数字都是正数，也可以使用<code>unsigned</code>来将所需范围扩大至原来的2倍，但是<code>unsigned int</code>这样的变量类型太长，如何简单地表示一个变量类型，可以使用声明定义<code>typedef</code>来重新声明变量类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式 typedef 被重新声明的变量类型 重新声明的变量类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8 <span class="comment">//代表8位正变量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16 <span class="comment">//代表16位正变量</span></span><br></pre></td></tr></table></figure>
<h2 id="编写程序-1"><a href="#编写程序-1" class="headerlink" title="编写程序"></a>编写程序</h2><p>有了延时函数，实现LED灯的闪烁便十分简单</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit LED1 = P2^<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> time)</span></span>; <span class="comment">//定义延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    LED1 = <span class="number">0</span>; <span class="comment">//控制LED灯亮起</span></span><br><span class="line">    delay(<span class="number">50000</span>); <span class="comment">//延时约450ms</span></span><br><span class="line">    LED1 = <span class="number">1</span>; <span class="comment">//控制LED灯熄灭</span></span><br><span class="line">    delay(<span class="number">50000</span>); <span class="comment">//延时约450ms</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> time)</span></span>&#123; <span class="comment">//定义延时函数</span></span><br><span class="line">  <span class="keyword">while</span>(time --)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述程序中，我们使用的变量是位变量，因此也可以使用二进制逻辑运算</p>
<ul>
<li>与运算<code>&amp;</code>         有0得0</li>
<li>或运算<code>|</code>         有1得1</li>
<li>非运算<code>~</code>         取反</li>
<li>异或运算<code>^</code>     不同为1，相同为0</li>
</ul>
<p>在之前通过讲解为什么不能在程序中直接使用<code>P2^0</code>已经了解到了异或运算，这里列举最基础也是最常用的4种二进制逻辑运算，结合本例程我们可以使用非运算来进行LED亮与不亮的切换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit LED1 = P2^<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> time)</span></span>; <span class="comment">//定义延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    LED1 = ~LED1; <span class="comment">//切换LED灯状态</span></span><br><span class="line">    delay(<span class="number">50000</span>); <span class="comment">//延时约450ms</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> time)</span></span>&#123; <span class="comment">//定义延时函数</span></span><br><span class="line">  <span class="keyword">while</span>(time --)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="LED流水灯"><a href="#LED流水灯" class="headerlink" title="LED流水灯"></a>LED流水灯</h1><h2 id="宏定义端口"><a href="#宏定义端口" class="headerlink" title="宏定义端口"></a>宏定义端口</h2><p>要使得8个LED灯依次亮起，就要用到全部8个P2端口的<code>I/O</code>口，使用<code>sbit</code>进行逐个定义可以实现功能，但是变量过多程序编写太过复杂，因此可以使用宏定义定义整个<code>P2</code>端口进行程序编写</p>
<p>宏定义<code>#define</code>属于预处理指令，“宏定义”也就是全局定义，也就是说进行宏定义的变量不单单可以在<code>main</code>函数中调用，其他的函数中同样可以调用，而“预处理”顾名思义，也就是在<code>main</code>函数执行之前，预先执行的指令，我们可以通过<code>main</code>函数来对端口，表达式或者是数字进行宏定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//宏定义格式 #define 变量名 变量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED P2 <span class="comment">//定义整个端口</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi 3.1415926 <span class="comment">//定义数字变量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A x+y <span class="comment">//定义一个表达式</span></span></span><br></pre></td></tr></table></figure>
<p>如何通过改变<code>P2</code>端口的值来改变其中的8个<code>I/O</code>口的值呢？<code>P2^0</code>相当于1位变量，那么<code>P2</code>端口就相当于8位变量，因为在编写程序之前LED灯是不亮的，故<code>P2</code>端口各<code>I/O</code>口初始时为高电平，用位来表示也就是8个<code>I/O</code>口的值均为1，<code>P2</code>就等于<code>0b 1111 1111</code>，<code>I/O</code>口在端口中的分布顺序为从右向左，也就是当D1灯亮起的时候<code>P2=0b 1111 11110</code>，然而在Keil uVision中不支持二进制的表示，我们可以通过8进制，10进制，16进制来表示，由于16进制每1位正好可以表示2进制中的4位，因此我们常用16进制来进行数据的输入，比如要使得D1亮起就要让<code>P2=0xFE</code>，要使得D8亮起就要让<code>P2=0x7F</code></p>
<h2 id="编写程序-2"><a href="#编写程序-2" class="headerlink" title="编写程序"></a>编写程序</h2><p>要简单地实现流水灯的效果，就要按位进行运算，此处引入一个新的头文件<code>intrins.h</code>这个头文件中包含了二进制循环左移&amp;循环右移的运算</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_crol_(变量,位数) <span class="comment">//循环左移</span></span><br><span class="line">_cror_(变量,位数) <span class="comment">//循环右移</span></span><br></pre></td></tr></table></figure>
<p>以循环左移为例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运算前后：0b 1111 1110 ----&gt; 0b 1111 1101</span><br><span class="line">数值溢出后回到第一位：0b 0111 1111 ----&gt; 0b 1111 1110</span><br></pre></td></tr></table></figure>
<p>因此使用二进制循环移动可以实现LED灯依次亮起并熄灭</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED P2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> time)</span></span>; <span class="comment">//定义延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  LED = <span class="number">0xFE</span>; <span class="comment">//初始化LED灯模块使得D1灯亮起</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    delay(<span class="number">50000</span>); <span class="comment">//延时约450ms</span></span><br><span class="line">    LED = _crol_(LED,<span class="number">1</span>); <span class="comment">//LED灯从左向右依次亮起熄灭</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> time)</span></span>&#123; <span class="comment">//定义延时函数</span></span><br><span class="line">  <span class="keyword">while</span>(time --)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在之前的C语言学习中，我们还学习过二进制运算的左移&amp;右移运算<code>&lt;&lt;</code>&amp;<code>&gt;&gt;</code>这两个运算区别于循环运算</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LED = LED &lt;&lt; <span class="number">1</span>; <span class="comment">//左移</span></span><br><span class="line"><span class="number">0b</span> <span class="number">1111</span> <span class="number">1110</span> —&gt; <span class="number">0b</span> <span class="number">1111</span> <span class="number">1100</span></span><br><span class="line">LED = _crol_(LED,<span class="number">1</span>) <span class="comment">//循环左移</span></span><br><span class="line"><span class="number">0b</span> <span class="number">1111</span> <span class="number">1110</span> —&gt; <span class="number">0b</span> <span class="number">1111</span> <span class="number">1101</span></span><br></pre></td></tr></table></figure>
<p>也就是说只需稍加修改刚刚的流水灯的代码就可以通过位移运算实现LED灯依次亮起但是不熄灭的效果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED P2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> time)</span></span>; <span class="comment">//定义延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(LED == <span class="number">0x00</span>)&#123;LED = <span class="number">0x01</span>;&#125; <span class="comment">//LED灯全部亮起使得D1灯熄灭</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LED == <span class="number">0xFF</span>)&#123;LED = <span class="number">0xFE</span>;&#125; <span class="comment">//LED灯全部熄灭使得D1灯亮起</span></span><br><span class="line">    delay(<span class="number">50000</span>); <span class="comment">//延时约450ms</span></span><br><span class="line">    LED = LED &lt;&lt; <span class="number">1</span>; <span class="comment">//LED灯从左向右依次亮起</span></span><br><span class="line">    delay(<span class="number">50000</span>); <span class="comment">//延时约450ms</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> time)</span></span>&#123; <span class="comment">//定义延时函数</span></span><br><span class="line">  <span class="keyword">while</span>(time --)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在点亮D1-D8这8个LED灯的过程中，尤其是流水灯这种动态点亮LED灯的程序执行的过程中，我们可以发现动态数码管模块上的数字也会随着LED灯的点亮而进行“不规律”的闪烁，通过观察原理图可以看到，在其他很多模块比如<code>EEPROM模块</code>,<code>74HC138译码器</code>中都出现了<code>P2</code>端口中的<code>I/O</code>口，这是由于单片机上的<code>I/O</code>口的数量较少，不像桌面CPU那样动辄上千个管脚，因此需要节约<code>I/O</code>口，用尽可能少的<code>I/O</code>口实现尽可能多的功能，因此在某些情况下可能会出现这样的冲突现象，由于51单片机仅供学习使用，我们一般来说是学习单片机上各个模块的作用，要自行编写一个较大的工程则需要自行根据需要实现的功能来设计电路，所以对于学习用的单片机上这样的冲突情况我们可以暂且忽略，只需要实现需要实现的功能内容即可</p>
<p><img src="/p/STC89C52.png" alt="单片机"></p>
<p>单片机的学习的核心是实践，通过在单片机上运行所写的程序能够直观的看到程序运行的状况以及结果如何，进而通过对程序进行调整，并且也能通过将自己的想法在单片机上运行起来来增长自己的知识储备以及实践能力</p>
<p>千里之行始于足下，通过点亮LED say <code>Hello World！</code></p>
<hr>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>通过将自己的学习进度以及学习到的内容以编写教程来体现出来，能够更好地巩固自己的知识的同时也能发现自己在某些知识面上的不足，并且为自己之后回顾基础知识提供了宝贵的材料，也对将要或者正在学习单片机的朋友提供一定帮助，今天是2月1日，我将会在2月这4周内完成单片机的学习并撰写相关教程，由于知识储备不足以及相关技术材料没有带回家，在撰写本文时一定会有在知识层面不足以及理解偏差之处，若能指正感激不尽，PC端可以通过右下角打开我的联系方式，手机端由于该模块的缺失快捷链接放在此处，联系方式仅限于Email和Telegram，由于个人隐私信息问题暂时不提供QQ，WeChat等联系方式</p>
<ul>
<li><a href="mailto:watermeter114514@foxmail.com">E-Mail</a></li>
<li><a href="https://t.me/miaobiao">Telegram</a></li>
<li><a href="https://github.com/CNwatermeter">Github</a></li>
</ul>
<hr>
<p><i class="fa fa-repeat" aria-hidden="true"></i>   更新于2020/2/22</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>单片机</tag>
        <tag>STC89C52</tag>
      </tags>
  </entry>
  <entry>
    <title>51单片机开发例程-4</title>
    <url>/p/f398.html</url>
    <content><![CDATA[<h1 id="内容概述"><a href="#内容概述" class="headerlink" title="内容概述"></a>内容概述</h1><p>在之前三章的内容中，我们学习到了三种信息输出的方法：独立LED灯，蜂鸣器，数码管，这一章我们开始学习信息输入的方法，相信你早就看到了主板上K1-K4四个独立按键以及S1-S16十六个矩阵按键，这些都是通过按键输入信息来控制单片机执行特定程序的有效方法，当然，在学习之前，你需要先将红外接收原件取下，具体原因我将在本章内容中讨论</p>
<a id="more"></a>

<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>1.使用<code>STC89C52</code>的普中51-单核-A2单片机（本文以该单片机为样本）</li>
<li>2.能够正常下载驱动以及Keil等开发软件的Windows10.0系统PC</li>
<li>3.一根micro USB to USB A数据线</li>
<li>4.取下IR1红外接收器模块</li>
</ul>
<h1 id="独立按键"><a href="#独立按键" class="headerlink" title="独立按键"></a>独立按键</h1><h2 id="独立按键原理"><a href="#独立按键原理" class="headerlink" title="独立按键原理"></a>独立按键原理</h2><p>单片机上使用的开关为轻触开关，是一种电子开关，轻轻按开关按钮就可以使开关接通，松开手后开关断开，开关如下图所示，有四个引脚，两两连接分为初始导通和初始不导通，其效果顾名思义</p>
<img src="/p/f398/qckg.png" class title="轻触开关原理">

<p>再看开发版原理图，原理非常简单，单片机<code>I/O</code>口与<code>GND</code>通过轻触开关连接，当按键按下时，对应的<code>I/O</code>口就为低电平，只需要单片机检测对应的<code>I/O</code>口是否为低电平就可得知按键是否被按下</p>
<img src="/p/f398/dlaj.png" class title="独立按键模块">

<h2 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h2><p>由于轻触开关内部为机械结构，按键按下时可能会存在抖动现象，也就是说当按下开关时，开关导通，由于内部某些原因，开关闭合然后又导通，导致按下一次开关后实际单片机核心检测到两次，或者说你没有按下按键，按键自行导通，因此我们需要消除抖动，那么如何消除抖动呢？此时我们就又需要用到延时函数，我们检测开关按下后，延时一段时间，再次检测开关是否闭合，如果第二次检测也闭合，那么就说明按键导通，因为抖动时间很短，所以延时足够长就可以消除抖动，因为人按下按键的时间相对于内部代码执行的时间非常长，因此也不必担心影响到正常按下按键</p>
<blockquote>
<p>观察开发板原理图我们可以看到，红外接收模块也接到了<code>P3^2</code>管脚上，因此如果不拔下红外接收器模块，实验现象就会受到干扰，因为在我们生活中红外线无处不在，即便是不按下按键，对应的程序也会运行，你不妨将下列程序修改一下，将输入的按键改为<code>P3^2</code>，你会观察到LED灯无规律闪烁，至于为什么把这些管脚接在一起，那是因为单片机管脚有限，开发板的作用就是容纳尽可能多的功能以供学习，因此管脚重复不可避免</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED P2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8;</span><br><span class="line">sbit K1 = P3^<span class="number">1</span>;</span><br><span class="line">sbit K2 = P3^<span class="number">0</span>;</span><br><span class="line">sbit K3 = P3^<span class="number">2</span>;</span><br><span class="line">sbit K4 = P3^<span class="number">3</span>; <span class="comment">//定义各个独立按键</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(K1 == <span class="number">0</span>)&#123;</span><br><span class="line">      delay(<span class="number">1000</span>) <span class="comment">//消除抖动</span></span><br><span class="line">        <span class="keyword">if</span>(K1 == <span class="number">0</span>)&#123;</span><br><span class="line">          LED = ~LED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(time --);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上述程序，我们可以观察到，按下按键LED灯亮起，但是松手后，LED灯可能亮起也可能熄灭，这是因为按下后程序一直在执行，LED一直在亮与不亮之间变化，只不过速度很快人眼看不到，就好像动态数码管刷新人眼无法察觉一样，因此我们要在按键按下之后锁定当前状态，如果未松开则进入一个循环使其不改变LED的状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED P2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8;</span><br><span class="line">sbit K1 = P3^<span class="number">1</span>;</span><br><span class="line">sbit K2 = P3^<span class="number">0</span>;</span><br><span class="line">sbit K3 = P3^<span class="number">2</span>;</span><br><span class="line">sbit K4 = P3^<span class="number">3</span>; <span class="comment">//定义各个独立按键</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(K1 == <span class="number">0</span>)&#123;</span><br><span class="line">      delay(<span class="number">1000</span>) <span class="comment">//消除抖动</span></span><br><span class="line">        <span class="keyword">if</span>(K1 == <span class="number">0</span>)&#123;</span><br><span class="line">          LED = ~LED;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">while</span>(!K1); <span class="comment">//检测按键是否松开，如果松开那么跳出循环，并且由于按键松开，之前的程序也不再执行，也就是说LED灯状态不再变化，如果没有松开则进入循环直到松开为止</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(time --);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>独立按键的核心要点也就是消除抖动和检测按键是否松开这两点，其他使用方法都可以根据这两点来展开，有些较为简单的使用方法甚至用不到检测是否松开这一点，这部分内容大家可以自己多尝试不同的内容</p>
<h1 id="矩阵按键"><a href="#矩阵按键" class="headerlink" title="矩阵按键"></a>矩阵按键</h1><h2 id="矩阵按键原理"><a href="#矩阵按键原理" class="headerlink" title="矩阵按键原理"></a>矩阵按键原理</h2><p>我们刚刚已经知道了单片机上所使用的轻触开关的原理以及使用方法了，这次我们直接来看原理图：16个按键连接8个管脚，再仔细看其连接方式，我们很容易就能得知：4+4=8，4*4=16，这8个管脚就像是XY轴一样通过两个XY管脚我们就可以确定任意一个开关的位置，因此，要从程序上确定是按下了哪个按键，我们就要分别对列和行进行扫描</p>
<img src="/p/f398/jzaj.png" class title="矩阵按键模块">

<h2 id="编写程序-1"><a href="#编写程序-1" class="headerlink" title="编写程序"></a>编写程序</h2><p>我们如何通过横向和纵向4+4两组管脚来确定是哪一个开关被按下了呢？我们对横向输入高电平，然后检测横向哪个管脚是低电平来确定纵向位置；对纵向输入高电平，然后检测纵向哪个管脚是低电平来确定横向位置，在确定横向纵向位置之前，我们依然要进行消抖的处理，在确定后，也要进行松手检测的处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_KEY P1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>;</span><br><span class="line"><span class="function">u8 <span class="title">KeyDown</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    KeyDown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(time --);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">u8 <span class="title">KeyDown</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="comment">//按键检测函数</span></span><br><span class="line">  u8 KeyValue;</span><br><span class="line">  u8 a = <span class="number">0</span>;</span><br><span class="line">  GPIO_KEY = <span class="number">0x0F</span>; <span class="comment">//对横向输入高电平，测试列</span></span><br><span class="line">  <span class="keyword">if</span>(GPIO_KEY != <span class="number">0x0F</span>)&#123; <span class="comment">//如果P1端口电平与刚刚输入的不同，说明有按键被按下</span></span><br><span class="line">    delay(<span class="number">1000</span>); <span class="comment">//按键消抖</span></span><br><span class="line">    <span class="keyword">if</span>(GPIO_KEY != <span class="number">0x0F</span>)&#123; <span class="comment">//再次检测</span></span><br><span class="line">      <span class="keyword">switch</span>(GPIO_KEY)&#123; <span class="comment">//检测，为其赋值每一列第一行代表的数字</span></span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0x07</span>):KeyValue = <span class="number">0</span>;<span class="keyword">break</span>; <span class="comment">//第1列</span></span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0x0b</span>):KeyValue = <span class="number">1</span>;<span class="keyword">break</span>; <span class="comment">//第2列</span></span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0x0d</span>):KeyValue = <span class="number">2</span>;<span class="keyword">break</span>; <span class="comment">//第3列</span></span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0x0e</span>):KeyValue = <span class="number">3</span>;<span class="keyword">break</span>; <span class="comment">//第4列</span></span><br><span class="line">      &#125;</span><br><span class="line">      GPIO_KEY = <span class="number">0xF0</span>; <span class="comment">//对纵向输入高电平，测试行</span></span><br><span class="line">      <span class="keyword">switch</span>(GPIO_KEY)&#123; <span class="comment">//检测，因为每一行之间差值为4，只需要加4*（行数-1）</span></span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0x70</span>):KeyValue += <span class="number">4</span> * <span class="number">0</span>;<span class="keyword">break</span>; <span class="comment">//第1行</span></span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0xb0</span>):KeyValue += <span class="number">4</span> * <span class="number">1</span>;<span class="keyword">break</span>; <span class="comment">//第2行</span></span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0xd0</span>):KeyValue += <span class="number">4</span> * <span class="number">2</span>;<span class="keyword">break</span>; <span class="comment">//第3行</span></span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0xe0</span>):KeyValue += <span class="number">4</span> * <span class="number">3</span>;<span class="keyword">break</span>; <span class="comment">//第4行</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>((a &lt; <span class="number">50</span>) &amp;&amp; (GPIO_KEY != <span class="number">0xF0</span>))&#123; <span class="comment">//按键松手检测</span></span><br><span class="line">    delay(<span class="number">100</span>);</span><br><span class="line">    a ++; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> KeyValue; <span class="comment">//返回按键值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么我们不直接使用<code>while(GPIO_KEY != 0xf0);</code>呢？因为矩阵按键是行列扫描来确定按键位置的，扫描完成后才知道按下哪个按键，并且按下的按键数值除存在一个变量中（之前的独立按键按键数值表示位对应<code>I/O</code>口的高低电平），如果按键没有被按下，程序扫描完一次后，进入while死循环，程序卡死，因此我们必须为松手检测设定一个时间范围，超出时间范围自动跳出循环，在时间范围内每隔一段时间就检测一下按键是否松开，因此即便是按键一直不松开或者说按键根本没有按下也不会影响程序的正常运行，并且实际上<code>whiile</code>中对<code>a</code>的范围限制并没有很严格，只需a是正整数并且不要太大就可以，如果a太大那么需要长时间按下程序才会相应</p>
<p>运行上述代码我们注意到，单片机蜂鸣器发出列声音，声音的频率由按键检测的时长有关，回顾之前的内容，会发现蜂鸣器的管脚连接到了<code>P1^5</code>并且矩阵按键行列扫描使得<code>P1</code>端口高低电平发生变化，产生了一定的脉冲信号，因此矩阵按键不可避免的会影响到蜂鸣器</p>
<p>为了让我们知道所按下的按键是哪个按键，我们将其从左到右从上到下按顺序赋予其16进制数字，正好16个按键可以表示16进制的16个数字0～F，此程序只需要将上一章节编写的函数添加到程序中即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_DIG P0 <span class="comment">//宏定义数码管端口</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_KEY P1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8;</span><br><span class="line">u8 KeyValue; <span class="comment">//定义按键全局变量</span></span><br><span class="line">sbit beep = P1^<span class="number">5</span>; <span class="comment">//定义制蜂鸣器</span></span><br><span class="line">sbit SLA = P2^<span class="number">2</span>;</span><br><span class="line">sbit SLB = P2^<span class="number">3</span>;</span><br><span class="line">sbit SLC = P2^<span class="number">4</span>; <span class="comment">//定义译码管ABC三个输入</span></span><br><span class="line">u8 code SMG[]=&#123; <span class="comment">//在ROM中存储数码管段码的数组</span></span><br><span class="line">  <span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line">  <span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line">  <span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>; <span class="comment">//动态数码管显示函数</span></span><br><span class="line"><span class="function">u8 <span class="title">KeyDown</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    KeyDown();</span><br><span class="line">    DigDisplay(KeyValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(time --);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">u8 <span class="title">KeyDown</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; </span><br><span class="line">  u8 a = <span class="number">0</span>;</span><br><span class="line">  GPIO_KEY = <span class="number">0x0F</span>; </span><br><span class="line">  <span class="keyword">if</span>(GPIO_KEY != <span class="number">0x0F</span>)&#123; </span><br><span class="line">    delay(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">if</span>(GPIO_KEY != <span class="number">0x0F</span>)&#123; </span><br><span class="line">      <span class="keyword">switch</span>(GPIO_KEY)&#123; </span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0x07</span>):KeyValue = <span class="number">0</span>;<span class="keyword">break</span>; </span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0x0b</span>):KeyValue = <span class="number">1</span>;<span class="keyword">break</span>; </span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0x0d</span>):KeyValue = <span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0x0e</span>):KeyValue = <span class="number">3</span>;<span class="keyword">break</span>; </span><br><span class="line">      &#125;</span><br><span class="line">      GPIO_KEY = <span class="number">0xF0</span>; </span><br><span class="line">      <span class="keyword">switch</span>(GPIO_KEY)&#123; </span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0x70</span>):KeyValue += <span class="number">4</span> * <span class="number">0</span>;<span class="keyword">break</span>; </span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0xb0</span>):KeyValue += <span class="number">4</span> * <span class="number">1</span>;<span class="keyword">break</span>; </span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0xd0</span>):KeyValue += <span class="number">4</span> * <span class="number">2</span>;<span class="keyword">break</span>; </span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0xe0</span>):KeyValue += <span class="number">4</span> * <span class="number">3</span>;<span class="keyword">break</span>; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>((a &lt; <span class="number">1</span>) &amp;&amp; (GPIO_KEY != <span class="number">0xF0</span>))&#123; </span><br><span class="line">    delay(<span class="number">100</span>);</span><br><span class="line">    a ++; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> KeyValue; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>&#123; <span class="comment">//动态数码管显示函数</span></span><br><span class="line">  <span class="keyword">long</span> LED = <span class="number">10</span>; <span class="comment">//LED是要显示的数码管的位数，同时作为除数求num长度</span></span><br><span class="line">  u8 numlong = <span class="number">1</span>; <span class="comment">//数字长度</span></span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">99999999</span>)&#123; <span class="comment">//数字超长则触发蜂鸣器警报</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;beep = ~beep;delay(<span class="number">100</span>);&#125;&#125;</span><br><span class="line">  <span class="keyword">while</span>(num / LED)&#123; <span class="comment">//求数字长度</span></span><br><span class="line">    LED *= <span class="number">10</span>;</span><br><span class="line">    numlong ++;&#125; </span><br><span class="line">  <span class="keyword">for</span>(LED = <span class="number">8</span>; LED &gt; <span class="number">8</span> - numlong; LED--)&#123; <span class="comment">//每次扫描循环执行8次</span></span><br><span class="line">    <span class="comment">//为了让高于输入数字位数的数码管不显示，因此我们要将数字长度带入循环，使得刷新完输入数字所在位数即停止，那么未扫描到的数码管就会不显示数字</span></span><br><span class="line">    <span class="keyword">switch</span>(LED)&#123;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">1</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//要显示第1位也就是要让如图LED8输出为0低电平，以下以此类推</span></span><br><span class="line">        <span class="keyword">case</span>(<span class="number">2</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">3</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">4</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">5</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">6</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">7</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">8</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    GPIO_DIG = SMG[num % <span class="number">10</span>]; <span class="comment">//第几个数码管显示数字几</span></span><br><span class="line">    num /= <span class="number">10</span>; <span class="comment">//数字减位</span></span><br><span class="line">    delay(<span class="number">100</span>); <span class="comment">//间隔一段时间扫描</span></span><br><span class="line">    GPIO_DIG = <span class="number">0x00</span>; <span class="comment">//消隐</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上程序是直接添加函数进入到主函数，将<code>KeyValue</code>变量定义在函数外，这样就可以锁定其数值使其只在按键按下刷新时被更改，说人话就是按下按键2，数码管会一直显示2，如果不使变量<code>KeyValue</code>定义在函数外，那么数码管只会在按下按键时显示对应的数字，松开手后恢复原状，由于之前所写的显示函数功能远多于此程序需求，因此优化空间非常大，由于是学习示例，此处不再对其进行优化，能达到目的即可</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>本章节学习到了一个非常有效并且常用的数据输入的方法：开关按键，理论上在学习完以上4个章节的内容后，你就可以大致上开发出一个十分简易的计算器程序，自行编写计算器程序是你巩固之前内容的十分有效的方法，期间可能会有一些问题但是前面的知识基本可以解决，不过还是要提醒一下，目前所学知识并不多，所以编写出的计算器程序功能不会太强大，编写时一定要从最基础最简单的功能开始编写，就像上一章数码管输出数字从正整数这样最简单的数字开始一样，计算器的编写作为一个项目我会单独展开讨论不算入开发例程中</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>单片机</tag>
        <tag>STC89C52</tag>
      </tags>
  </entry>
  <entry>
    <title>51单片机开发例程-5</title>
    <url>/p/3359.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>单片机</tag>
        <tag>STC89C52</tag>
        <tag>74HC595</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/p/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>iPad书写体验</title>
    <url>/p/a833.html</url>
    <content><![CDATA[<p>iPad书写体验一直以来都被人们所诟病，因为Apple  pencil与屏幕阻尼过小导致大部分人体验极差，因此自从Apple pencil问世以来，人们就在不停探寻改善Apple pencil书写体验的方法，就目前来说，主流方法有：类纸膜，笔尖套以及第三方笔尖</p>
<!--- more --->

<p>首先我先说一下结论，单纯看书写体验，最好的是类纸膜+原装笔尖，其次是以珞小希笔尖为代表的第三方2B笔尖，最次是笔尖套，这三种方法各有各的优点，适用的人群也大不相同，并且每个人的书写体验以及习惯具有很强的主观性，因此以下内容仅为我的个人体验，并不代表客观评价</p>
<h1 id="类纸膜-原装笔尖"><a href="#类纸膜-原装笔尖" class="headerlink" title="类纸膜+原装笔尖"></a>类纸膜+原装笔尖</h1><blockquote>
<p>优点：还原纸质书写体验</p>
<p>缺点：类纸膜价格昂贵，严重影响屏幕分辨率，磨损笔尖(?)</p>
</blockquote>
<p>这个方案是目前绝大多数人在使用的方案，也是我最初使用iPad书写时使用的方案，当初刚拿到iPad之后立马就贴上了类纸膜开始使用了起来，虽然与纸质书写还是有点一点不同，不过能够很快适应，类纸膜表面的磨砂感能够很好还原在纸上书写的感觉并且能够提供良好的阻尼感，因此为绝大多数人所追捧</p>
<p>但是，类纸膜价格比较贵，价格差不多是钢化膜的2倍以上，不过个人感觉没有必要购买太贵的类纸膜，因为类纸膜本质上区别并不大，高价类纸膜提供的体验并不符合其价位，个人认为类纸膜选购价格在50-100元左右即可，之前有听说过这样一个说法：低价的类纸膜不是类纸膜是磨砂膜，个人认为这句话就跟凤梨不是菠萝，车厘子不是樱桃一样，具体什么意思自己体会一下吧</p>
<p>类纸膜对于屏幕分辨率的影响有多大？个人观感分辨率砍半，换算下来也就是iPad的分辨率被砍到720p～1080p之间的水平，这个说法毫不夸张，因为类纸膜表面的颗粒会严重影响分辨率，更加可怕的是，表面的颗粒会折射屏幕光线，导致你看屏幕会有类似相机拍照出现的彩噪，如果你要兼顾观影体验的话，这个影响无异于直接给你打回视网膜屏前的iPad（iPad1，iPad2），有的人大概是能接受或者说能凑合，反正我有点接受不了了</p>
<p>磨损笔尖这个说法见很多人说过，不过我不知道是我写的太少了还是那些人下笔太重？个人notability笔记差不多1000页应该是有了吧，笔尖能看到磨损但是并不影响正常使用，如果那些人是因为磨损笔尖不好看而不是磨损笔尖导致不能用那我也无力吐槽，个人觉得有点迷惑，笔尖生来就是为了磨损的，不磨损还供起来养着？</p>
<h1 id="钢化膜-2B笔尖"><a href="#钢化膜-2B笔尖" class="headerlink" title="钢化膜+2B笔尖"></a>钢化膜+2B笔尖</h1><blockquote>
<p>优点：书写声音较小，保留了屏幕全分辨率</p>
<p>缺点：阻尼感仍然不够，书写时屏幕过滑</p>
</blockquote>
<p>2B笔尖不同于原装笔尖是硬的，笔尖实际上是有一点软的，这样就能够极大减小书写时笔尖碰触屏幕发出的声音，我在使用的iPad Pro是全贴合屏幕，使用2B笔尖之后的声音几乎听不到了，不过iPad就不清楚了，非全贴合屏幕手敲一下都会有很大的声音</p>
<p>使用2B笔尖就是为了全分辨率，不影响分辨率自然也没什么好说的，分辨率就跟你刚拿到iPad还没有贴膜时一样，由于我使用的是iPad Pro，我不能只记笔记吧，那就太浪费iPad Pro强大的性能以及屏幕还有扬声器了，钢化膜价格不高，建议使用20～40之间价位的钢化膜，个人使用的钢化膜价格是36元，使用起来非常棒，感觉这个价格就是非常高端的膜了在贵没什么必要。另外这边安利一下大米家的钢化膜，在使用iPad Pro34以及iPad Air4的小伙伴强烈建议使用这个膜，因为这个膜不同于市面上其他膜在Face ID以及摄像头处开了一个刘海（iPad都要开刘海真的是巨丑巨丑），这个膜是全贴合的，只有证明麦克风处打了一个小孔，其余的地方没有开控没有刘海，并且膜的周围还是有点弧边的，这就很棒</p>
<blockquote>
<p><i class="fa fa-info-circle" aria-hidden="true"></i>   <a href="https://m.tb.cn/h.4lA1xZY?sm=c28238">大米评测iPad全面屏钢化膜</a></p>
</blockquote>
<p>刚拿到2B笔尖的时候在屏幕上划拉了几个字，感觉还凑合，阻尼感有点像橡皮的感觉，但是实际书写时就不大行了，虽然阻尼大于原装笔尖，但是还差得远，依然比较滑，并且类纸膜的精髓在于其表面的凹凸不平还原了纸张凹凸不平的感觉，这个笔尖完全没有，所以根本没有在纸上写的感觉，体验只能说能用，原装笔尖个人认为是完全不能用</p>
<p>还有一点就是，我购买的膜表面疏油层做的非常到位，导致书写的时候手与屏幕的接触面阻尼较小，手会有点打滑</p>
<p><i class="fa fa-arrow-circle-right" aria-hidden="true"></i>   使用大约4天后的补充：第一天开始使用的时候是非常非常难受的，因为假期中写字不多，开学都会出现“不会写字的”现象，再加上钢化膜的负面手感加成，写出来的字会歪歪扭扭，横不平竖不直，很难写也很难看，具体分析原因大概是因为阻尼太小导致下笔很滑，笔尖移动的方向与距离不会按照自己的意思来，很难写出直线来，据我多年写字的经验，写字要好看一定要横平竖直（这里说的好看不是传统意义上的好看，而是别人看你写的字能很轻松看出你在写什么字）而由于笔尖过滑导致并不能写出直线来，具体什么样子，看下图：</p>
<img src="/p/a833/IMG_1931.jpg" class title="第一天使用notability书写的部分笔记1">

<img src="/p/a833/IMG_ABA976E152E2-1.jpeg" class title="第一天使用notability书写的部分笔记2">

<p>当时我写完标题还在下面重新写了一遍尝试补救一下，但是失败了，我这辈子都想不到自己能写出这么歪的字来，并且当时写的非常吃力，因为笔很滑，每写一个字我都要付出巨大的努力</p>
<p>不过当我使用4天后，不知道是因为笔尖被“用开了”的缘故还是因为我熟悉了这样的阻尼感了，写字莫名变得顺滑起来，虽然还有一丢丢打滑，但是写字已经基本上能有之前的感觉了（<del>虽然手感依然不咋滴</del>），并且写字没有前几天那么吃力了，写字用的力度基本上就是之前正常写字的力度了，不知道我继续使用以后会不会完全适应呢？让我们拭目以待！</p>
<p>另外更换钢化膜还有一个问题，那就是屏幕反光问题，之前的类纸膜由于屏幕是磨砂的，导致一些较强光源在屏幕上的反光被大大削弱了，因此在之前一年多的使用中没有被反光问题困扰，但是新学期我换上了新的钢化膜并且开始使用屏幕挂灯我发现一个大问题：电脑显示屏是不反光了，但是我的ipad显示屏会反光，我能做的唯一解决方法就是书写时身子更靠前一点</p>
<h1 id="钢化膜-笔尖套"><a href="#钢化膜-笔尖套" class="headerlink" title="钢化膜+笔尖套"></a>钢化膜+笔尖套</h1><blockquote>
<p>优点：价格低廉</p>
<p>缺点：容易破损，体验类似2B笔尖</p>
</blockquote>
<p>笔尖套价格是公认的低，几块钱就能买到好多，不过笔尖套也分好多种，个人没有进行太多体验，因为其价格低廉就注定了体验绝对不会好太多，因此我对笔尖套的评价不具备任何参考价值，看看图一乐就行</p>
<p>为什么要买很多笔尖套？因为容易破损，你想想，你在教室上着课，看着黑板，记着笔记，突然笔尖套就破了，你还忘带多余的笔尖套，这多蛋疼？</p>
<p>体验个人没有细细体验，但是鉴于材质与2B笔尖类似，暂时默认体验类似，此处待完善</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>另外还有往笔尖上贴各自胶带的，emm。。。看着就有点傻，不过这个自己完全没有试过，所以也不做评价，最近打算从网上买一个iPad笔尖各类笔尖套以及贴纸的试用套装，过一阵到了以后全都试试再完善一下</p>
<hr>
<p><strong><i class="fa fa-info-circle" aria-hidden="true"></i>   待完善的文章，内容尚不全面</strong></p>
]]></content>
      <categories>
        <category>评测</category>
      </categories>
      <tags>
        <tag>iPad</tag>
        <tag>Apple pencil</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇测试文章</title>
    <url>/p/af180990.html</url>
    <content><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><p>内容？</p>
<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>测试</p>
<h2 id="第二个二级标题"><a href="#第二个二级标题" class="headerlink" title="第二个二级标题"></a>第二个二级标题</h2><p>测试内容</p>
<h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><a id="more"></a>

<p>芜湖</p>
<ul>
<li>列表1</li>
<li>列表2<br>  a 子表1<pre><code>  b啊啊啊啊
              啊啊啊啊
</code></pre>
  芜湖<br><a href="https://baidu.com/">百度</a></li>
</ul>
<h1 id="2-图片测试"><a href="#2-图片测试" class="headerlink" title="2 图片测试"></a>2 图片测试</h1><p>以下为图片测试</p>
<p><img src="/p/uyi.jpeg" alt="图片测试"></p>
<img src="/p/af180990/uyi.jpeg" class title="This is an test image">

<p><img src="/Users/Watermeter/BlogHub/Blog/source/_posts/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/uyi.jpeg" alt="uyi"></p>
<p><em>斜字体</em></p>
<p><strong>加粗字体</strong></p>
<p><code>printf:(&quot;Hello World!&quot;)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printf(&quot;芜湖&quot;)</span><br><span class="line">scanf_s(&quot;&amp;d&quot;,num);</span><br></pre></td></tr></table></figure>
<h1 id="3-引用？"><a href="#3-引用？" class="headerlink" title="3 引用？"></a>3 引用？</h1><blockquote>
<p>此处引用<a href="https://baidu.com/">百度</a></p>
</blockquote>
<p>以下为分割线测试</p>
<hr>
<h2 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a>测试2</h2>

	<div class="row">
    <embed src="./普中51单片机开发攻略--A2.pdf" width="100%" height="550" type="application/pdf">
	</div>




<p> <a href="%E7%AC%AC%E4%B8%80%E7%AF%87%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/%E6%99%AE%E4%B8%AD51%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91%E6%94%BB%E7%95%A5--A2.pdf">普中51单片机开发攻略–A2.pdf</a> </p>
<p>#4 不规范的标题示例</p>
<p>-END-</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>51单片机开发例程-3</title>
    <url>/p/904410e9.html</url>
    <content><![CDATA[<h1 id="内容概述"><a href="#内容概述" class="headerlink" title="内容概述"></a>内容概述</h1><p>在这一章的内容中，将会学习到另一个运用非常广泛的元器件：数码管，数码管常用来表示16进制及以内的数字，因此可以显示我们要输入单片机的数字以及单片机输出的数字，在计算器，电子时钟以及一些可以调节简单参数的机械中都有数码管的广泛运用，因此熟练掌握数码管的使用是单片机学习过程中必不可少的</p>
<a id="more"></a>

<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>1.使用<code>STC89C52</code>的普中51-单核-A2单片机（本文以该单片机为样本）</li>
<li>2.能够正常下载驱动以及Keil等开发软件的Windows10.0系统PC</li>
<li>3.一根micro USB to USB A数据线</li>
</ul>
<h1 id="数码管显示数字"><a href="#数码管显示数字" class="headerlink" title="数码管显示数字"></a>数码管显示数字</h1><h2 id="数码管原理"><a href="#数码管原理" class="headerlink" title="数码管原理"></a>数码管原理</h2><p>在我们的单片机上有两个型号标注为<code>3461AS-1</code>的数码管，每个数码管都可以显示4位数字，单片机通过将这两个数码管靠近摆放且联结在一起来将数码管能够同时显示的位数相加达到8位</p>
<blockquote>
<p><a href="https://baike.baidu.com/item/led%E6%95%B0%E7%A0%81%E7%AE%A1">led数码管</a>（LED Segment Displays）是由多个发光二极管封装在一起组成“8”字型的<a href="https://baike.baidu.com/item/%E5%99%A8%E4%BB%B6">器件</a>，引线已在内部连接完成，只需引出它们的各个笔划，公共电极。led数码管常用段数一般为7段有的另加一个小数点，还有一种是类似于3位“+1”型。位数有半位，1，2，3，4，5，6，8，10位等等，led数码管根据LED的接法不同分为共阴和共阳两类，了解LED的这些特性，对编程是很重要的，因为不同类型的数码管，除了它们的硬件电路有差异外，编程方法也是不同的。图2是共阴和共阳极数码管的内部电路，它们的发光原理是一样的，只是它们的电源极性不同而已。颜色有红，绿，蓝，黄等几种。led数码管广泛用于仪表，时钟，车站，家电等场合。选用时要注意产品尺寸颜色，功耗，亮度，波长等。</p>
<p>——引用自<a href="https://baike.baidu.com/item/%E6%95%B0%E7%A0%81%E7%AE%A1/9903965?fr=aladdin">百度百科</a></p>
</blockquote>
<p>在单片机中，数码管的接法为<strong>共阴型</strong>，也就是说，数码管LED的负极接在一起，靠控制LED的正极来点亮数码管，共阳数码管与上述相反，因此，我们只需要给连接到数码管的管脚以高电平即可点亮数码管，重点来了，如何控制第几个数码管亮起以及数码管内显示怎样的图形数字呢？</p>
<img src="/p/904410e9/SMG.png" class title="数码管">

<p>通过原理图我们可以看到，<code>P0</code>端口通过芯片<code>74HC245</code>连接到了数码管的一极，而<code>P0</code>端口的8位正好对应数码管1位内的8个LED灯，这8个LED灯分别由构成了数字“8”的7个LED灯以及右下角的1个表示小数点的LED灯组成，我们将这8个<code>I/O</code>口称之为数码管的<strong>段选</strong>，由段选控制单个数码管所要显示的数字符号</p>
<blockquote>
<p>观察原理图我们可以看出，在<code>74HC245</code>芯片中输入与输出一一对应，那为什么还要通过这个芯片来控制数码管呢？这是由于单片机核心起的作用是控制作用，其输出的电流电压很小，只能驱动单个LED这样电流电压较小的元件，不足以驱动一些功耗相对较大的电子元件，比如数码管，电机等</p>
</blockquote>
<p>那又怎样选择要使得哪个数码管被点亮呢？如果将每一条线都直接接入单片机的管脚上，我们可以通过控制对应 <code>I/O</code>口输出的高低电平来控制第几个数码管被点亮，这就是数码管的<strong>位选</strong>，虽然这种方法看起来可行，但是这种方法太占用<code>I/O</code>口了，我们的单片机一共才只有40个<code>I/O</code>口，像上面那种方法的话就要占用16个，为了尽可能的节约<code>I/O</code>口并且让我们学习到两种不同的信号输入输出的方法，单片机上还引入了一个芯片：<code>74HC138译码器</code></p>
<img src="/p/904410e9/74HC138.png" class title="74HC138译码器">

<p>138译码器通过ABC3个输入来达到Y0-Y7这8个输出的效果，我们可以简单理解为将2进制信号输出为10进制信号，3位2进制数字正好可以表示8个数字，按二进制数字算：其中高电平代表0，低电平代表1，查阅芯片手册我们可以得知译码器的信号判断规则，举个例子：输入A1B1C1时，化为二进制0b000，因此Y0输出0，其他输出1；输入A1B0C1时，化为二进制0b010，因此Y2输出0，其他输出1；输入A1B0C0时，化为二进制0b011，因此Y6输出0，其他输出1</p>
<img src="/p/904410e9/e61190ef76c6a7eff649c979fdfaaf51f3de6605.png" class title="译码器功能表">

<h2 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h2><p>知道了通过<strong>段选</strong>和<strong>位选</strong>来控制数码管显示什么显示哪一位，我们就可以开始编写程序了，按照正常思维逻辑，我们要先知道要选哪一位，再考虑显示什么，因此我们的程序从位选开</p>
<p>但是在开始前我们需要注意一个问题，数码管其实就是LED灯按照一定形状排列组合而成，LED灯具有二极管的单向导通性，如何确定那一端为正那一端为负呢，在这一章的最开始我们提到过，这个单片机是使用的共阴的数码管模块，负极接在一起，通过数码管的原理图可以看到，每个数码管还分出了一条线，由于每个数码管从下方（位选）输入8条线，而只从上方（段选）输出1条线，又数码管是共阴的，我们可以得知图示上方（位选）的线为低电平，下方（段选）的线为高电平时数码管被点亮</p>
<blockquote>
<p><i class="fa fa-info-circle" aria-hidden="true"></i>    我们在第一节的内容中曾经讲过通过typedef重新定义变量类型，因为重新定义后的变量名更加简略且易读，因此从本章节开始使用这一内容，但是需要注意重新定义后变量的长度</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8; <span class="comment">//代表8位正数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16; <span class="comment">//代表16位正数</span></span><br><span class="line">sbit SLA = P2^<span class="number">2</span>;</span><br><span class="line">sbit SLB = P2^<span class="number">3</span>;</span><br><span class="line">sbit SLC = P2^<span class="number">4</span>; <span class="comment">//定义译码管ABC三个输入</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  u8 LED; <span class="comment">//LED是要显示的数码管的位数</span></span><br><span class="line">  LED = <span class="number">3</span>; <span class="comment">//让从左到右第3个数码管亮起</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">switch</span>(LED)&#123;</span><br><span class="line">       <span class="keyword">case</span>(<span class="number">1</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//要显示第1位也就是要让如图LED8输出为0低电平，以下以此类推</span></span><br><span class="line">        <span class="keyword">case</span>(<span class="number">2</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">3</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">4</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">5</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">6</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">7</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">8</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行后我们发现第3个数码管的8个LED灯均亮起，说明程序正确无误，那么我们就要进行下一个环节，段码的选择</p>
<p>仔细观察图纸我们可以发现，段选对应的8个引脚在图上分别作了a,b,c,d,,e,f,g,dp的标注，同时在单个数码管的每个LED上也作了对应的标注，意思就是如果标注a的管脚输出了低电平就可以使得a被点亮，因此我们宏定义整个<code>P0</code>端口，通过16进制的方法对每个数字一一进行表示</p>
<p>为了快速读取<code>I/O</code>口与LED代号的关系，我们可以读图将其写出来</p>
<table>
<thead>
<tr>
<th>P0^0</th>
<th>P0^1</th>
<th>P0^2</th>
<th>P0^3</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>b</td>
<td>c</td>
<td>d</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>P0^4</th>
<th>P0^5</th>
<th>P0^6</th>
<th>P0^7</th>
</tr>
</thead>
<tbody><tr>
<td>e</td>
<td>f</td>
<td>g</td>
<td>dp</td>
</tr>
</tbody></table>
<p>以1为例子，要让数码管显示的数字为1，那么也就是说代号为b和c的LED灯输出高电平，也就是<code>P0^1``P0^2</code>输出高电平，那么<code>P0</code>端口就为<code>0b00000110</code>，换算为编译器能够使用的16进制就为：<code>0x06</code></p>
<p>以2为例子，要让数码管显示的数字为2，那么也就是说代号为a,b,g,e,d的LED灯输出高电平，也就是<code>P0^0``P0^1``P0^6``P0^4``P0^3</code>输出高电平，那么<code>P0</code>端口就为<code>0b01011011</code>，换算为编译器能够使用的16进制就为：<code>0x5b</code></p>
<p>其他的数字这里也就不单独推算了，最终要使得显示16进制数字那么也就一共有16个，这么多难以记忆的16进制数字如何简单快捷的调用呢，我们可以将其储存在数组中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u8 code SMG[]=&#123;</span><br><span class="line">  <span class="comment">/*我们编写的程序都是在单片机的RAM中运行的</span></span><br><span class="line"><span class="comment">  如果在数组变量类型后加code,那么可以让数组中存储的数据存储在ROM中*/</span></span><br><span class="line">  <span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line">  <span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line">  <span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>将上述数组并入之前写好的程序中并对需要的端口进行宏定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8; <span class="comment">//代表8位正数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16; <span class="comment">//代表16位正数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_DIG P0 <span class="comment">//宏定义数码管端口</span></span></span><br><span class="line">sbit SLA = P2^<span class="number">2</span>;</span><br><span class="line">sbit SLB = P2^<span class="number">3</span>;</span><br><span class="line">sbit SLC = P2^<span class="number">4</span>; <span class="comment">//定义译码管ABC三个输入</span></span><br><span class="line">u8 code SMG[]=&#123; <span class="comment">//在ROM中存储数码管段码的数组</span></span><br><span class="line">  <span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line">  <span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line">  <span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  u8 LED; <span class="comment">//LED是要显示的数码管的位数</span></span><br><span class="line">  LED = <span class="number">3</span>; <span class="comment">//让从左到右第3个数码管亮起</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">switch</span>(LED)&#123;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">1</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//要显示第1位也就是要让如图LED8输出为0低电平，以下以此类推</span></span><br><span class="line">        <span class="keyword">case</span>(<span class="number">2</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">3</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">4</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">5</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">6</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">7</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">8</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    GPIO_DIG = SMG[<span class="number">5</span>]; <span class="comment">//数码管显示数字5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行，第3个数码管上显示出了数字5，说明程序正确</p>
<h1 id="动态数码管显示数字"><a href="#动态数码管显示数字" class="headerlink" title="动态数码管显示数字"></a>动态数码管显示数字</h1><h2 id="动态显示原理"><a href="#动态显示原理" class="headerlink" title="动态显示原理"></a>动态显示原理</h2><p>完成刚刚的程序后，那么问题又来了，在我们平常看到的数码管中，都可以多个数字同时显示，并且数码管设计这么多位也不可能只显示一位，如何让数码管一次性显示多个数字呢？这里就要用到动态扫描显示的原理</p>
<p>所谓动态扫描显示即轮流向各位数码管送出字形码（段码）和相应的位码，利用发光管的余辉和人眼的视觉暂留作用，使人的感觉好像各位数码管同时都在显示，就好像我们平时使用的显示器每秒刷新60次，120次一样</p>
<h2 id="编写程序-1"><a href="#编写程序-1" class="headerlink" title="编写程序"></a>编写程序</h2><p>实现动态刷新，就需要一个循环函数将数码管一次次地执行，因为数码管有8位，所以我们循环的最小单位是8，也就是说我们刷新一次屏幕，循环函数要让上面的程序执行8次，因此我们采用for循环，而每次扫描后，我们需要清除段码，否则段码可能会被带入下一次循环中，因为下面示例的程序是要让第几个数码管显示数字几，那么直接把段码选择放到位码前面不就好了吗，实际上在运行过程中还是会产生影响，你可以试着运行一下，显示出来的数字是乱的，并且每一位实际显示的数字是<em>应该显示的数字</em>和<em>应该显示的数字+1</em>的叠加，至于为什么，在撰写这篇文章的时候我也不太清楚原因，大概是与寄存器有关，因此此处不做解答，如果有了解这一方面的同学可以给我发邮件或者电报一起讨论</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8; <span class="comment">//代表8位正数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16; <span class="comment">//代表16位正数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_DIG P0 <span class="comment">//宏定义数码管端口</span></span></span><br><span class="line">sbit SLA = P2^<span class="number">2</span>;</span><br><span class="line">sbit SLB = P2^<span class="number">3</span>;</span><br><span class="line">sbit SLC = P2^<span class="number">4</span>; <span class="comment">//定义译码管ABC三个输入</span></span><br><span class="line">u8 code SMG[]=&#123; <span class="comment">//在ROM中存储数码管段码的数组</span></span><br><span class="line">  <span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line">  <span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line">  <span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  u8 LED; <span class="comment">//LED是要显示的数码管的位数</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span>(LED = <span class="number">8</span>; LED &gt; <span class="number">0</span>; LED--)&#123; <span class="comment">//每次扫描循环执行8次，从右向左刷新，如果for循环内改为“LED = 1;LED &lt; 8;LED ++”为从左向右刷新，此处两种方法是等效的</span></span><br><span class="line">    <span class="keyword">switch</span>(LED)&#123;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">1</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//要显示第1位也就是要让如图LED8输出为0低电平，以下以此类推</span></span><br><span class="line">        <span class="keyword">case</span>(<span class="number">2</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">3</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">4</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">5</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">6</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">7</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">8</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    GPIO_DIG = SMG[LED]; <span class="comment">//第几个数码管显示数字几</span></span><br><span class="line">    GPIO_DIG = <span class="number">0x00</span>; <span class="comment">//消隐</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上述程序后我们发现，虽然数码管显示了我们需要的数字，但是亮度较低，这是因为单位时间内显示的时间太少，之前我们讲到过单片机运行每条指令都需要时间，我们可以看到在段选之后立马就是消隐，因此在扫描一次运行了好几条代码的时间中，真正显示的时间只有一条代码显示的时间，假设一共运行了10条代码，那么显示时间就是1/10，为了让数码管单位时间内显示的时间增加，我们就需要用到我们的老朋友：延时函数，我们进行延时100条代码的时间，那么显示时间就变成了101/110，亮度就会增加，但是随之刷新率也会降低，因此我们不但要高亮度也要兼顾刷新率</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8; <span class="comment">//代表8位正数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16; <span class="comment">//代表16位正数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_DIG P0 <span class="comment">//宏定义数码管端口</span></span></span><br><span class="line">sbit SLA = P2^<span class="number">2</span>;</span><br><span class="line">sbit SLB = P2^<span class="number">3</span>;</span><br><span class="line">sbit SLC = P2^<span class="number">4</span>; <span class="comment">//定义译码管ABC三个输入</span></span><br><span class="line">u8 code SMG[]=&#123; <span class="comment">//在ROM中存储数码管段码的数组</span></span><br><span class="line">  <span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line">  <span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line">  <span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>; <span class="comment">//延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  u8 LED; <span class="comment">//LED是要显示的数码管的位数</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span>(LED = <span class="number">8</span>; LED &gt; <span class="number">0</span>; LED--)&#123; <span class="comment">//每次扫描循环执行8次，从右向左刷新，如果for循环内改为“LED = 1;LED &lt; 8;LED ++”为从左向右刷新，此处两种方法是等效的</span></span><br><span class="line">    <span class="keyword">switch</span>(LED)&#123;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">1</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//要显示第1位也就是要让如图LED8输出为0低电平，以下以此类推</span></span><br><span class="line">        <span class="keyword">case</span>(<span class="number">2</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">3</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">4</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">5</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">6</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">7</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">8</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    GPIO_DIG = SMG[LED]; <span class="comment">//第几个数码管显示数字几</span></span><br><span class="line">    delay(<span class="number">100</span>); <span class="comment">//间隔一段时间扫描</span></span><br><span class="line">    GPIO_DIG = <span class="number">0x00</span>; <span class="comment">//消隐</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>&#123; <span class="comment">//延时函数</span></span><br><span class="line">  <span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样每隔一小段时间扫描一次，就能显著提升数码管亮度，但是为什么延时100呢，因为如果设置时间过短，亮度还是相对较低，如果设置较长，人眼就能看到明显闪烁，设置为200时依然能够依稀感知到闪烁，因此100在这个程序里是一个相对较好的延时时长，你可以尝试使用较高的延时时长或者在100延时下使用手机的慢动作模式以每秒240fps以上的录制帧率录制都可以看到数码管在从左向右依次刷新，这便是数码管的动态扫描显示</p>
<h1 id="动态数码管的显示函数"><a href="#动态数码管的显示函数" class="headerlink" title="动态数码管的显示函数"></a>动态数码管的显示函数</h1><p>因为数码管显示是单片机开发过程中的一个重要部分，我们不妨将其写成函数方便日后使用，由于这个函数的执行就已经在数码管上实现了数据的输出，所以我们不需要在函数中返回数值，但是我们要输入一个数字来让数码管显示这个数字，又因为数字需要在数码管上一位一位的显示，因此我们还要将数字的每一位分开来，并且数字不单单是正数，还有负数，小数，以及超出数码管显示范围的数字，我们要对这些数字一一进行处理，但是为了简单易懂，我们从正数开始</p>
<h2 id="动态数码管显示正整数"><a href="#动态数码管显示正整数" class="headerlink" title="动态数码管显示正整数"></a>动态数码管显示正整数</h2><p>按照我们生活中其他数码管设备的显示方式，不满8位的数字应该向右对齐，因此，应当把数码管扫描从左向右扫描改为从右向左扫描，接下来要在段码存储的数组<code>SMG</code>中加入空白项，使得当前数码管不显示任何内容，再将之前的代码mian函数中除了<code>while</code>循环的部分都移到了新函数<code>DigDisplay</code>中</p>
<p>对于函数<code>DigDisplay</code>我们要对其输入一个数字，使其显示我们输入的数字，我们编写此函数的目的是输出8位及以内的正整数，因此存储的数字也需要达到8个数字的长度，但是单片机核心是8bit核心，跟我们之前学习电脑时使用的64bit，32bit核心不同，8bit的数据类型所占字节数也与之前不一样</p>
<table>
<thead>
<tr>
<th>int</th>
<th>long</th>
<th>float</th>
<th>double</th>
</tr>
</thead>
<tbody><tr>
<td>2byte</td>
<td>4byte</td>
<td>4byte</td>
<td>8byte</td>
</tr>
<tr>
<td>-32768～32767</td>
<td>-2.1E+9～2.1E+9</td>
<td>-3.4E+38～3.4E+38</td>
<td>-1.8E+308～1.8E+308</td>
</tr>
</tbody></table>
<p>根据上述在8bit核心下数据类型所占字节的表格，我们可以得知要让数码管显示8位数字，需要选择4字节以上的数据类型，此处使用正整数，因此选用long</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8; <span class="comment">//代表8位正数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16; <span class="comment">//代表16位正数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_DIG P0 <span class="comment">//宏定义数码管端口</span></span></span><br><span class="line">sbit SLA = P2^<span class="number">2</span>;</span><br><span class="line">sbit SLB = P2^<span class="number">3</span>;</span><br><span class="line">sbit SLC = P2^<span class="number">4</span>; <span class="comment">//定义译码管ABC三个输入</span></span><br><span class="line">u8 code SMG[]=&#123; <span class="comment">//在ROM中存储数码管段码的数组</span></span><br><span class="line">  <span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line">  <span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line">  <span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>; <span class="comment">//延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>; <span class="comment">//动态数码管显示函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="comment">//主函数</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    DigDisplay(<span class="number">6</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>&#123; <span class="comment">//延时函数</span></span><br><span class="line">  <span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>&#123; <span class="comment">//动态数码管显示函数</span></span><br><span class="line">  <span class="keyword">char</span> LED; <span class="comment">//LED是要显示的数码管的位数</span></span><br><span class="line">  <span class="keyword">for</span>(LED = <span class="number">8</span>; LED &gt; <span class="number">0</span>; LED--)&#123; <span class="comment">//每次扫描循环执行8次，从右向左刷新，如果for循环内改为“LED = 1;LED &lt; 8;LED ++”为从左向右刷新，此处选用从右向左刷新</span></span><br><span class="line">    <span class="keyword">switch</span>(LED)&#123;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">1</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//要显示第1位也就是要让如图LED8输出为0低电平，以下以此类推</span></span><br><span class="line">        <span class="keyword">case</span>(<span class="number">2</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">3</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">4</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">5</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">6</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">7</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">8</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    GPIO_DIG = SMG[LED]; <span class="comment">//第几个数码管显示数字几</span></span><br><span class="line">    delay(<span class="number">100</span>); <span class="comment">//间隔一段时间扫描</span></span><br><span class="line">    GPIO_DIG = <span class="number">0x00</span>; <span class="comment">//消隐</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述程序，数码管所显示的还是之前的内容，如何向函数输入一个正整数使数码管显示我们输入的数字呢，我们首先要将输入的数字进行处理，将其每一位分开，在之前C语言学习中我们可以用取余和除法很容易实现这个内容，因为变量LED在进入循环之前用不到，我们可以利用LED来求得输入的数字长度来减少定义一个新变量，但是我们还需要考虑不足8位以及超出8位的问题，那么我们首先对数字的长度进行判断，如果数字太长就报警</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sbit beep = P1^<span class="number">5</span>; <span class="comment">//引入蜂鸣器表示输入数字错误</span></span><br><span class="line"><span class="keyword">if</span>(num &gt; <span class="number">99999999</span>)&#123; <span class="comment">//数字超长则触发蜂鸣器警报，程序在蜂鸣器中循环</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    beep = ~beep;</span><br><span class="line">    delay(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8; <span class="comment">//代表8位正数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16; <span class="comment">//代表16位正数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_DIG P0 <span class="comment">//宏定义数码管端口</span></span></span><br><span class="line">sbit beep = P1^<span class="number">5</span>; <span class="comment">//定义制蜂鸣器</span></span><br><span class="line">sbit SLA = P2^<span class="number">2</span>;</span><br><span class="line">sbit SLB = P2^<span class="number">3</span>;</span><br><span class="line">sbit SLC = P2^<span class="number">4</span>; <span class="comment">//定义译码管ABC三个输入</span></span><br><span class="line">u8 code SMG[]=&#123; <span class="comment">//在ROM中存储数码管段码的数组</span></span><br><span class="line">  <span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line">  <span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line">  <span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>; <span class="comment">//延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>; <span class="comment">//动态数码管显示函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="comment">//主函数</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    DigDisplay(<span class="number">114514</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>&#123; <span class="comment">//延时函数</span></span><br><span class="line">  <span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>&#123; <span class="comment">//动态数码管显示函数</span></span><br><span class="line">  <span class="keyword">long</span> LED = <span class="number">10</span>; <span class="comment">//LED是要显示的数码管的位数，同时作为除数求num长度</span></span><br><span class="line">  u8 numlong = <span class="number">1</span>; <span class="comment">//数字长度</span></span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">99999999</span>)&#123; <span class="comment">//数字超长则触发蜂鸣器警报</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;beep = ~beep;delay(<span class="number">100</span>);&#125;&#125;</span><br><span class="line">  <span class="keyword">while</span>(num / LED)&#123; <span class="comment">//求数字长度</span></span><br><span class="line">    LED *= <span class="number">10</span>;</span><br><span class="line">    numlong ++;&#125; </span><br><span class="line">  <span class="keyword">for</span>(LED = <span class="number">8</span>; LED &gt; <span class="number">8</span> - numlong; LED--)&#123; <span class="comment">//每次扫描循环执行8次</span></span><br><span class="line">    <span class="comment">//为了让高于输入数字位数的数码管不显示，因此我们要将数字长度带入循环，使得刷新完输入数字所在位数即停止，那么未扫描到的数码管就会不显示数字</span></span><br><span class="line">    <span class="keyword">switch</span>(LED)&#123;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">1</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//要显示第1位也就是要让如图LED8输出为0低电平，以下以此类推</span></span><br><span class="line">        <span class="keyword">case</span>(<span class="number">2</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">3</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">4</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">5</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">6</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">7</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">8</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    GPIO_DIG = SMG[num % <span class="number">10</span>]; <span class="comment">//第几个数码管显示数字几</span></span><br><span class="line">    num /= <span class="number">10</span>; <span class="comment">//数字减位</span></span><br><span class="line">    delay(<span class="number">100</span>); <span class="comment">//间隔一段时间扫描</span></span><br><span class="line">    GPIO_DIG = <span class="number">0x00</span>; <span class="comment">//消隐</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译执行上述代码，我们可以看到数码管上显示了我们输入的数字：114514，因此该程序实现了我们的需求，上述函数主要是添加了对输入数字的长度检测以及对输入数字的逐位分离，这些内容都非常简单，但是如何整合进函数中需要一定思考，仔细研究上述代码，待研究透彻后即可进入下一步，其实这一步是该函数最为复杂的一步，之后的负数以及小数都是对原函数稍加修改，大同小异</p>


<h2 id="动态数码管显示负数"><a href="#动态数码管显示负数" class="headerlink" title="动态数码管显示负数"></a>动态数码管显示负数</h2><p>我们实现了正数的显示，那么负数只需要判断是否为负数然后显示的时候加一个负号即可，并且由于负号的存在，数码管显示的位数就只有7位了，这一点需要注意</p>
<p>那么开始添加代码，首先先判断输入的数字是否为负数，如果是那么输出它的绝对值，并且将位数控制在7位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8; <span class="comment">//代表8位正数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16; <span class="comment">//代表16位正数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_DIG P0 <span class="comment">//宏定义数码管端口</span></span></span><br><span class="line">sbit beep = P1^<span class="number">5</span>; <span class="comment">//定义制蜂鸣器</span></span><br><span class="line">sbit SLA = P2^<span class="number">2</span>;</span><br><span class="line">sbit SLB = P2^<span class="number">3</span>;</span><br><span class="line">sbit SLC = P2^<span class="number">4</span>; <span class="comment">//定义译码管ABC三个输入</span></span><br><span class="line">u8 code SMG[]=&#123; <span class="comment">//在ROM中存储数码管段码的数组</span></span><br><span class="line">  <span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line">  <span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line">  <span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>; <span class="comment">//延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>; <span class="comment">//动态数码管显示函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="comment">//主函数</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    DigDisplay(<span class="number">-114514</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>&#123; <span class="comment">//延时函数</span></span><br><span class="line">  <span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>&#123; <span class="comment">//动态数码管显示函数</span></span><br><span class="line">  <span class="keyword">long</span> LED = <span class="number">10</span>; <span class="comment">//LED是要显示的数码管的位数，同时作为除数求num长度</span></span><br><span class="line">  u8 numlong = <span class="number">1</span>; <span class="comment">//数字长度</span></span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">99999999</span> || num &lt; <span class="number">-9999999</span>)&#123; <span class="comment">//数字超长则触发蜂鸣器警报</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;beep = ~beep;delay(<span class="number">100</span>);&#125;&#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(num &lt; <span class="number">0</span>)&#123;num *= <span class="number">-1</span>;&#125; <span class="comment">//如果数字小于0则取绝对值</span></span><br><span class="line">  <span class="keyword">while</span>(num / LED)&#123; <span class="comment">//求数字长度</span></span><br><span class="line">    LED *= <span class="number">10</span>;</span><br><span class="line">    numlong ++;&#125; </span><br><span class="line">  <span class="keyword">for</span>(LED = <span class="number">8</span>; LED &gt; <span class="number">8</span> - numlong; LED--)&#123; <span class="comment">//每次扫描循环执行8次</span></span><br><span class="line">    <span class="comment">//为了让高于输入数字位数的数码管不显示，因此我们要将数字长度带入循环，使得刷新完输入数字所在位数即停止，那么未扫描到的数码管就会不显示数字</span></span><br><span class="line">    <span class="keyword">switch</span>(LED)&#123;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">1</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//要显示第1位也就是要让如图LED8输出为0低电平，以下以此类推</span></span><br><span class="line">        <span class="keyword">case</span>(<span class="number">2</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">3</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">4</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">5</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">6</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">7</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">8</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    GPIO_DIG = SMG[num % <span class="number">10</span>]; <span class="comment">//第几个数码管显示数字几</span></span><br><span class="line">    num /= <span class="number">10</span>; <span class="comment">//数字减位</span></span><br><span class="line">    delay(<span class="number">100</span>); <span class="comment">//间隔一段时间扫描</span></span><br><span class="line">    GPIO_DIG = <span class="number">0x00</span>; <span class="comment">//消隐</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们要将判断出的正负以变量的形式代入扫描，使负数扫描的次数比数字的长度多一次，并且在多的那一次中加入负号，负号的段码我们保存在之前的数组中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8; <span class="comment">//代表8位正数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16; <span class="comment">//代表16位正数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_DIG P0 <span class="comment">//宏定义数码管端口</span></span></span><br><span class="line">sbit beep = P1^<span class="number">5</span>; <span class="comment">//定义制蜂鸣器</span></span><br><span class="line">sbit SLA = P2^<span class="number">2</span>;</span><br><span class="line">sbit SLB = P2^<span class="number">3</span>;</span><br><span class="line">sbit SLC = P2^<span class="number">4</span>; <span class="comment">//定义译码管ABC三个输入</span></span><br><span class="line">u8 code SMG[]=&#123; <span class="comment">//在ROM中存储数码管段码的数组</span></span><br><span class="line">  <span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line">  <span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line">  <span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,<span class="number">0x40</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>; <span class="comment">//延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>; <span class="comment">//动态数码管显示函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="comment">//主函数</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    DigDisplay(<span class="number">-114514</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>&#123; <span class="comment">//延时函数</span></span><br><span class="line">  <span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>&#123; <span class="comment">//动态数码管显示函数</span></span><br><span class="line">  <span class="keyword">long</span> LED = <span class="number">10</span>; <span class="comment">//LED是要显示的数码管的位数，同时作为除数求num长度</span></span><br><span class="line">  u8 numlong = <span class="number">1</span>; <span class="comment">//数字长度</span></span><br><span class="line">  u8 PosNeg = <span class="number">1</span>; <span class="comment">//该变量为0时代表数字为负数</span></span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">99999999</span> || num &lt; <span class="number">-9999999</span>)&#123;<span class="keyword">while</span>(<span class="number">1</span>)&#123;beep = ~beep;delay(<span class="number">100</span>);&#125;&#125;  <span class="comment">//数字超长则触发蜂鸣器警报</span></span><br><span class="line">  <span class="keyword">if</span>(num &lt; <span class="number">0</span>)&#123;num *= <span class="number">-1</span>;PosNeg = <span class="number">0</span>;numlong ++&#125; <span class="comment">//如果数字小于0则取绝对值，将数字为负数的信息传入扫描循环，并且多扫描一次以显示负号</span></span><br><span class="line">  <span class="keyword">while</span>(num / LED)&#123; <span class="comment">//求数字长度</span></span><br><span class="line">    LED *= <span class="number">10</span>;</span><br><span class="line">    numlong ++;&#125; </span><br><span class="line">  <span class="keyword">for</span>(LED = <span class="number">8</span>; LED &gt; <span class="number">8</span> - numlong; LED--)&#123; <span class="comment">//每次扫描循环执行8次</span></span><br><span class="line">    <span class="comment">//为了让高于输入数字位数的数码管不显示，因此我们要将数字长度带入循环，使得刷新完输入数字所在位数即停止，那么未扫描到的数码管就会不显示数字</span></span><br><span class="line">    <span class="keyword">switch</span>(LED)&#123;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">1</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//要显示第1位也就是要让如图LED8输出为0低电平，以下以此类推</span></span><br><span class="line">        <span class="keyword">case</span>(<span class="number">2</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">3</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">4</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">5</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">6</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">7</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">8</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(PosNeg == <span class="number">0</span> &amp;&amp; LED == <span class="number">2</span>)&#123;GPIO_DIG = SMG[<span class="number">16</span>];&#125; <span class="comment">//负数最后一位显示负号</span></span><br><span class="line">    <span class="keyword">else</span>&#123;GPIO_DIG = SMG[num % <span class="number">10</span>];&#125; <span class="comment">//第几个数码管显示数字几</span></span><br><span class="line">    num /= <span class="number">10</span>; <span class="comment">//数字减位</span></span><br><span class="line">    delay(<span class="number">100</span>); <span class="comment">//间隔一段时间扫描</span></span><br><span class="line">    GPIO_DIG = <span class="number">0x00</span>; <span class="comment">//消隐</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态数码管显示小数"><a href="#动态数码管显示小数" class="headerlink" title="动态数码管显示小数"></a>动态数码管显示小数</h2><p>待完善…….</p>
<hr>
<p><i class="fa fa-info-circle" aria-hidden="true"></i>   更新于2020/2/23</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>单片机</tag>
        <tag>STC89C52</tag>
        <tag>74HC138</tag>
        <tag>74HC245</tag>
      </tags>
  </entry>
  <entry>
    <title>危险品押运员生活体验</title>
    <url>/p/631a1438.html</url>
    <content><![CDATA[<p>最近在家“里闲来无事”（我妈觉得我很闲），正好临近过年，年前就让我跟我爸出去拉货挣钱去，正好也算是让我体验体验生活，并且是往江苏跑，也不用担心中高风险区什么影响返校，毕竟学校就在江苏，我索性就跟着去了，一开始我想的是拿着笔电，在车上学习来着，后来嘛，就没学成……<del>不过钱还是赚了的，赚钱就好XD</del></p>
<a id="more"></a>

<blockquote>
<p><i class="fa fa-info-circle" aria-hidden="true"></i>   本篇初写于第一次行程后，所记录的为第一次行程，由于初一后还出车前往太仓，故将两篇汇总，引用栏内为第二次行程内容</p>
</blockquote>
<blockquote>
<p><i class="fa fa-info-circle" aria-hidden="true"></i>             由于替班工作地方不同，第一次与第二次行程时所使用的汽车不同，第一次为北奔重卡一未知型号手动挡汽车，第二次为中国一汽解放J6P自动挡汽车，本文涉及图片均为后者</p>
</blockquote>
<p>之前疫情期间在家闲来无事，正好自己刚考完驾照，于是有段时间我就每天自驾去隔壁区驾校学危险品押运员证，考证后半年多没用过，年前这一阵终于有机会出挣钱了！持证上岗！</p>
<img src="/p/631a1438/IMG_5582.jpeg" class title="危险品押运员证">

<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>工作第一天，上午我像往常一样在床上趴到差不多10点，然后刷刷B站，差不多到中午吃完饭就匆匆忙忙地准备走，我本来没以为会走这么急，没想到啊没想到，然后我妈那边，她问我拿不拿方便面，我说嗯，然后就没然后了，她的意思是提醒我让我自己拿，我的意思是我以为我妈会给我拿，然后就没拿，我也不好多说啥，反之也不是多么必要的东西，无所谓了，我爸那边，又是忘拿工作鞋，又是忘拿饼啥的，因为发现的时候已经离家很远了也懒得回去拿了</p>
<p>这次出来我拿了一些吃的，充电器，手机，iPad，笔电，单片机啥的，当时的雄心壮志是打算正好用这几天时间好好学习复习一下单片机，正好也能挣钱，一举两得，实际上车晃的要死，在车上别说用笔电了，我用手机看番都不舒服</p>
<p>我妈开车把我们送到了郊区停车场里，开上车，出发去滨州博兴的一个工厂拉货，第一次坐上公路上的“王者”，视野就是不一样，视野要高很多，并且由于车头跟驾驶室玻璃是平齐的，在对前方距离的判断可以比小车更精确一些，并且反光镜有两对，主驾驶和副驾驶各用一对，主驾驶用的差不多是副驾驶反光镜的两三倍大，车内很宽敞，驾驶室主驾驶副驾驶不是连在一起的，中间有一部分是高起来可以放一些杂物的，比如做饭的锅，桶装水，充电器，证件啥的，驾驶座后面是双层床，下面那一层比驾驶室与副驾驶中间那一部分还高一点点，同样上面也是队满了衣服被子还有一些杂物啥的，双层床的第二层一端由铰链固连在车壁上，另一端则是由两个安全带绳连在车顶上，还算牢固，平时开车的时候就把安全带一端插在车顶上，形成一个三角形区域减少开车时占据的车内的空间，设计的还算合理，然后在我副驾驶座位下还放着一个暖壶，用来盛开水，并且车内车外也有很多柜子可以放东西，总之就是比之前坐过的任何一种车都宽敞一些，刚上车还算舒服</p>
<img src="/p/631a1438/IMG_5285.jpeg" class title="主驾驶处反光镜">

<img src="/p/631a1438/IMG_5284.jpeg" class title="副驾驶处反光镜">

<blockquote>
<p>对比第一次行程，第二辆车就比第一次的好多了，车比北奔重卡那辆更宽敞，并且车头大概高半米，即便是我站在副驾驶的座位上头也距离车顶还有一小段距离，因此大概估计车内空间应该在2.3m—2.5m之间，第一辆车估计在1.9m左右，可以说第二辆车在高度上相当舒服了，并且，第二辆车的悬挂系统比第一辆好得多，在旅途过程中没有第一辆那么颠，不过由于第一次出车非常颠簸所以第二次我就没拿笔电，没想到第二辆车的悬挂系统完全允许我使用笔电，还有就是双层床不像是第一辆车那样用安全带吊着，而是使用了液压杆的设计，这个设计就非常棒了，收起放下二层床毫不费力并且驾驶室貌似还比第一辆车长一点，因为第一辆车放下双层床后会压迫到驾驶座，因此第一辆车在行车过程中无法使用上层床，而第二辆车就不会，大概也是因为第二辆车二层床小一点的缘故？我没有测量尺寸所以没办法对比，但是使用体验是绝对比第一辆车好</p>
</blockquote>
<img src="/p/631a1438/IMG_5282.jpeg" class title="折叠床">

<blockquote>
<p>再就是从司机角度来看：自动挡，毫无疑问，这意味着轻松，半挂车分为12个档位，并且半挂车平时也就是跑60km/h左右的样子，档位分的比较细，如果遇上红绿灯或者说堵车就非常难受，而自动挡就完全解决了这个烦恼，刚拿到车的时候我爸还不会开自动挡，因为他和我都没有开过自动挡的汽车，家里汽车是手动挡的，但是考虑到自动挡的档位分布图，大概就能判断出：R是倒车，N是驻车，D是行车，+-分别是加减档，而A/M根据常用缩写可以判断出是Automatic/Manual（自动/手动），也就是切换为A自动挡时，变速杆放在D行车档上就行，切换为M手动挡时，变速杆也是放在D行车上，但是可以通过+-来加减档，在实际操作后，果然就是这样，<del>那么这样我也会开自动挡半挂啦XD</del></p>
</blockquote>
<img src="/p/631a1438/IMG_5583.jpg" class title="变速杆">

<p>在车上睡了一个午觉后，到达工厂，但是拉货需要排号，那个工厂看起来也不小，并且来的车很多，下午到的，结果我们排到晚上才进去装货，装货的时候貌似工厂有规定，不允许带手机入内，貌似也不允许带水？反正不能带手机这个我理解，但是不能带水就很迷惑，车内小杯子还在，但是装水的大桶以及暖壶我爸都拿下来了让我在外面等着，然后我看外面其他正在等候的押运员也都是拿着大瓶小壶的，我也就懒得问了，跟我也没啥关系</p>
<p>进去装货的时候是司机进去装货，押运员在外面等候，工厂门口有押运员等候的小房间，里面看着有空调，但是貌似没开？因为感觉跟外面温度差不多，不过起码挡风，我就在里面畏畏缩缩等了一个多小时吧，鬼知道装货怎么这么慢，等装完以后也八点多了，干脆开车回家了，回到家吃晚饭拿上之前忘记拿的东西就尽快睡觉了，因为第二天早上要5点起床不早睡可起不来</p>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>虽然我平常早上起床起不来，但是有必要的事情要做的时候我还是很准时的，起床以后还是跟第一天中午一样我妈把我们送过去，然后我们开车正式出发</p>
<p>此次行程是去往无锡锡山，本来是要去景德镇的，但是嘛，由于一些原因不去了改成去无锡了，不过也行8，少去1天正好也赶在年前前一天回来，看了一下导航，全程大约七八百公里，按照大货车限速60再加上走下道红绿灯，要跑十几个小时，估摸着晚上大约能到扬州，到时候就在扬州睡觉，早上起来上高速</p>
<p>平日里坐惯了小轿车，半挂车明显比小轿车颠簸的多，看来小轿车悬挂比半挂车好得多，我原本以为半挂车重量比较大，同样颠簸的路段会更稳，没想到跟我想的正好相反，一路上真的巨颠簸，有些老国道省道都破烂不堪了，地面上坑坑洼洼的，跑几步颠一下，我干脆就先补觉吧，中途的时候经过一个包子店我爸下去买了点包子吃，这就是我们出来第一顿早餐了，平日里我是不吃早餐的，但是我还是吃了点，不吃也不大行，吃完我就继续睡</p>
<p>一觉睡起来已经是中午了，我们到了一个镇上，我爸说这个地方的烧鸡挺好，然后他就下去买了个烧鸡，我们在车上馏（蒸）了点饼就着吃，草草的解决了中午饭，继续启程，下午我也是昏昏沉沉，想拿笔电，又有点晕不想动，不拿笔电吧，又有点精神就看看手机，就这样在纠结中度过了一个下午，最终还是没能拿出笔电学习（</p>
<p>到了晚上在一个村旁的路边停下做饭，我爸拿了些芹菜炒了炒吃，味道肯定是不如家里的，但是不知道为啥在车上啥也不干我还有点饿，估计是一路颠簸，然后就跟那些瘦身机器是绑在身上震动差不多原理吧，一会功夫芹菜就被恰完了，洗洗锅继续上路</p>
<p>晚上按照计划，差不多9点半到达扬州，在路边停车的时候还因为太黑，没看到草丛里不知道哪来的一根铁杆子，把车后保险杠给淦弯了一点，不过还好就是丑了一点，尾灯没有什么影响。我在路边上个厕所然后漱漱口就准备上床睡觉，因为下铺放的杂物有点多，我懒得收拾，并且我爸在下铺可能会方便些，我就睡上铺了，从家走的时候我妈觉得车上的被子不干净，还给我拿了个睡袋让我睡在睡袋里，外面再盖上被子，会干净一点，我也就照做了，但是吧，说实话，睡睡袋真的不咋舒服，像我这种睡觉不怎么老实平常特别喜欢翻身并且还有抱抱枕习惯的人来说，睡袋里面那一点点空间完全就是把我束缚住了，怎么动都不方便，并且如果里面捂的比较闷热的话还没有办法像平常被子一样掀起来就能把热气放出去，所以睡睡袋挺难受的，这破玩意也就是拿着比较方便，真要睡觉还是盖被子好</p>
<p>白天睡了大半天的觉，晚上车停稳以后，我爸早早的就睡着了，我在被窝里看番顺便吃lex的瓜到11点多才睡觉，真正意义上的第一天就这么过去了，说实话，挺无聊的，基本上在车上能做的事情也就是玩手机，看看文字类信息（但是容易晕），看看短视频（因为比较颠簸，看视频体验比较差，长视频比如番剧不能很好地看到弹幕以及视频中的细节，如果我是专职押运员我肯定会去买个云台看视频）还有睡觉，睡觉还睡的我脖子疼，因为没有拿U形枕，并且副驾驶的座位被阉割的很严重：没有前后调节，没有高低调节，靠背角度调节有限，所以坐着也不咋舒服，根本没有办法很好的集中精力干其她的事情，所以说这项工作的前景很差，想要做专职押运员的话基本上以后也就这样了</p>
<blockquote>
<p>第二次行程本来说着去南通来着，但是鬼知道怎么回事是去太仓，而第二次行程由于是在过年期间，高速不允许上危化品车，所以要过江就必须走轮渡，走轮渡时上下坡起伏比较大，第一次上轮渡的时候用的是自动挡，速度快了汽车自动加档，导致中途憋火了，并且汽车还有一股浓浓的柴油没烧完的味道，当时可给我吓死了，因为停的地方正好在船与地面形成的V形坡的中间，我不知道这样会不会把挂车与牵引车中间的连接处搞断，车上拉的货是四氯乙烯，再加上那个柴油没烧充分的味道，巨TM恐怖好吧，不过还好，最后我爸还是平安把车开上去了，也算是有惊无险吧</p>
</blockquote>
<img src="/p/631a1438/IMG_5335.jpeg" class title="轮渡">

<blockquote>
<p>登上轮渡以后，我穿上外套去甲板上看风景，前边是高速公路通过长江的沪苏通长江公铁大桥，后边是南通延边的货运码头，左右两边有行驶过的货船与航道浮标，上边有点点星光，迎着江风，戴着耳机放一首最喜欢的歌曲，感叹人类工业文明的伟大</p>
</blockquote>
<img src="/p/631a1438/IMG_5343.jpeg" class title="长江（夜）">

<h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h1><p>因为昨天晚上撞到那个柱子的事情，我爸一晚上思来想去早上睡不着差不多4点多就醒了，哎，我也是服了，屁大点事纠结那么久，然后5点钟他就准时开车走了，我5点醒来以后本来想起床来着但是我还是跟在家一样：关了闹钟继续睡</p>
<p>一觉醒来已经是8点了，车停在了服务站，我就说之前怎么那么舒服，原来是上了高速后路面比较平整就不颠簸了，这一觉睡起来还真是爽，醒来以后我穿上衣服去给我爸装油，不知道为啥，我爸让我把油从车里卸出来，然后拿一个桶装起来再从上面倒回去，这个操作我是没看懂，咱也不知道为啥，咱也懒得问，反之倒了三桶油以后就完事了，上车继续出发</p>
<p>很快，上午大约9点我们就到了那个厂子，貌似是一个生产润滑油的厂？厂子比起之前装货的厂来说真是太小了，这个厂子是私营的，管理相对来说松一点，按理来说卸货是需要押运员全程盯着的，但是因为私营小厂嘛，我也就不用全程盯着，在车上看看手机，差不多半个小时就完事了，卸货前后都是要称重的，称完以后那边的负责人说少40kg，我第一反应就是少了就少呗，又不多，误差范围内嘛，但是按照人家的规定要扣钱，最后是扣了150块钱，真的坑啊，因为毕竟装车的时候用的称跟卸货的时候不一样，再加上这么远的运输，车内驾驶室啥的东西也有少许变动，这40kg相比于30多吨的货来说差不多也就是0.1%多，这还能算？不过扣钱毕竟不是扣我们的钱，跟我们关系也不大，所以也不必太理会，最后运费一共给了10050，本来应该是10200，因为扣去了150所以就这样啦，这样算的话也就是说差不多800kg的行程运30t多点的油运费是10200，这样我也就大致知道了这方面的运费</p>
<blockquote>
<p>第二次行程卸货之后是比之前多20kg的样子，在卸货之前我看到了车上的记事本，上面记载了之前日常工作的每一次的装货记录，基本上都是会多20-40kg，看来这就是跟地磅由很大关系，第一次去的时候真的坑，明明不是我们的原因，还是要扣，不过没扣我们的钱还好</p>
<p>第二次出行去的厂子还算蛮大的，在太仓工业园里面，工业园我是第一次去，里面全部都是工厂，工厂与工厂之间用道路分隔，整个区域布局非常整齐整洁，毕竟是专门为了搞工业开设的园区，我估摸着那些产业园科技园都是类似的布局</p>
</blockquote>
<p>返程还是需要走一段高速，因为毕竟要跨过长江，不走不行，高速路费也是蛮贵的，淮安大桥走过去要200块钱，大车跑1km大约要2块多，然后如果走隧道啥的都是按米算钱的，为了省钱能不走高速就不走高速，扬州到无锡这一段来回高速都要1k多，真的贵，但是体验也是真的好，高速最低速度60，没有红绿灯，路面平整，下道最高速60，还有红绿灯，其实最高速度无所谓，主要是红绿灯太费时间了，半挂车起步很慢，碰见一个红绿灯损失的不止是等红绿灯的时间，还有汽车启动加速的时间</p>
<blockquote>
<p>过江依然还是走轮渡，不过这次去通常轮渡，之前没过江的时候问过通常轮渡这边，说北往南不走，南往北可以走，我也不清楚这有什么区别，不过既然说了北往南不能走就只能绕道走通沙轮渡，这次回去自然就不绕道了，因为通常汽渡是离我们最近的，貌似也是长江离海最近的一个轮渡？</p>
</blockquote>
<img src="/p/631a1438/IMG_5389.jpeg" class title="长江北岸码头">

<h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h1><p>返程的话也就那样？没有什么好讲的，顺着原路回去就行了，回去以后先去找了个地方修车，后面那一点虽然完全不影响使用但是毕竟车不是自己的，修还是要修的，持证上岗拿到人生第一桶金：880元</p>
<blockquote>
<p>第二次回去拿工钱的时候出了点小插曲，一直联系不上老板，刚回去的时候老板说等那个人一起结，因为我们出去的时候是两辆车，我们先回来了让我们等他们，不过还是难以理解，我们又不认识，而且我们先完工了为啥让我们等他们？之前其实我们和那一辆车进度车差不多，但是卸货的时候他们早跑我们前面去了结果化验报告暂时找不到了就让我们先卸货了，我们卸完货那个司机才在自己口袋里找到了化验报告，我们自然不会等他们，就早走了，最后早一步回来</p>
<p>等到那辆车回来以后，老板直接联系不上了，当时我们以为要拖欠工资，那个司机就报警了，然后我们这就暂时把车上的行驶证车钥匙拿走了，第二天老板才告诉我们昨天喝醉了，让我们回去拿钱，我就懒得去了，让我爸自己去的，我爸回来告诉我另外那个司机不咋滴，态度不大好，因为这次出去涉及到目的地变更以及轮渡的问题，多跑了路程，并且这车是改装双油箱，我爸不会用，路上漏了好多油，回去的时候还加了200多块钱的油，但是那个司机，他开车习惯不好，踩油门踩的重，他加了800多块钱的油，我都惊了，800多块钱差不多一天白干，那个人心里很不平衡呗，不过因此我也知道开车踩油门不要太重，不然这个耗油真的太恐怖咯</p>
<p>这次行程因为是过年期间，工资自然高，这4天我就拿到了2000，这个假期用了一周时间挣了2880，还行叭，暑假有空再出去溜几圈挣点钱嘿嘿</p>
</blockquote>
<img src="/p/631a1438/IMG_5405.jpeg" class title="中国一汽解放J6P">

<hr>
<p><i class="fa fa-info-circle" aria-hidden="true"></i>   更新于2020/2/22</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>工作体验</tag>
      </tags>
  </entry>
</search>
