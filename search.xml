<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>51单片机传感器-2</title>
    <url>/p/4241.html</url>
    <content><![CDATA[<p>撰写中。。。</p>
]]></content>
  </entry>
  <entry>
    <title>51单片机开发例程-1</title>
    <url>/p/7e4a71c5.html</url>
    <content><![CDATA[<p>此文章致力于了解单片机开发的基础内容，需要能够读懂单片机原理图，具备一定C语言知识储备，能够使用Keil uVision对程序进行编译生成<code>.hex</code>文件，以及能够将编译好<code>.hex</code>文件通过烧录软件烧录进单片机中进行运行</p>
<p>由于撰写该文章时知识储备尚不足以及不具备数电模电知识的入门用户难以理解一部分知识，因此本文章不进行单片机原理以及各部件原理功能的分析，如有需要可自行从网络上查询相关教学视频进行学习</p>
<a id="more"></a>

<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>1.使用<code>STC89C52</code>的普中51-单核-A2单片机（本文以该单片机为样本）</li>
<li>2.能够正常下载驱动以及Keil等开发软件的Windows10.0系统PC</li>
<li>3.一根micro USB to USB A数据线</li>
</ul>
<h1 id="点亮第一个LED"><a href="#点亮第一个LED" class="headerlink" title="点亮第一个LED"></a>点亮第一个LED</h1><h2 id="LED模块原理"><a href="#LED模块原理" class="headerlink" title="LED模块原理"></a>LED模块原理</h2><p>在点亮LED前，我们首先需要知道点亮LED的原理以及如何点亮LED</p>
<img src="/p/7e4a71c5/LED.png" class title="LED灯">

<p>从原理图中我们可以看到，单片机上的LED模块是由8个LED灯电阻串联后并联而成，并且通过LED灯的方向我们可以得知，VCC处为高电平，<code>P2*</code>处为低电平时LED灯才会被点亮，反之由于二极管的单向导通性则LED灯不会被点亮，控制VCC处的电平无法控制单个LED灯，所以要控制LED灯就要通过<code>P20-P27</code>这8个<code>I/O</code>口的电平为低电平才能控制并点亮LED灯</p>
<h2 id="单片机核心原理"><a href="#单片机核心原理" class="headerlink" title="单片机核心原理"></a>单片机核心原理</h2><p>单片机核心控制外部电路的原理简单来说就是控制各个<code>I/O</code>口的高低电平来实现的，从单片机核心原理图中可以看到在核心引出的管脚中也有<code>P20-P27</code>这8个<code>I/O</code>口，那么我们只需要通过程序控制单片机<code>I/O</code>口输出的高低电平就可以直接控制LED灯</p>
<img src="/p/7e4a71c5/Core.png" class title="单片机核心">

<h2 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h2><p>单片机使用的语言是C语言，编写程序需要一定C语言基础但是对C语言要求并不是特别高，基础薄弱也可以从最基础的例程中学习到C语言知识，并且由于单片机相比于在电脑上运行能够更好地锻炼实际应用能力，所以从单片机开始学习巩固C语言也是很好的选择</p>
<p>众所周知，在之前的C语言学习中，在写代码之前都要调用头文件以及<code>main</code>函数构建起代码基本的框架</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//代码内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理，在单片机开发中同样需要用到这些内容，但是由于电脑CPU核心的工作原理与单片机核心工作原理不同，我们需要调用的头文件也不同，并且我们需要让程序一直运行，那么就需要在<code>main</code>函数内添加一个<code>while</code>循环来实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt; //STC89C52单片机头文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//代码内容</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搭建好程序的框架之后就可以开始写程序了，从前面的原理分析可知，要让单片机上的LED灯发光，就要向P20-P27这8个<code>I/O</code>口中输出低电平，对应的LED灯就会被点亮</p>
<p>那么如何在程序中表示这些<code>I/O</code>口呢，只需要在P2与之后的数字中加入符号<code>^</code>就可以直接以变量的形式调用表示的端口，我们首先来尝试点亮第一个（D1）和最后一个（D8）LED灯</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    P2^<span class="number">0</span> = <span class="number">0</span>; <span class="comment">//点亮D1</span></span><br><span class="line">    P2^<span class="number">7</span> = <span class="number">0</span>; <span class="comment">//点亮D8</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行上述代码，编译器会报错</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MAIN.C(错误代码的行数):errer C141: syntax error near <span class="string">&#x27;=&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上述代码的含义为：在“=”附近的代码有语法错误，这是为什么呢？因为在<code>main</code>函数中，<code>^</code>是一个二进制逻辑运算符，代表异或运算，也就是参与运算的两个变量如果相同那么输出<code>0</code>，如果不同那么输出<code>1</code>，由于异或运算符已经进行了运算，所以在其之后不能加“=”号了，如果加了“=”号，那么这一行代码的错误就与<code>1+1=2</code>一样，把赋值运算符<code>=</code>与数学中的等于号<code>=</code>混淆了，编译器自然会报错</p>
<p>那么在程序中我们如何修改<code>P2^0</code>与<code>P2^7</code>这两个<code>I/O</code>口的电平呢，此时，我们就需要定义单个<code>I/O</code>口<code>sbit</code>来重新定义这两个<code>I/O</code>口</p>
<p>定义特殊寄存器的位变量<code>sbit</code>（在单片机开发中，说人话就是定义单个<code>I/O</code>口的指令），它的功能是定义单个<code>I/O</code>口，因此sbit的存储位数只有1位（如char：8位）即只有1和0两种情况，分别对应<code>I/O</code>口的高低电平</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//特殊寄存器的位变量定义格式 sbit 变量名 = 变量；</span></span><br><span class="line">sbit LED1 = P2^<span class="number">0</span>；</span><br></pre></td></tr></table></figure>
<p>知道了以上知识，就可以写出正确的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit LED1 = P2^<span class="number">0</span>;</span><br><span class="line">sbit LED8 = P2^<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  LED1 = <span class="number">0</span>;</span><br><span class="line">  LED8 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行后单片机LED灯模块只有D1和D8两个LED灯持续亮起，证明程序正确</p>
<h1 id="控制LED灯闪烁"><a href="#控制LED灯闪烁" class="headerlink" title="控制LED灯闪烁"></a>控制LED灯闪烁</h1><h2 id="LED灯闪烁原理"><a href="#LED灯闪烁原理" class="headerlink" title="LED灯闪烁原理"></a>LED灯闪烁原理</h2><p>要使LED灯不断闪烁，我们就需要让控制LED灯亮起的<code>I/O</code>口在1和0之前来回切换，并且每次切换后都有一定的延时来保证人眼能够看到闪烁的效果，此时就需要用到一个函数：延时函数</p>
<h2 id="晶振原理"><a href="#晶振原理" class="headerlink" title="晶振原理"></a>晶振原理</h2><p>延时函数要控制的参数必然是延时的时常，要使得单片机能够控制时长，我们就需要用到单片机上计时的重要组件：晶振</p>
<blockquote>
<p>晶体是指其中的原子、分子、或离子以规则、重复的模式朝各方向延伸的一种固体。</p>
<p>晶体与几乎所有的<a href="https://bk.tw.lvfukeji.com/baike-%E5%BD%88%E6%80%A7">弹性</a>物质都具有自然共振频率，透过适当的<a href="https://bk.tw.lvfukeji.com/baike-%E4%BC%A0%E6%84%9F%E5%99%A8">传感器</a>可加以利用。例如<a href="https://bk.tw.lvfukeji.com/baike-%E9%92%A2">钢铁</a>具有良好弹性、音速快，在石英晶体大量应用以前，钢铁被用作<a href="https://bk.tw.lvfukeji.com/baike-%E6%A9%9F%E6%A2%B0%E6%BF%BE%E6%B3%A2%E5%99%A8">机械式滤波器</a>。共振频率取决于晶体的尺寸、形状、弹性、与物质内的音速。高频用的晶体通常是切成简单的形状，如方形片状。典型的低频用晶体则常切成<a href="https://bk.tw.lvfukeji.com/baike-%E9%9F%B3%E5%8F%89">音叉</a>形，例如手表所使用的。如不需要太高的精确度，则也可以使用<a href="https://bk.tw.lvfukeji.com/w/index.php?title=%E9%99%B6%E7%93%B7%E8%AB%A7%E6%8C%AF%E5%99%A8&action=edit&redlink=1">陶瓷谐振器</a>取代石英晶体谐振器。</p>
<p>运用石英晶体上的电极对一颗被适当切割并安置的石英晶体施以<a href="https://bk.tw.lvfukeji.com/baike-%E9%9B%BB%E5%A0%B4">电场</a>时，晶体会产生变形。这就是逆压电效应。当外加电场移除时，石英晶体会恢复原状并发出电场，因而在电极上产生电压。这样的特性造成石英晶体在电路中的行为，类似于某种<a href="https://bk.tw.lvfukeji.com/baike-%E9%9B%BB%E6%84%9F%E5%99%A8">电感器</a>、<a href="https://bk.tw.lvfukeji.com/baike-%E9%9B%BB%E5%AE%B9%E5%99%A8">电容器</a>、与<a href="https://bk.tw.lvfukeji.com/baike-%E9%9B%BB%E9%98%BB%E5%99%A8">电阻器</a>所组合成的<a href="https://bk.tw.lvfukeji.com/baike-RLC%E7%94%B5%E8%B7%AF">RLC电路</a>。组合中的<a href="https://bk.tw.lvfukeji.com/baike-%E9%9B%BB%E6%84%9F">电感</a><a href="https://bk.tw.lvfukeji.com/baike-%E9%9B%BB%E5%AE%B9">电容</a>谐振频率则反映了石英晶体的实体共振频率。</p>
<p>石英晶体的优点是在温度变化时，影响震荡频率的弹性系数与尺寸变化轻微，因而在频率特性上表现稳定。共振的特性还取决于振动模式与石英的切割角度（相对于晶轴而言），目前常用的是AT切割，它的振荡是厚度剪切（thickness shear）振荡模式。此外，在需要高精密度与稳定性的严格场合，石英晶体会放置于<a href="https://bk.tw.lvfukeji.com/w/index.php?title=%E6%81%86%E6%BA%AB%E7%AE%B1&action=edit&redlink=1">恒温箱</a>与吸振容器内，以防止外部温度与震动的干扰。</p>
<p>——引用自<a href="https://bk.tw.lvfukeji.com/wiki/%E6%99%B6%E6%8C%AF#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">Wikipedia</a></p>
</blockquote>
<p>简而言之就是晶振会以一个固定频率进行震荡，从而输出一个周期等于振荡周期的脉冲波，单片机通过这个固定频率的脉冲波来实现对时间的控制，单片机上使用的晶振频率为11.0592MHz，而一个机器周期（单片机运行一句代码的时长）是12个震荡周期，通过计算可以大致求得运行100,000（10万）条代码所需的时长为0.9216s，为了便于计算，可以四舍五入求得运行10w条代码所需的时间为0.9s</p>
<h2 id="延时函数"><a href="#延时函数" class="headerlink" title="延时函数"></a>延时函数</h2><p>要控制延时的时长就要控制延时函数内所执行的代码的数量，通过输入要执行代码的条数在函数内进行减法运算是实现延时函数最好的方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span> <span class="params">(<span class="keyword">int</span> time)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(time --)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们需要的延时超过了int的范围怎么办？此时可以使用<code>long</code>等能够存储位数较长的变量，由于延时函数所用到的数字都是正数，也可以使用<code>unsigned</code>来将所需范围扩大至原来的2倍，但是<code>unsigned int</code>这样的变量类型太长，如何简单地表示一个变量类型，可以使用声明定义<code>typedef</code>来重新声明变量类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式 typedef 被重新声明的变量类型 重新声明的变量类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8 <span class="comment">//代表8位正变量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16 <span class="comment">//代表16位正变量</span></span><br></pre></td></tr></table></figure>
<h2 id="编写程序-1"><a href="#编写程序-1" class="headerlink" title="编写程序"></a>编写程序</h2><p>有了延时函数，实现LED灯的闪烁便十分简单</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit LED1 = P2^<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> time)</span></span>; <span class="comment">//定义延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    LED1 = <span class="number">0</span>; <span class="comment">//控制LED灯亮起</span></span><br><span class="line">    delay(<span class="number">50000</span>); <span class="comment">//延时约450ms</span></span><br><span class="line">    LED1 = <span class="number">1</span>; <span class="comment">//控制LED灯熄灭</span></span><br><span class="line">    delay(<span class="number">50000</span>); <span class="comment">//延时约450ms</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> time)</span></span>&#123; <span class="comment">//定义延时函数</span></span><br><span class="line">  <span class="keyword">while</span>(time --)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述程序中，我们使用的变量是位变量，因此也可以使用二进制逻辑运算</p>
<ul>
<li>与运算<code>&amp;</code>         有0得0</li>
<li>或运算<code>|</code>         有1得1</li>
<li>非运算<code>~</code>         取反</li>
<li>异或运算<code>^</code>     不同为1，相同为0</li>
</ul>
<p>在之前通过讲解为什么不能在程序中直接使用<code>P2^0</code>已经了解到了异或运算，这里列举最基础也是最常用的4种二进制逻辑运算，结合本例程我们可以使用非运算来进行LED亮与不亮的切换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit LED1 = P2^<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> time)</span></span>; <span class="comment">//定义延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    LED1 = ~LED1; <span class="comment">//切换LED灯状态</span></span><br><span class="line">    delay(<span class="number">50000</span>); <span class="comment">//延时约450ms</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> time)</span></span>&#123; <span class="comment">//定义延时函数</span></span><br><span class="line">  <span class="keyword">while</span>(time --)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="LED流水灯"><a href="#LED流水灯" class="headerlink" title="LED流水灯"></a>LED流水灯</h1><h2 id="宏定义端口"><a href="#宏定义端口" class="headerlink" title="宏定义端口"></a>宏定义端口</h2><p>要使得8个LED灯依次亮起，就要用到全部8个P2端口的<code>I/O</code>口，使用<code>sbit</code>进行逐个定义可以实现功能，但是变量过多程序编写太过复杂，因此可以使用宏定义定义整个<code>P2</code>端口进行程序编写</p>
<p>宏定义<code>#define</code>属于预处理指令，“宏定义”也就是全局定义，也就是说进行宏定义的变量不单单可以在<code>main</code>函数中调用，其他的函数中同样可以调用，而“预处理”顾名思义，也就是在<code>main</code>函数执行之前，预先执行的指令，我们可以通过<code>main</code>函数来对端口，表达式或者是数字进行宏定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//宏定义格式 #define 变量名 变量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED P2 <span class="comment">//定义整个端口</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi 3.1415926 <span class="comment">//定义数字变量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A x+y <span class="comment">//定义一个表达式</span></span></span><br></pre></td></tr></table></figure>
<p>如何通过改变<code>P2</code>端口的值来改变其中的8个<code>I/O</code>口的值呢？<code>P2^0</code>相当于1位变量，那么<code>P2</code>端口就相当于8位变量，因为在编写程序之前LED灯是不亮的，故<code>P2</code>端口各<code>I/O</code>口初始时为高电平，用位来表示也就是8个<code>I/O</code>口的值均为1，<code>P2</code>就等于<code>0b 1111 1111</code>，<code>I/O</code>口在端口中的分布顺序为从右向左，也就是当D1灯亮起的时候<code>P2=0b 1111 11110</code>，然而在Keil uVision中不支持二进制的表示，我们可以通过8进制，10进制，16进制来表示，由于16进制每1位正好可以表示2进制中的4位，因此我们常用16进制来进行数据的输入，比如要使得D1亮起就要让<code>P2=0xFE</code>，要使得D8亮起就要让<code>P2=0x7F</code></p>
<h2 id="编写程序-2"><a href="#编写程序-2" class="headerlink" title="编写程序"></a>编写程序</h2><p>要简单地实现流水灯的效果，就要按位进行运算，此处引入一个新的头文件<code>intrins.h</code>这个头文件中包含了二进制循环左移&amp;循环右移的运算</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_crol_(变量,位数) <span class="comment">//循环左移</span></span><br><span class="line">_cror_(变量,位数) <span class="comment">//循环右移</span></span><br></pre></td></tr></table></figure>
<p>以循环左移为例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运算前后：0b 1111 1110 ----&gt; 0b 1111 1101</span><br><span class="line">数值溢出后回到第一位：0b 0111 1111 ----&gt; 0b 1111 1110</span><br></pre></td></tr></table></figure>
<p>因此使用二进制循环移动可以实现LED灯依次亮起并熄灭</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED P2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> time)</span></span>; <span class="comment">//定义延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  LED = <span class="number">0xFE</span>; <span class="comment">//初始化LED灯模块使得D1灯亮起</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    delay(<span class="number">50000</span>); <span class="comment">//延时约450ms</span></span><br><span class="line">    LED = _crol_(LED,<span class="number">1</span>); <span class="comment">//LED灯从左向右依次亮起熄灭</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> time)</span></span>&#123; <span class="comment">//定义延时函数</span></span><br><span class="line">  <span class="keyword">while</span>(time --)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在之前的C语言学习中，我们还学习过二进制运算的左移&amp;右移运算<code>&lt;&lt;</code>&amp;<code>&gt;&gt;</code>这两个运算区别于循环运算</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LED = LED &lt;&lt; <span class="number">1</span>; <span class="comment">//左移</span></span><br><span class="line"><span class="number">0b</span> <span class="number">1111</span> <span class="number">1110</span> —&gt; <span class="number">0b</span> <span class="number">1111</span> <span class="number">1100</span></span><br><span class="line">LED = _crol_(LED,<span class="number">1</span>) <span class="comment">//循环左移</span></span><br><span class="line"><span class="number">0b</span> <span class="number">1111</span> <span class="number">1110</span> —&gt; <span class="number">0b</span> <span class="number">1111</span> <span class="number">1101</span></span><br></pre></td></tr></table></figure>
<p>也就是说只需稍加修改刚刚的流水灯的代码就可以通过位移运算实现LED灯依次亮起但是不熄灭的效果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED P2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> time)</span></span>; <span class="comment">//定义延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(LED == <span class="number">0x00</span>)&#123;LED = <span class="number">0x01</span>;&#125; <span class="comment">//LED灯全部亮起使得D1灯熄灭</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LED == <span class="number">0xFF</span>)&#123;LED = <span class="number">0xFE</span>;&#125; <span class="comment">//LED灯全部熄灭使得D1灯亮起</span></span><br><span class="line">    delay(<span class="number">50000</span>); <span class="comment">//延时约450ms</span></span><br><span class="line">    LED = LED &lt;&lt; <span class="number">1</span>; <span class="comment">//LED灯从左向右依次亮起</span></span><br><span class="line">    delay(<span class="number">50000</span>); <span class="comment">//延时约450ms</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> time)</span></span>&#123; <span class="comment">//定义延时函数</span></span><br><span class="line">  <span class="keyword">while</span>(time --)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在点亮D1-D8这8个LED灯的过程中，尤其是流水灯这种动态点亮LED灯的程序执行的过程中，我们可以发现动态数码管模块上的数字也会随着LED灯的点亮而进行“不规律”的闪烁，通过观察原理图可以看到，在其他很多模块比如<code>EEPROM模块</code>,<code>74HC138译码器</code>中都出现了<code>P2</code>端口中的<code>I/O</code>口，这是由于单片机上的<code>I/O</code>口的数量较少，不像桌面CPU那样动辄上千个管脚，因此需要节约<code>I/O</code>口，用尽可能少的<code>I/O</code>口实现尽可能多的功能，因此在某些情况下可能会出现这样的冲突现象，由于51单片机仅供学习使用，我们一般来说是学习单片机上各个模块的作用，要自行编写一个较大的工程则需要自行根据需要实现的功能来设计电路，所以对于学习用的单片机上这样的冲突情况我们可以暂且忽略，只需要实现需要实现的功能内容即可</p>
<img src="/p/7e4a71c5/STC89C52.png" class title="51单片机开发板原理图">

<p>单片机的学习的核心是实践，通过在单片机上运行所写的程序能够直观的看到程序运行的状况以及结果如何，进而通过对程序进行调整，并且也能通过将自己的想法在单片机上运行起来来增长自己的知识储备以及实践能力</p>
<p>千里之行始于足下，通过点亮LED say <code>Hello World！</code></p>
<hr>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>通过将自己的学习进度以及学习到的内容以编写教程来体现出来，能够更好地巩固自己的知识的同时也能发现自己在某些知识面上的不足，并且为自己之后回顾基础知识提供了宝贵的材料，也对将要或者正在学习单片机的朋友提供一定帮助，今天是2月1日，我将会在2月这4周内完成单片机的学习并撰写相关教程，由于知识储备不足以及相关技术材料没有带回家，在撰写本文时一定会有在知识层面不足以及理解偏差之处，若能指正感激不尽，PC端可以通过右下角打开我的联系方式，手机端由于该模块的缺失快捷链接放在此处，联系方式仅限于Email和Telegram，由于个人隐私信息问题暂时不提供QQ，WeChat等联系方式</p>
<ul>
<li><a href="mailto:watermeter114514@foxmail.com">E-Mail</a></li>
<li><a href="https://t.me/miaobiao">Telegram</a></li>
<li><a href="https://github.com/CNwatermeter">Github</a></li>
</ul>
<hr>
<p><i class="fa fa-repeat" aria-hidden="true"></i>   更新于2020/2/22</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>单片机</tag>
        <tag>STC89C52</tag>
      </tags>
  </entry>
  <entry>
    <title>51单片机开发例程-4</title>
    <url>/p/f398.html</url>
    <content><![CDATA[<p>在之前三章的内容中，我们学习到了三种信息输出的方法：独立LED灯，蜂鸣器，数码管，这一章我们开始学习信息输入的方法，相信你早就看到了主板上K1-K4四个独立按键以及S1-S16十六个矩阵按键，这些都是通过按键输入信息来控制单片机执行特定程序的有效方法，当然，在学习之前，你需要先将红外接收原件取下，具体原因我将在本章内容中讨论</p>
<a id="more"></a>

<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>1.使用<code>STC89C52</code>的普中51-单核-A2单片机（本文以该单片机为样本）</li>
<li>2.能够正常下载驱动以及Keil等开发软件的Windows10.0系统PC</li>
<li>3.一根micro USB to USB A数据线</li>
<li>4.取下IR1红外接收器模块</li>
</ul>
<h1 id="独立按键"><a href="#独立按键" class="headerlink" title="独立按键"></a>独立按键</h1><h2 id="独立按键原理"><a href="#独立按键原理" class="headerlink" title="独立按键原理"></a>独立按键原理</h2><p>单片机上使用的开关为轻触开关，是一种电子开关，轻轻按开关按钮就可以使开关接通，松开手后开关断开，开关如下图所示，有四个引脚，两两连接分为初始导通和初始不导通，其效果顾名思义</p>
<img src="/p/f398/qckg.png" class title="轻触开关原理">

<p>再看开发版原理图，原理非常简单，单片机<code>I/O</code>口与<code>GND</code>通过轻触开关连接，当按键按下时，对应的<code>I/O</code>口就为低电平，只需要单片机检测对应的<code>I/O</code>口是否为低电平就可得知按键是否被按下</p>
<img src="/p/f398/dlaj.png" class title="独立按键模块">

<h2 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h2><p>由于轻触开关内部为机械结构，按键按下时可能会存在抖动现象，也就是说当按下开关时，开关导通，由于内部某些原因，开关闭合然后又导通，导致按下一次开关后实际单片机核心检测到两次，或者说你没有按下按键，按键自行导通，因此我们需要消除抖动，那么如何消除抖动呢？此时我们就又需要用到延时函数，我们检测开关按下后，延时一段时间，再次检测开关是否闭合，如果第二次检测也闭合，那么就说明按键导通，因为抖动时间很短，所以延时足够长就可以消除抖动，因为人按下按键的时间相对于内部代码执行的时间非常长，因此也不必担心影响到正常按下按键</p>
<blockquote>
<p>观察开发板原理图我们可以看到，红外接收模块也接到了<code>P3^2</code>管脚上，因此如果不拔下红外接收器模块，实验现象就会受到干扰，因为在我们生活中红外线无处不在，即便是不按下按键，对应的程序也会运行，你不妨将下列程序修改一下，将输入的按键改为<code>P3^2</code>，你会观察到LED灯无规律闪烁，至于为什么把这些管脚接在一起，那是因为单片机管脚有限，开发板的作用就是容纳尽可能多的功能以供学习，因此管脚重复不可避免</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED P2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8;</span><br><span class="line">sbit K1 = P3^<span class="number">1</span>;</span><br><span class="line">sbit K2 = P3^<span class="number">0</span>;</span><br><span class="line">sbit K3 = P3^<span class="number">2</span>;</span><br><span class="line">sbit K4 = P3^<span class="number">3</span>; <span class="comment">//定义各个独立按键</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(K1 == <span class="number">0</span>)&#123;</span><br><span class="line">      delay(<span class="number">1000</span>); <span class="comment">//消除抖动</span></span><br><span class="line">        <span class="keyword">if</span>(K1 == <span class="number">0</span>)&#123;</span><br><span class="line">          LED = ~LED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(time --);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上述程序，我们可以观察到，按下按键LED灯亮起，但是松手后，LED灯可能亮起也可能熄灭，这是因为按下后程序一直在执行，LED一直在亮与不亮之间变化，只不过速度很快人眼看不到，就好像动态数码管刷新人眼无法察觉一样，因此我们要在按键按下之后锁定当前状态，如果未松开则进入一个循环使其不改变LED的状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED P2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8;</span><br><span class="line">sbit K1 = P3^<span class="number">1</span>;</span><br><span class="line">sbit K2 = P3^<span class="number">0</span>;</span><br><span class="line">sbit K3 = P3^<span class="number">2</span>;</span><br><span class="line">sbit K4 = P3^<span class="number">3</span>; <span class="comment">//定义各个独立按键</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(K1 == <span class="number">0</span>)&#123;</span><br><span class="line">      delay(<span class="number">1000</span>);<span class="comment">//消除抖动</span></span><br><span class="line">        <span class="keyword">if</span>(K1 == <span class="number">0</span>)&#123;</span><br><span class="line">          LED = ~LED;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">while</span>(!K1); <span class="comment">//检测按键是否松开，如果松开那么跳出循环，并且由于按键松开，之前的程序也不再执行，也就是说LED灯状态不再变化，如果没有松开则进入循环直到松开为止</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(time --);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>独立按键的核心要点也就是消除抖动和检测按键是否松开这两点，其他使用方法都可以根据这两点来展开，有些较为简单的使用方法甚至用不到检测是否松开这一点，这部分内容大家可以自己多尝试不同的内容</p>
<p><i class="fa fa-arrow-circle-right" aria-hidden="true"></i>   观察上述程序的运行我们不难发现，当你在按下按键的一瞬间，灯就亮起或熄灭，有没有方法可以让按下按键松开后才执行程序呢？那么就需要将检测按键是否松开的部分删去，并加入一条新的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED P2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8;</span><br><span class="line">sbit K1 = P3^<span class="number">1</span>;</span><br><span class="line">sbit K2 = P3^<span class="number">0</span>;</span><br><span class="line">sbit K3 = P3^<span class="number">2</span>;</span><br><span class="line">sbit K4 = P3^<span class="number">3</span>; <span class="comment">//定义各个独立按键</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(K1 == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">while</span>(K1 == <span class="number">0</span>); <span class="comment">//松开按键后执行下列程序</span></span><br><span class="line">      LED = ~LED;</span><br><span class="line">      delay(<span class="number">1000</span>); <span class="comment">//消抖</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(time --);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="矩阵按键"><a href="#矩阵按键" class="headerlink" title="矩阵按键"></a>矩阵按键</h1><h2 id="矩阵按键原理"><a href="#矩阵按键原理" class="headerlink" title="矩阵按键原理"></a>矩阵按键原理</h2><p>我们刚刚已经知道了单片机上所使用的轻触开关的原理以及使用方法了，这次我们直接来看原理图：16个按键连接8个管脚，再仔细看其连接方式，我们很容易就能得知：4+4=8，4*4=16，这8个管脚就像是XY轴一样通过两个XY管脚我们就可以确定任意一个开关的位置，因此，要从程序上确定是按下了哪个按键，我们就要分别对列和行进行扫描</p>
<img src="/p/f398/jzaj.png" class title="矩阵按键模块">

<h2 id="编写程序-1"><a href="#编写程序-1" class="headerlink" title="编写程序"></a>编写程序</h2><p>我们如何通过横向和纵向4+4两组管脚来确定是哪一个开关被按下了呢？我们对横向输入高电平，然后检测横向哪个管脚是低电平来确定纵向位置；对纵向输入高电平，然后检测纵向哪个管脚是低电平来确定横向位置，在确定横向纵向位置之前，我们依然要进行消抖的处理，在确定后，也要进行松手检测的处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_KEY P1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>;</span><br><span class="line"><span class="function">u8 <span class="title">KeyDown</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    KeyDown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(time --);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">u8 <span class="title">KeyDown</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="comment">//按键检测函数</span></span><br><span class="line">  u8 KeyValue;</span><br><span class="line">  u8 a = <span class="number">0</span>;</span><br><span class="line">  GPIO_KEY = <span class="number">0x0F</span>; <span class="comment">//对横向输入高电平，测试列</span></span><br><span class="line">  <span class="keyword">if</span>(GPIO_KEY != <span class="number">0x0F</span>)&#123; <span class="comment">//如果P1端口电平与刚刚输入的不同，说明有按键被按下</span></span><br><span class="line">    delay(<span class="number">1000</span>); <span class="comment">//按键消抖</span></span><br><span class="line">    <span class="keyword">if</span>(GPIO_KEY != <span class="number">0x0F</span>)&#123; <span class="comment">//再次检测</span></span><br><span class="line">      <span class="keyword">switch</span>(GPIO_KEY)&#123; <span class="comment">//检测，为其赋值每一列第一行代表的数字</span></span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0x07</span>):KeyValue = <span class="number">0</span>;<span class="keyword">break</span>; <span class="comment">//第1列</span></span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0x0b</span>):KeyValue = <span class="number">1</span>;<span class="keyword">break</span>; <span class="comment">//第2列</span></span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0x0d</span>):KeyValue = <span class="number">2</span>;<span class="keyword">break</span>; <span class="comment">//第3列</span></span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0x0e</span>):KeyValue = <span class="number">3</span>;<span class="keyword">break</span>; <span class="comment">//第4列</span></span><br><span class="line">      &#125;</span><br><span class="line">      GPIO_KEY = <span class="number">0xF0</span>; <span class="comment">//对纵向输入高电平，测试行</span></span><br><span class="line">      <span class="keyword">switch</span>(GPIO_KEY)&#123; <span class="comment">//检测，因为每一行之间差值为4，只需要加4*（行数-1）</span></span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0x70</span>):KeyValue += <span class="number">4</span> * <span class="number">0</span>;<span class="keyword">break</span>; <span class="comment">//第1行</span></span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0xb0</span>):KeyValue += <span class="number">4</span> * <span class="number">1</span>;<span class="keyword">break</span>; <span class="comment">//第2行</span></span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0xd0</span>):KeyValue += <span class="number">4</span> * <span class="number">2</span>;<span class="keyword">break</span>; <span class="comment">//第3行</span></span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0xe0</span>):KeyValue += <span class="number">4</span> * <span class="number">3</span>;<span class="keyword">break</span>; <span class="comment">//第4行</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>((a &lt; <span class="number">50</span>) &amp;&amp; (GPIO_KEY != <span class="number">0xF0</span>))&#123; <span class="comment">//按键松手检测</span></span><br><span class="line">    delay(<span class="number">100</span>);</span><br><span class="line">    a ++; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> KeyValue; <span class="comment">//返回按键值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么我们不直接使用<code>while(GPIO_KEY != 0xf0);</code>呢？因为矩阵按键是行列扫描来确定按键位置的，扫描完成后才知道按下哪个按键，并且按下的按键数值除存在一个变量中（之前的独立按键按键数值表示位对应<code>I/O</code>口的高低电平），如果按键没有被按下，程序扫描完一次后，进入while死循环，程序卡死，因此我们必须为松手检测设定一个时间范围，超出时间范围自动跳出循环，在时间范围内每隔一段时间就检测一下按键是否松开，因此即便是按键一直不松开或者说按键根本没有按下也不会影响程序的正常运行，并且实际上<code>whiile</code>中对<code>a</code>的范围限制并没有很严格，只需a是正整数并且不要太大就可以，如果a太大那么需要长时间按下程序才会相应</p>
<p>运行上述代码我们注意到，单片机蜂鸣器发出列声音，声音的频率由按键检测的时长有关，回顾之前的内容，会发现蜂鸣器的管脚连接到了<code>P1^5</code>并且矩阵按键行列扫描使得<code>P1</code>端口高低电平发生变化，产生了一定的脉冲信号，因此矩阵按键不可避免的会影响到蜂鸣器</p>
<p>为了让我们知道所按下的按键是哪个按键，我们将其从左到右从上到下按顺序赋予其16进制数字，正好16个按键可以表示16进制的16个数字0～F，此程序只需要将上一章节编写的函数添加到程序中即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_DIG P0 <span class="comment">//宏定义数码管端口</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_KEY P1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8;</span><br><span class="line">u8 KeyValue; <span class="comment">//定义按键全局变量</span></span><br><span class="line">sbit beep = P1^<span class="number">5</span>; <span class="comment">//定义制蜂鸣器</span></span><br><span class="line">sbit SLA = P2^<span class="number">2</span>;</span><br><span class="line">sbit SLB = P2^<span class="number">3</span>;</span><br><span class="line">sbit SLC = P2^<span class="number">4</span>; <span class="comment">//定义译码管ABC三个输入</span></span><br><span class="line">u8 code SMG[]=&#123; <span class="comment">//在ROM中存储数码管段码的数组</span></span><br><span class="line">  <span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line">  <span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line">  <span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>; <span class="comment">//动态数码管显示函数</span></span><br><span class="line"><span class="function">u8 <span class="title">KeyDown</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    KeyDown();</span><br><span class="line">    DigDisplay(KeyValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(time --);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">u8 <span class="title">KeyDown</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; </span><br><span class="line">  u8 a = <span class="number">0</span>;</span><br><span class="line">  GPIO_KEY = <span class="number">0x0F</span>; </span><br><span class="line">  <span class="keyword">if</span>(GPIO_KEY != <span class="number">0x0F</span>)&#123; </span><br><span class="line">    delay(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">if</span>(GPIO_KEY != <span class="number">0x0F</span>)&#123; </span><br><span class="line">      <span class="keyword">switch</span>(GPIO_KEY)&#123; </span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0x07</span>):KeyValue = <span class="number">0</span>;<span class="keyword">break</span>; </span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0x0b</span>):KeyValue = <span class="number">1</span>;<span class="keyword">break</span>; </span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0x0d</span>):KeyValue = <span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0x0e</span>):KeyValue = <span class="number">3</span>;<span class="keyword">break</span>; </span><br><span class="line">      &#125;</span><br><span class="line">      GPIO_KEY = <span class="number">0xF0</span>; </span><br><span class="line">      <span class="keyword">switch</span>(GPIO_KEY)&#123; </span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0x70</span>):KeyValue += <span class="number">4</span> * <span class="number">0</span>;<span class="keyword">break</span>; </span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0xb0</span>):KeyValue += <span class="number">4</span> * <span class="number">1</span>;<span class="keyword">break</span>; </span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0xd0</span>):KeyValue += <span class="number">4</span> * <span class="number">2</span>;<span class="keyword">break</span>; </span><br><span class="line">          <span class="keyword">case</span>(<span class="number">0xe0</span>):KeyValue += <span class="number">4</span> * <span class="number">3</span>;<span class="keyword">break</span>; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>((a &lt; <span class="number">1</span>) &amp;&amp; (GPIO_KEY != <span class="number">0xF0</span>))&#123; </span><br><span class="line">    delay(<span class="number">100</span>);</span><br><span class="line">    a ++; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> KeyValue; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>&#123; <span class="comment">//动态数码管显示函数</span></span><br><span class="line">  <span class="keyword">long</span> LED = <span class="number">10</span>; <span class="comment">//LED是要显示的数码管的位数，同时作为除数求num长度</span></span><br><span class="line">  u8 numlong = <span class="number">1</span>; <span class="comment">//数字长度</span></span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">99999999</span>)&#123; <span class="comment">//数字超长则触发蜂鸣器警报</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;beep = ~beep;delay(<span class="number">100</span>);&#125;&#125;</span><br><span class="line">  <span class="keyword">while</span>(num / LED)&#123; <span class="comment">//求数字长度</span></span><br><span class="line">    LED *= <span class="number">10</span>;</span><br><span class="line">    numlong ++;&#125; </span><br><span class="line">  <span class="keyword">for</span>(LED = <span class="number">8</span>; LED &gt; <span class="number">8</span> - numlong; LED--)&#123; <span class="comment">//每次扫描循环执行8次</span></span><br><span class="line">    <span class="comment">//为了让高于输入数字位数的数码管不显示，因此我们要将数字长度带入循环，使得刷新完输入数字所在位数即停止，那么未扫描到的数码管就会不显示数字</span></span><br><span class="line">    <span class="keyword">switch</span>(LED)&#123;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">1</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//要显示第1位也就是要让如图LED8输出为0低电平，以下以此类推</span></span><br><span class="line">        <span class="keyword">case</span>(<span class="number">2</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">3</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">4</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">5</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">6</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">7</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">8</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    GPIO_DIG = SMG[num % <span class="number">10</span>]; <span class="comment">//第几个数码管显示数字几</span></span><br><span class="line">    num /= <span class="number">10</span>; <span class="comment">//数字减位</span></span><br><span class="line">    delay(<span class="number">100</span>); <span class="comment">//间隔一段时间扫描</span></span><br><span class="line">    GPIO_DIG = <span class="number">0x00</span>; <span class="comment">//消隐</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上程序是直接添加函数进入到主函数，将<code>KeyValue</code>变量定义在函数外，这样就可以锁定其数值使其只在按键按下刷新时被更改，说人话就是按下按键2，数码管会一直显示2，如果不使变量<code>KeyValue</code>定义在函数外，那么数码管只会在按下按键时显示对应的数字，松开手后恢复原状，由于之前所写的显示函数功能远多于此程序需求，因此优化空间非常大，由于是学习示例，此处不再对其进行优化，能达到目的即可</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>本章节学习到了一个非常有效并且常用的数据输入的方法：开关按键，理论上在学习完以上4个章节的内容后，你就可以大致上开发出一个十分简易的计算器程序，自行编写计算器程序是你巩固之前内容的十分有效的方法，期间可能会有一些问题但是前面的知识基本可以解决，不过还是要提醒一下，目前所学知识并不多，所以编写出的计算器程序功能不会太强大，编写时一定要从最基础最简单的功能开始编写，就像上一章数码管输出数字从正整数这样最简单的数字开始一样，计算器的编写作为一个项目我会单独展开讨论不算入开发例程中</p>
<p><i class="fa fa-refresh" aria-hidden="true"></i>   更新于2020/5/1</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>单片机</tag>
        <tag>STC89C52</tag>
      </tags>
  </entry>
  <entry>
    <title>51单片机开发例程-6</title>
    <url>/p/3219.html</url>
    <content><![CDATA[<p>你也许很早就注意到了单片机开发套件里面的“电动小马达”，而驱动电机不能像LED灯一样直接通过单片机核心进行控制，因为单片机核心只具有控制作用不具有驱动作用，其产生的电流太小无法驱动电机正常运转，因此我们就需要使用到集成放大电路</p>
<a id="more"></a>

<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>1.使用<code>STC89C52</code>的普中51-单核-A2单片机（本文以该单片机为样本）</li>
<li>2.能够正常下载驱动以及Keil等开发软件的Windows10.0系统PC</li>
<li>3.一根micro USB to USB A数据线</li>
<li>4.5V直流电机+2根1pin线</li>
</ul>
<h1 id="直流电机"><a href="#直流电机" class="headerlink" title="直流电机"></a>直流电机</h1><h2 id="直流电机原理"><a href="#直流电机原理" class="headerlink" title="直流电机原理"></a>直流电机原理</h2><p>直流电机的原理其实我们在初高中都学过，原理不在过多赘述，详细内容可以查看下面引用内容，但是在此要提一下直流电机的几个特点：首先，直流电机既可以作电动机，也可以作发电机；直流电机没有正负极之分，两端通直流电就可以正常工作，交换两极可以控制其正反转</p>
<blockquote>
<p>直流电机是指能将直流电能转换成机械能(直流电动机)或将机械能转换成 直流电能(直流发电机)的旋转电机。它是能实现直流电能和机械能互相转换的 电机。当它作电动机运行时是直流电动机，将电能转换为机械能;作发电机运行 时是直流发电机，将机械能转换为电能</p>
<p>直流电机的结构应由定子和转子两大部分组成。直流电机运行时静止不动的 部分称为定子，定子的主要作用是产生磁场，由机座、主磁极、 换向极、 端盖、 轴承和电刷装置等组成。运行时转动的部分称为转子，其主要作用是产生电磁转 矩和感应电动势，是直流电机进行能量转换的枢纽，所以通常又称为电枢，由转 轴、电枢铁心、电枢绕组、换向器和风扇等组成</p>
<p>直流电机没有正负之分，在两端加上直流电就能工作。需要知道直流电机的 额定电压和额定功率，不能使之长时间超负荷运作。 在交换接线后，可以形成 正反转</p>
<p>——引用自普中科技单片机开发攻略149页</p>
</blockquote>
<h2 id="ULN2003"><a href="#ULN2003" class="headerlink" title="ULN2003"></a>ULN2003</h2><p>该芯片是一个单片高电压，高电流的达林顿晶体管阵列集成电路，不仅仅可以驱动直流电机，还可以用来驱动五项四线步进电机，关于步进电机我们在之后的内容中讲解，在此我们只讲解驱动直流电机的用法</p>
<p><code>ULN2003</code>由7对NPN达林顿管组成，说起达林顿管你肯定不熟悉，但是如果学过电工学的同学肯定对NPN很熟悉，那么请看原理图：</p>
<img src="/p/3219/dldg.png" class title="ULN2003逻辑框图以及达林顿管">

<p>这个达林顿管和NPN结合起来是不是想起什么了，没错，就是放大电路，当然这里不细讲其内部的原理以及电路分析，我们单片机学习更重要的是了解集成电路的功能以及使用方法而不是其原理，当然如果知道原理更好，如果没有余力去了解每个芯片的原理那么只需要知道并且能够活用每一个集成电路就好</p>
<p><code>ULN2003</code>芯片的功能简单来讲类似非门电路，也就是反相输出，输入高电平输出低电平，输入低电平输出高电平</p>
<h2 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h2><p>知道了上述原理那么事情就变的非常简单了，就像点亮LED灯一样地简单，因为直流电机的工作原理也是一端输入高电平，一端输入低电平即可，并且不像LED灯那样有明确的正负，直流电机正反接都可以正常工作，不同的只是电机旋转的方向</p>
<img src="/p/3219/uln2003.png" class title="ULN2003原理图">

<p>我们可以看到，该集成电路输入端连接到单片机核心进行控制，输出连接到J47模块也就是单片机左上角的那裸露的5根针脚，这5根针脚分别对应4个<code>ULN2003</code>的输出引脚与VCC，但是<code>ULN2003</code>的输出引脚也有5个，为什么有一个没有与J47的引脚相接呢？看原理图，这一引脚连接到的是BEEP，也就是蜂鸣器，蜂鸣器我们在第二节就已经讲过了，并且也接触到了这个芯片，有没有回忆起来呢？如果忘记了可以去翻之前的内容，那边也对这一集成电路进行了一点说明 ——&gt; <a href="https://cnwatermeter.github.io/p/e743207f.html#more">51单片机开发例程-2</a></p>
<p>那么程序就非常好写了，我这边仅仅示例一个通过点按开关控制直流电机开启的程序，其他使用方法请自行开发，由于原理真的非常简单，注释我也懒得写了，如果这点你都看不懂那您可以入土啦！这章是这一部分最简单的部分了，所以使用起来并不复杂</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8;</span><br><span class="line">sbit moto = P1^<span class="number">0</span>;</span><br><span class="line">sbit K1 = P3^<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  u8 i;</span><br><span class="line">  moto = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    moto = ~K1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这一部分就是写着玩吧，没什么后记，驱动蜂鸣器之前讲过了，驱动直流电机太简单了，然后我手里目前没有步进电机所以不作说明，如果有必要的话之后会专门开一章来讲步进电机</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>单片机</tag>
        <tag>STC89C52</tag>
        <tag>ULN2003</tag>
      </tags>
  </entry>
  <entry>
    <title>51单片机开发例程-8</title>
    <url>/p/f698.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Doing ordinary things at extraordinary times —— is it worth it?</title>
    <url>/p/95c5.html</url>
    <content><![CDATA[<p>Nowadays, more and more students, especially college students, choose to work part-time during summer and winter vacations or even on holidays to earn money: some because of poor family circumstances, some to earn a little pocket money, and others to experience life, they all have their own reasons or purposes for working, but I can’t help asking the question: is it really worth it?</p>
<p>For the vast majority of people, I firmly believe: it’s not worth it.</p>
<p>First of all, the labor of college students is often not proportional to the pay.</p>
<p>As we all know, the cheapest labor force in China is the group of college students. They don’t know how to use their labor force, so they always do something very stupid, such as becoming free labor in order to get credits. Some people think that there is nothing wrong with being a free laborer to get credits, but there are many ways to get credits in college life without being a free laborer, and you can find many such opportunities if you pay attention to them. It’s not right to waste your time and energy for credits that are not worth anything.</p>
<p>And what really makes me incomprehensible and angry is this behavior of playing cheap jobs on holidays, it’s unbelievable!</p>
<p>For a hundred years, workers have been seeking higher pay and better pay, but these college students are stupid enough to be willing to sell their labor for a fraction of the price! They are completely unaware of the value of their labor, and just a little benefit can make them complacent. Damn! It’s f**king crazy! </p>
<p>On the other hand, college students should learn knowledge rather than perform physical labor.</p>
<p>College students are still students after all, and isn’t the purpose of going to college to improve your workforce by learning knowledge?So why do some college students use their study time to work? Nowadays, the implementation of college students poverty assistance and loan policies have shown me that the majority of poor students do not live in poverty. Therefore, the majority of college students do not need to work during the school year to make a living. The purpose of going to college is to learn from it so that you don’t have to do strenuous physical work, but these people are doing the opposite. They don’t really know what they are supposed to be doing, sadly.</p>
<p>My roommate, on the Labor Day holiday, a holiday that honors workers for their courageous pursuit of their rights, chose instead to perform cheap labor. The owner of the restaurant was able to get him to willingly work for him for the busiest days of his life for only ¥120  per day! During winter break, I was able to earn up to ¥700  per day for working on legal holidays because I had obtained a relevant qualification. I was able to earn several times more than my roommate without having to do manual labor because I had the knowledge.</p>
<p>Ignorance is terrible because they do not know they are ignorant.</p>
<p>In fact, college students working part-time is not always bad, as long as they get a reasonable pay, or they can learn something useful from it, it is worth it! But like my roommate so silly to carry out manual labor and only earn so little pay is really f**king stupid!</p>
<p>While one roommate was playing games and another was doing cheap labor, I wanted to use these days to study to improve myself, because: knowledge is power.</p>
<p>So I hope you don’t work part-time when you should be studying, think about why you came to college, think about what you should be doing now, think about what you want to do after you graduate, make a plan for your life, set goals for your future, and fight for the job and life you really want!</p>
<hr>
<p><strong><i class="fa fa-info-circle" aria-hidden="true"></i></strong>   This is my first English article, and because my English is poor, I use a translator for some of the content, so I’m bound to make mistakes, but one day I’ll write a perfect English article without using a translator!</p>
]]></content>
      <tags>
        <tag>奇思妙想</tag>
        <tag>EN-language</tag>
      </tags>
  </entry>
  <entry>
    <title>51单片机开发例程-2</title>
    <url>/p/e743207f.html</url>
    <content><![CDATA[<p>此章学习到单片机上的一个重要部件：蜂鸣器</p>
<p>蜂鸣器通过发出声音来达到提示以及播放音乐的功能，可以让使用者能够简单地判断单片机是否实现了自己想要的效果比如：开始工作，输出结果，程序故障等等，而蜂鸣器又分为有源蜂鸣器和无源蜂鸣器，在此单片机上使用的是无源蜂鸣器</p>
<a id="more"></a>

<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>1.使用<code>STC89C52</code>的普中51-单核-A2单片机（本文以该单片机为样本）</li>
<li>2.能够正常下载驱动以及Keil等开发软件的Windows10.0系统PC</li>
<li>3.一根micro USB to USB A数据线</li>
</ul>
<h1 id="驱动蜂鸣器发声"><a href="#驱动蜂鸣器发声" class="headerlink" title="驱动蜂鸣器发声"></a>驱动蜂鸣器发声</h1><h2 id="蜂鸣器原理"><a href="#蜂鸣器原理" class="headerlink" title="蜂鸣器原理"></a>蜂鸣器原理</h2><p>单片机上使用的蜂鸣器是无源蜂鸣器，这种蜂鸣器又被称为压电蜂鸣器，原因是这种蜂鸣器发声的原理是压电效应</p>
<blockquote>
<p>当对压电材料施以物理压强时，材料体内之<a href="https://bk.tw.lvfukeji.com/baike-%E7%94%B5%E5%81%B6%E6%9E%81%E7%9F%A9">电偶极矩</a>会因压缩而变短，此时压电材料为抵抗这变化会在材料相对的表面上产生等量正负电荷，以保持原状。这种由于<a href="https://bk.tw.lvfukeji.com/baike-%E5%BD%A2%E8%AE%8A">形变</a>而产生<a href="https://bk.tw.lvfukeji.com/baike-%E9%9B%BB%E6%A5%B5%E5%8C%96">电极化</a>的现象称为“正压电效应”。若欲持续产生电能，须使材料振动。</p>
<p>正压电效应实质上是机械能转化为电能的过程。</p>
<p>当在压电材料表面施加<a href="https://bk.tw.lvfukeji.com/baike-%E9%9B%BB%E5%A0%B4">电场</a>（电压），因电场作用时电偶极矩会被拉长，压电材料为抵抗变化，会沿电场方向伸长。这种通过电场作用而产生机械形变的过程称为“逆压电效应”。</p>
<p>逆压电效应实质上是电能转化为机械能的过程。</p>
<p>——引用自<a href="https://bk.tw.lvfukeji.com/wiki/%E5%A3%93%E9%9B%BB%E6%95%88%E6%87%89">Wikipedia</a></p>
</blockquote>
<p>如何使得蜂鸣器发生且发出不同声音？我们可以通过改变蜂鸣器连接到单片机引脚输出交变电压波形的频率来调整控制蜂鸣器的音调，也可以改变输出交变电压占空比来控制蜂鸣器声音的大小</p>
<blockquote>
<p>Un buzzer (transducteur) piézoélectrique est typiquement composé d’un diaphragme piézoélectrique, d’une cavité avec un orifice et de connexions pour les bornes électriques. Il nécessite une tension alternative pour fonctionner, de quelques volts à quelques dizaines de volts (3 V à 30 V par exemple). C’est ce type de <a href="https://fr.wikipedia.org/wiki/Transducteur">transducteur</a> que l’on retrouve au dos des montres ayant une fonction alarme.Il présente une fréquence de résonance optimale de quelques kilohertz, entre 1 kHz et 5 kHz en général, par exemple 2,8 kHz ou 3 kHz, mais il peut atteindre des fréquences plus hautes jusqu’à 80 kHz. Il faut donc un oscillateur chargé de produire un signal rectangulaire, ce dernier pouvant facilement être construit avec des portes logiques ou avec des transistors. Si on applique au transducteur piézoélectrique un signal donné sur une de ses bornes, et le même signal mais en opposition de phase sur son autre borne, il sera en mesure de délivrer une puissance quadruple, avec une tension d’alimentation identique (montage en pont, même principe que celui adopté pour certains amplificateurs audio de puissance).</p>
<p>压电蜂鸣器通常由压电隔膜，带孔的空腔和电气端子的连接组成。它需要交替电压才能运行，从几伏特到几十伏特（例如3伏到30伏特）。这种<a href="https://fr.wikipedia.org/wiki/Transducteur">传感器</a>可以在手表背面找到，具有报警功能。它的最佳共振频率为几千赫，一般在1千赫至5千赫之间，例如2.8千赫或3千赫2，但它可以达到高达80千赫3的更高频率。因此，有必要有一个振荡器来负责产生矩形信号，该信号可以很容易地使用逻辑门或晶体管构建。如果给定的信号被施加到其一个终端上的压电传感器上，并且信号相同，但与另一个终端相位相反，它将能够以相同的电源电压（桥接安装，与某些功率音频放大器采用的原理相同）提供四倍功率。</p>
<p>——引用自<a href="https://fr.wikipedia.org/wiki/Bipeur">Wikipedia</a></p>
</blockquote>
<p>了解了蜂鸣器的工作原理后，现在回到单片机原理图对实际情况进行分析</p>
<img src="/p/e743207f/BEEP.png" class title="蜂鸣器">

<p>从原理图中可以看到，蜂鸣器的一端接VCC，另一段接BZ，之前在LED灯模块我们也遇到过VCC这个管脚，并且通过二极管原理推断出了VCC处是高电平，那么VCC到底有什么含义呢</p>
<ul>
<li>VCC（Volt Current Condenser）电路的供电电压</li>
<li>GND（Ground）电线接地端</li>
</ul>
<p>以上两个在电路中常用的简写一个代表高电平，一个代表低电平，这样我们就能通过原理图更加明确地读出各个元器件工作时对应<code>I/O</code>口应该输出高电平还是低电平了</p>
<p>而BZ又是什么含义呢？</p>
<img src="/p/e743207f/ULN2003D.png" class title="ULN2003原理图">

<p>仔细观察原理图，我们还可以在<code>ULN2003D</code>这个芯片的管脚处看到BZ的身影：<code>P1^5</code>连接<code>IN5</code>，<code>IN5</code>连接<code>OUT5</code>，<code>OUT5</code>连接<code>BZ</code>，因此，我们可以通过控制<code>P1^5</code>输出的高低电平来控制BZ的高低电平进而控制蜂鸣器，那么为什么需要使用<code>ULN2003D</code>芯片对蜂鸣器进行驱动呢，这是因为该元件内含7个达林顿管，在电子电路里的主要特点是大电流容量和高电压输出，常作为驱动器使用，可以直接驱动蜂鸣器，继电器，步进马达等负载</p>
<blockquote>
<p>ULN2003是一种高压大电流的<a href="https://bk.tw.lvfukeji.com/baike-%E5%85%B1%E5%B0%84%E6%A5%B5">共发射极</a><a href="https://bk.tw.lvfukeji.com/baike-%E9%81%94%E6%9E%97%E9%A0%93%E9%9B%BB%E6%99%B6%E9%AB%94">达林顿晶体管</a>数组<a href="https://bk.tw.lvfukeji.com/baike-%E7%A9%8D%E9%AB%94%E9%9B%BB%E8%B7%AF">集成电路</a>，内含7组达林顿对管，每组对管的<a href="https://bk.tw.lvfukeji.com/baike-%E9%9B%BB%E6%B5%81">电流</a>容量是500mA，输出的<a href="https://bk.tw.lvfukeji.com/baike-%E9%9B%BB%E5%A3%93">电压</a>最高50V。该集成电路还集成了7只共阴极形式连接的<a href="https://bk.tw.lvfukeji.com/baike-%E7%BB%AD%E6%B5%81%E4%BA%8C%E6%9E%81%E7%AE%A1">续流二极管</a>，用于电感性负载的开关动作的电流续流。</p>
<p>——引用自<a href="https://bk.tw.lvfukeji.com/baike-ULN2003A?wprov=srpw1_0">Wikipedia</a></p>
<p>达灵顿晶体管是<a href="https://bk.tw.lvfukeji.com/baike-%E7%94%B5%E5%AD%90%E5%AD%A6">电子学</a>中由两个（甚至多个）<a href="https://bk.tw.lvfukeji.com/baike-%E5%8F%8C%E6%9E%81%E6%80%A7%E6%99%B6%E4%BD%93%E7%AE%A1">双极性晶体管</a>（或者其他类似的集成电路或分立元件）组成的复合结构，通过这样的结构，经第一个双极性晶体管放大的电流可以进一步被放大。]这样的结构可以提供一个比其中任意一个双极性晶体管高得多的电流<a href="https://bk.tw.lvfukeji.com/baike-%E5%A2%9E%E7%9B%8A">增益</a>。在使用集成电流芯片的情况里，达灵顿晶体管可以使得芯片比使用两个分立晶体管元件占用更少的空间，因为两个晶体管可以共用一个<a href="https://bk.tw.lvfukeji.com/w/index.php?title=%E9%9B%86%E7%94%B5%E6%9E%81&action=edit&redlink=1">集电极</a>。达灵顿晶体管通常被封装在单一的芯片里，从外面看就像一个双极性晶体管。有时，集成电路芯片中会包含8个这样的结构方便使用。</p>
<p>——引用自<a href="https://bk.tw.lvfukeji.com/baike-%E9%81%94%E6%9E%97%E9%A0%93%E9%9B%BB%E6%99%B6%E9%AB%94">Wikipedia</a></p>
</blockquote>
<h2 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h2><p>有了以上知识，我们很容易就可以得知只需在程序中让<code>P1^5</code>管脚输出的电平以一定频率在高低电平间切换就可以控制蜂鸣器发出声音的音调</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit beep = P1^<span class="number">5</span>; <span class="comment">//定义控制蜂鸣器的I/O口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> time)</span></span>; <span class="comment">//延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    beep = ~beep; <span class="comment">//控制高低电平来回切换</span></span><br><span class="line">    delay(<span class="number">100</span>); <span class="comment">//延时0.9ms，使得发出声音的频率约为0.55KHz</span></span><br><span class="line">    <span class="comment">//高低电平之间切换时间相同，占空比为50%</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> time)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行，单片机成功发出声音，但是需要注意，在使用之前建议将蜂鸣器上的保护贴纸撕掉，不然可能会一定程度上影响发声的频率</p>
<p>如果要改变蜂鸣器发生的频率，只需要改变延时函数参数即可</p>
<p>那么如果要改变占空比来改变蜂鸣器发声的大小又该如何修改程序，其实只需要将<code>while</code>循环中的代码复制一下后再改一下<code>beep</code>的赋值即可，这样就可以通过修改两个延时函数延时之和所占比例来调节占空比进而调节声音大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit beep = P1^<span class="number">5</span>; <span class="comment">//定义控制蜂鸣器的I/O口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> time)</span></span>; <span class="comment">//延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    beep = <span class="number">1</span>; <span class="comment">//控制高电平</span></span><br><span class="line">    delay(<span class="number">50</span>); <span class="comment">//延时0.45ms</span></span><br><span class="line">     beep = <span class="number">0</span>; <span class="comment">//控制低电平</span></span><br><span class="line">    delay(<span class="number">150</span>); <span class="comment">//延时1.35ms</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> time)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但实际上通过调节占空比来调节蜂鸣器响度的方法效果并不好，在房间内进行135s持续响度测试得出以下数据</p>
<table>
<thead>
<tr>
<th></th>
<th><a href="mailto:&#x30;&#46;&#x31;&#49;&#x4b;&#x48;&#122;&#x40;&#x30;&#x2e;&#x31;">&#x30;&#46;&#x31;&#49;&#x4b;&#x48;&#122;&#x40;&#x30;&#x2e;&#x31;</a>%</th>
<th><a href="mailto:&#48;&#x2e;&#49;&#49;&#75;&#x48;&#122;&#64;&#x39;&#57;&#46;&#57;">&#48;&#x2e;&#49;&#49;&#75;&#x48;&#122;&#64;&#x39;&#57;&#46;&#57;</a>%</th>
<th>无蜂鸣器</th>
</tr>
</thead>
<tbody><tr>
<td>平均响度</td>
<td>26dB</td>
<td>33dB</td>
<td>11dB</td>
</tr>
</tbody></table>
<p>当然，增大响度的方法还有增大电压，但是在前期学习中难以实现增大电压的方法，并且在学习过程中蜂鸣器的响度对学习以及程序的正常运行没有影响，因此只需要知道改变占空比与电压都可以改变蜂鸣器的占空比即可</p>
<hr>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>通过本章的内容，我们又学习到了一种数据输出的方法，蜂鸣器的原理较为复杂，涉及到一部分电子知识，之前没有基础的同学也完全可以暂且忽略原理，只需要知道驱动蜂鸣器需要脉冲波，且在单片机上还需要通过一个大电流高电压的元器件来驱动即可，同时我们也发现要实现一项功能可能不止需要单个元件，还需要其他芯片配合使用，所以当遇到不熟悉的管脚不妨到其他元件上找找是否有这个管脚</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>单片机</tag>
        <tag>STC89C52</tag>
        <tag>ULN2003</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈“生产力”——新款iPad Pro发布有感</title>
    <url>/p/a996.html</url>
    <content><![CDATA[<p>就在北京时间2021年4月21日凌晨，苹果发布了一系列搭载Apple Silicon M1芯片的新款产品，出人意料的是，这颗“桌面级Soc”被放在了新款iPad Pro中，不少人直呼牛逼但是更多的却是质疑与几年来人们一直反复争论的<strong>生产力</strong>问题</p>
<a id="more"></a>

<p><strong>生产力</strong>，其实我非常非常讨厌这个词汇，并且我也非常讨厌拿这个词汇来攻击其他人的人（实际上坦白来讲对于使用这个词汇的我都不太喜欢），因为<strong>很多人对于这个词汇并没有一个明确的，正确的定义</strong>，比如：自媒体博主对于一些产品的评测会着重讲解剪视频的性能体验，比如程序员会着重看中使用的平台能使用哪些IDE或者说插件之类的（原谅我对此并没有了解太多），比如文字工作者只是想要一个方便码字的工具。毕竟每个人都不会对所有领域了解，每个人都有自己的需求，然后有些人就会拿自己领域的东西来攻击别的领域的东西：比如iPad没法写程序，这，我有什么好说的呢？我该去说手机没法写程序吗？或者是我该说手机没法记笔记吗？不能，因为手机不是用来写程序的，手机不是用来记笔记的。所以<strong>所谓的生产力，应该根据使用者实际情况来看</strong></p>
<p>这几年来，对于生产力的争议屡见不鲜并且不仅仅是对于iPad的争论，而今年新款iPad Pro更是达到了一个新的高峰，许许多多的人坚定自己的设备是最有生产力的，并以此来质疑iPad的无用（我或许该称之为iPad无用论？）“iPad做的到吗？”，更有甚者以此来攻击iPad用户，但是他们却不知道他们口中的<strong>对比是不对等的</strong>，就如上一段末尾我所讲的那样</p>
<p>对于iPad无用论我听到的最多的一句话自然就是：“<strong>买前生产力，买后爱奇艺</strong>”，这句话当然非常形象，我个人有一段时间也有类似的感受，但是问题出在哪里呢？问题出在用户：“买前生产力”，用户买之前自然是想好了要用设备来干什么，但是由于自己不克制不进取而沦为了“买后爱奇艺”的娱乐工具，很多人所谓的x86生产力工具不也有“买前生产力，买后打游戏”的真实经历吗，所以说，<strong>永远不要指望更换设备就能养成良好的习惯</strong></p>
<p>其实一直以来<strong>设备都只是提供了一个平台</strong>，这个平台需要开发者和用户共同维护，为什么现在Windows电脑能够运行更多程序，能够做更多事情，那是因为Windows的历史远比iOS来的悠久，用户远比iOS用户来的多，用户多了（市场大了），开发者自然就会对这一平台更上心。同理，同样是平板电脑，为什么一众安卓平板电脑打不过iPad？自然是iPad用户更多，苹果的号召力更强，能请求<del>（强迫）</del>厂商适配，并且完善的App Store会让开发者真正拿到钱，所以开发者会对iPad开发专门的app或者说对其进行适配优化</p>
<p>实际上，如今我们手中的设备在当今已经不仅仅是工具，也还是“一个人形象的象征”，比如相当一部分使用旗舰产品的人会有一种莫名的“优越感”，因为不管怎样，旗舰产品总的来说确实是优于次旗舰产品的，使用“智商检测机”的人可能就会被周围的人另眼相看，因为人总是喜欢对比的，不管是有意还是无意，绝大多数人都会注意到自己优于别人的方面而“骄傲”，劣于别人的方面而“嫉妒”，不过<strong>一旦涉及到了品牌，那争议就大了去了</strong>：海军，米猴，工读生，果蛆，这些负面称呼就是很好的证明，比如某些华为用户可能会觉得华为比小米好，小米就是垃圾，于是使用了一些不当的过激词汇来攻击小米或者小米用户，那么相当一部分小米用户自己觉得自己受到了冒犯，自然就会反击，于是大战一触即发，演变成两个品牌部分用户的对立，而一些看热闹的人就会在一边讲风凉话：“厂商是你们爹吗？”厂商当然不是用户的爹，但是当你手中的设备被人贬低的一无是处，那你还能心平气和的跟那个人对话吗？不要自以为是觉得无所谓，对于绝大多数人来讲被人贬低自己设备一文不值的时候即便是强忍着心平气和的交流血压实际上也是在升高的，“不以物喜不以物悲”的人毕竟是少数，如果你恰好是那少部分人并且你乐意的话可以来跟我交流一下真实感受</p>
<p>言归正传，iPad只是提供了一个平台，怎样使用是用户自己的事情，iPad用户不该去以己之长攻人之短，而Windows用户也不该拿自己的使用场景来贬低iPad做不到这做不到那，毕竟，<strong>大概你其实也并不是目标用户</strong></p>
<p>对于这次iPad Pro的更新换代，只能说一般，iPad Pro2018可谓是iPad更新最大的一代了，一代经典，虽然当时很多软件都没有适配新的屏幕比例，两年半过去了，如今的iPad App已经全线为新屏幕比例适配优化过了，上次Pro的更新只是加了个GPU核心，加了个摄像头，激光雷达，然后基础存储增大了而已，这次基本上也都是小升级，但是比起上次更新这次对于芯片和屏幕的更新可谓巨大，搭载了M1芯片的iPad Pro把性能提升到一个新的高度，搭载了mini LED显示屏把12.9寸iPad Pro屏幕素质提升到了一个新的高度，<strong>然而对于我们这些老用户来讲呢？虽然参数上很好看但是貌似并没有更新的必要和动力</strong>，因为A12X和A12Z已经很强了，对于绝大多数用户来说性能已经是溢出了<del>（除了原神玩家）</del>，有些人说加入M1性能溢出没啥用，但是苹果把最好的芯片给最好的iPad有错吗？没有错！对于这方面厂商和用户都没有错，只能说苹果近几年来对于产品的功能与设计越来越保守了，性能的提升是必要的，所以别再跟我扯什么性能溢出了！性能高难道不好？谁不希望自己的设备能够多用几年呢？</p>
<p>作为一个三星半家桶换到苹果全家桶的用户来说，苹果设备并没有给我带来太多惊艳与惊喜，不过我却<strong>并不想换其他品牌设备也并不想更新我手中的设备</strong>，在我看来我当前手中的设备是最经济也是最适合我的：</p>
<blockquote>
<p>iPhone 11 Pro Max：新的激光雷达，更好的摄像系统，更好的性能与5G对我来说都没有必要，我不打游戏不需要性能，然后摄像系统的话要付出的金钱太多了并且现在手里设备画展完全够用所以完全没必要，5G是未来但是不是现在</p>
<p>iPad Pro 3 11inch + Apple pencil 2 ：超高性价比，跟新款比起来主要也就是芯片和摄像系统差别，正经人谁用iPad摄像啊，然后那个激光雷达的话我觉得可以有，但是也只是锦上添花，目前主要用来记笔记，影音，随航，最近开始学习用Shapr 3D建模</p>
<p>MacBook Pro M1：唯一一个最新产品，试试水，之前的MacBook Pro2017确实比较老了风扇狂转，更新新款有更好的性能更好的续航，这个我基本上就是拿来做一些Mac特长的事情，轻办公敲代码什么，续航长就是好啊</p>
<p>Apple Watch Series4：新款升级除了常量都对我来说没必要，S4就和iPad Pro3类似</p>
<p>AirPods2 + AirPods Pro：搭配苹果生态自动切换很舒服，虽然音质不行但是通勤还是很舒服的，已经是最新产品没法更新</p>
</blockquote>
<p>这些产品与我的生活息息相关，涵盖了我几乎所有的活动，它们给了我良好的影音体验，改变了我学习的方式，记录了我生活的习惯并使我以此进行作息调整，让我舒适的听音乐。电子产品大大丰富了我的生活，它们都在不同程度上帮助了我的学习与工作，也让我享受游戏与电影。当我想要学习单片机时，我会打开我的Windows电脑；当我想要记笔记时，我拿出我的iPad和吸附在上面的pencil；当我想要去图书馆学习时，我不会忘记带我的MacBook；当别人向我发来消息时，我的Watch会第一时间提醒我；当我想要在嘈杂的校园环境中静听一曲时，AirPods能带给我属于我自己的世界，但是要说它们有怎样的生产力时，我无话可说，因为当我在学习与工作，影音与娱乐的时候，我只是在想：<strong>利用好手中的工具就好了，何必去纠结它不能做什么？</strong></p>
<p>最后，这些仅仅是我个人的所见所闻所思所想，并且我在文中大量使用了非绝对的词语，所以不代表所有人都是如此，请不要对号入座。我肯定会有错误，并且肯定会有人不赞同我的观点，所以如有错误或你不赞同我的观点希望您能留下宝贵的意见，因为撰写此文章时候Blog的评论系统尚不完善所以评论请移步Telegram</p>
<p><strong><i class="fa fa-info-circle" aria-hidden="true"></i>   其中观点完全主观，请辩证地看待文中观点</strong></p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>奇思妙想</tag>
        <tag>iPad</tag>
        <tag>生产力</tag>
      </tags>
  </entry>
  <entry>
    <title>网络焦虑</title>
    <url>/p/505a.html</url>
    <content><![CDATA[<p>最近这几天不怎么上推特之后感觉自己的生活美好了许多，虽然来自现实中的压力比前一段时间更大了：临近的期末考试，还没有完成的实验和作业，无数节补课，外出实训过程中依然要回校补课考试…不过，我心知肚明，虽然结果可能不尽人意，但是这些东西都是可以解决的，而网络上那些东西，虽然很多都是“虚拟”的（<del>但是我把握不住</del>），都是跟我没有什么关系的，但是却切实地影响到了我的心理状态。</p>
<p>就正如前几天我退推一样，来自推特中错综复杂的信息在那段时间给予我的更多的是烦恼，并且我束手无策，当前我并没有找到一个适合自己的网络社交规则，如果我只是发推而不去看别人的推，这样我便成了自己讨厌的一类人；如果我大量观看其他人的推文，那么就一定会看到一些会让我心情不好的东西，一方面大家都讨厌的双方互相对立谩骂，另一方面是处于自己的嫉妒：看到别人比我强太多，比我过的好太多；那么就不能有个折中点吗？适度看推适度发推？这是不存在的，只要去看推就一定可能会遇到上面的这些事情，为此我有些难过，在此之前我貌似没有这样的烦恼的，大概是我发自内心把推特当树洞了。</p>
<p>实际上不仅仅是我，也有许多人都有这样一种网络焦虑，因为网络不同与现实，你可以在网络上看到任何一个人，任何一个地方所发生的任何一个事情，虽然只有少数与我所处的现实脱节，但是人的心理往往会对这些特殊的个例印象深刻，当我看到他们所处的环境，所做的事情，所掌握的条件比我优越太多时，我会发自内心地羡慕他们，同时心生嫉妒，就是这样的嫉妒让我产生这样一种网络焦虑，因为我已经很久没有读心理学的书籍了所以我也没办法展开讨论的太深刻，甚至没有办法准确描述这种切实发生在我身上的现象，我现在所能表述的，大概是因为我现实中社交活动的匮乏导致我将网络社交作为了自己的第一社交途径，因而在网络中的烦恼作用在了现实之中。</p>
<p>即便如此，依然很难促使我在现实中的社交活动中有所改变，因为我所处的小环境的缘故，导致我不愿意花费太多精力在这一方面上。大学都已经过去两年了，大学才过去两年，我也不清楚这一方面的改进对我自身而言能否有所裨益，虽然之前我听过看过这样的言论：“之后工作了也不能保证自己能喜欢所有人，所以与自己不喜欢的人或者说一般的人打交道也还是必要的”，但是我不同意这样的说法，虽然一眼看上去所处的情景是一样的，但是其中的利益关系完全不同，在工作中，即便是你不喜欢的老板或者同事甚至下属，也能给你带来工作或者经济上的效益，而在校园的社交活动中却不能，因为也就失去了“必要性”。</p>
<p>那么“锻炼自己的能力”这一说法靠谱吗？这个我实际上并不清楚，因为我对于陌生人与并不熟悉的人，我现在已经能够在有话题可谈的前提下与他们沟通无阻，我缺乏的是在公众面前讲话的能力，时至今日虽然我能够站上讲台，但是我依然无法摆脱紧张的负面影响。</p>
<p>在现实中的社交的受阻也就导致了我将社交的重心移到了网络当中去，因而也就又了网络焦虑，在现实中社交的受阻源于我自视不凡，而在网络中的受阻源于我技不如人，这我或许该自嘲一下了，我现在的状态大概也就是高中班主任嘴里常常念叨的：“眼高手低，自命不凡”吧哈哈哈。</p>
<p>有问题，就要找出原因并加以改进，对于网络方面，最近我暂退来思考我未来在网络社交上的态度，对于现实方面，我大概依然不打算”加强社交“，但是我在读完手头中的书后大概会重拾心理学的书目，从某种方面讲大一读过的一点社会心理学确实给予了我一点帮助，书中我认同的内容为我的社交活动提供了理论依据，因此即便是与其他同学关系不是那么好，但我也算是”有理有据“了嘿嘿。</p>
<p>今天晚上有感而发写一点吧，最近已经在积极对自我进行调整了，但总的来说，问题出在别人，更出在我自己，如果我目前手头有能拿得出手的东西，大概也就不会这样了，说到底还是自己太菜了，当下能够改变自己这一现状的切合实际的方法貌似只有考研这一条途径了：去做学术研究？自己之前貌似没有想过，不过大概也还不错，我不太懂自己有没有这方面的天分，但是不试试怎么知道呢？但前提当然是自己能不能考上理想的大学与专业了，高考的失利使我一蹶不振，我能能否重新做回当年那个自己呢？一年半以后拭目以待！</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>奇思妙想</tag>
        <tag>社交</tag>
      </tags>
  </entry>
  <entry>
    <title>iPad书写体验</title>
    <url>/p/a833.html</url>
    <content><![CDATA[<p>iPad书写体验一直以来都被人们所诟病，因为Apple  pencil与屏幕阻尼过小导致大部分人体验极差，因此自从Apple pencil问世以来，人们就在不停探寻改善Apple pencil书写体验的方法，就目前来说，主流方法有：类纸膜，笔尖套以及第三方笔尖</p>
<a id="more"></a>

<p>首先我先说一下结论，单纯看书写体验，最好的是类纸膜+原装笔尖，其次是以珞小希笔尖为代表的第三方2B笔尖，最次是笔尖套，这三种方法各有各的优点，适用的人群也大不相同，并且每个人的书写体验以及习惯具有很强的主观性，因此以下内容仅为我的个人体验，并不代表客观评价</p>
<h1 id="类纸膜-原装笔尖"><a href="#类纸膜-原装笔尖" class="headerlink" title="类纸膜+原装笔尖"></a>类纸膜+原装笔尖</h1><blockquote>
<p>优点：还原纸质书写体验</p>
<p>缺点：类纸膜价格昂贵，严重影响屏幕分辨率，磨损笔尖(?)</p>
</blockquote>
<p>这个方案是目前绝大多数人在使用的方案，也是我最初使用iPad书写时使用的方案，当初刚拿到iPad之后立马就贴上了类纸膜开始使用了起来，虽然与纸质书写还是有点一点不同，不过能够很快适应，类纸膜表面的磨砂感能够很好还原在纸上书写的感觉并且能够提供良好的阻尼感，因此为绝大多数人所追捧</p>
<p>但是，类纸膜价格比较贵，价格差不多是钢化膜的2倍以上，不过个人感觉没有必要购买太贵的类纸膜，因为类纸膜本质上区别并不大，高价类纸膜提供的体验并不符合其价位，个人认为类纸膜选购价格在50-100元左右即可，之前有听说过这样一个说法：低价的类纸膜不是类纸膜是磨砂膜，个人认为这句话就跟凤梨不是菠萝，车厘子不是樱桃一样，具体什么意思自己体会一下吧</p>
<p>类纸膜对于屏幕分辨率的影响有多大？个人观感分辨率砍半，换算下来也就是iPad的分辨率被砍到720p～1080p之间的水平，这个说法毫不夸张，因为类纸膜表面的颗粒会严重影响分辨率，更加可怕的是，表面的颗粒会折射屏幕光线，导致你看屏幕会有类似相机拍照出现的彩噪，如果你要兼顾观影体验的话，这个影响无异于直接给你打回视网膜屏前的iPad（iPad1，iPad2），有的人大概是能接受或者说能凑合，反正我有点接受不了了</p>
<p>磨损笔尖这个说法见很多人说过，不过我不知道是我写的太少了还是那些人下笔太重？个人notability笔记差不多1000页应该是有了吧，笔尖能看到磨损但是并不影响正常使用，如果那些人是因为磨损笔尖不好看而不是磨损笔尖导致不能用那我也无力吐槽，个人觉得有点迷惑，笔尖生来就是为了磨损的，不磨损还供起来养着？</p>
<h1 id="钢化膜-2B笔尖"><a href="#钢化膜-2B笔尖" class="headerlink" title="钢化膜+2B笔尖"></a>钢化膜+2B笔尖</h1><blockquote>
<p>优点：书写声音较小，保留了屏幕全分辨率</p>
<p>缺点：阻尼感仍然不够，书写时屏幕过滑</p>
</blockquote>
<p>2B笔尖不同于原装笔尖是硬的，笔尖实际上是有一点软的，这样就能够极大减小书写时笔尖碰触屏幕发出的声音，我在使用的iPad Pro是全贴合屏幕，使用2B笔尖之后的声音几乎听不到了，不过iPad就不清楚了，非全贴合屏幕手敲一下都会有很大的声音</p>
<p>使用2B笔尖就是为了全分辨率，不影响分辨率自然也没什么好说的，分辨率就跟你刚拿到iPad还没有贴膜时一样，由于我使用的是iPad Pro，我不能只记笔记吧，那就太浪费iPad Pro强大的性能以及屏幕还有扬声器了，钢化膜价格不高，建议使用20～40之间价位的钢化膜，个人使用的钢化膜价格是36元，使用起来非常棒，感觉这个价格就是非常高端的膜了在贵没什么必要。另外这边安利一下大米家的钢化膜，在使用iPad Pro34以及iPad Air4的小伙伴强烈建议使用这个膜，因为这个膜不同于市面上其他膜在Face ID以及摄像头处开了一个刘海（iPad都要开刘海真的是巨丑巨丑），这个膜是全贴合的，只有证明麦克风处打了一个小孔，其余的地方没有开控没有刘海，并且膜的周围还是有点弧边的，这就很棒</p>
<blockquote>
<p><i class="fa fa-info-circle" aria-hidden="true"></i>   <a href="https://m.tb.cn/h.4lA1xZY?sm=c28238">大米评测iPad全面屏钢化膜</a></p>
</blockquote>
<p>刚拿到2B笔尖的时候在屏幕上划拉了几个字，感觉还凑合，阻尼感有点像橡皮的感觉，但是实际书写时就不大行了，虽然阻尼大于原装笔尖，但是还差得远，依然比较滑，并且类纸膜的精髓在于其表面的凹凸不平还原了纸张凹凸不平的感觉，这个笔尖完全没有，所以根本没有在纸上写的感觉，体验只能说能用，原装笔尖个人认为是完全不能用</p>
<p>还有一点就是，我购买的膜表面疏油层做的非常到位，导致书写的时候手与屏幕的接触面阻尼较小，手会有点打滑</p>
<p><i class="fa fa-arrow-circle-right" aria-hidden="true"></i>   使用大约4天后的补充：第一天开始使用的时候是非常非常难受的，因为假期中写字不多，开学都会出现“不会写字的”现象，再加上钢化膜的负面手感加成，写出来的字会歪歪扭扭，横不平竖不直，很难写也很难看，具体分析原因大概是因为阻尼太小导致下笔很滑，笔尖移动的方向与距离不会按照自己的意思来，很难写出直线来，据我多年写字的经验，写字要好看一定要横平竖直（这里说的好看不是传统意义上的好看，而是别人看你写的字能很轻松看出你在写什么字）而由于笔尖过滑导致并不能写出直线来，具体什么样子，看下图：</p>
<img src="/p/a833/IMG_1931.jpg" class title="第一天使用notability书写的部分笔记1">

<img src="/p/a833/IMG_ABA976E152E2-1.jpeg" class title="第一天使用notability书写的部分笔记2">

<p>当时我写完标题还在下面重新写了一遍尝试补救一下，但是失败了，我这辈子都想不到自己能写出这么歪的字来，并且当时写的非常吃力，因为笔很滑，每写一个字我都要付出巨大的努力</p>
<p>不过当我使用4天后，不知道是因为笔尖被“用开了”的缘故还是因为我熟悉了这样的阻尼感了，写字莫名变得顺滑起来，虽然还有一丢丢打滑，但是写字已经基本上能有之前的感觉了（<del>虽然手感依然不咋滴</del>），并且写字没有前几天那么吃力了，写字用的力度基本上就是之前正常写字的力度了，不知道我继续使用以后会不会完全适应呢？让我们拭目以待！</p>
<p>另外更换钢化膜还有一个问题，那就是屏幕反光问题，之前的类纸膜由于屏幕是磨砂的，导致一些较强光源在屏幕上的反光被大大削弱了，因此在之前一年多的使用中没有被反光问题困扰，但是新学期我换上了新的钢化膜并且开始使用屏幕挂灯我发现一个大问题：电脑显示屏是不反光了，但是我的ipad显示屏会反光，我能做的唯一解决方法就是书写时身子更靠前一点</p>
<h1 id="钢化膜-笔尖套"><a href="#钢化膜-笔尖套" class="headerlink" title="钢化膜+笔尖套"></a>钢化膜+笔尖套</h1><blockquote>
<p>优点：价格低廉</p>
<p>缺点：容易破损，体验类似2B笔尖</p>
</blockquote>
<p>笔尖套价格是公认的低，几块钱就能买到好多，不过笔尖套也分好多种，个人没有进行太多体验，因为其价格低廉就注定了体验绝对不会好太多，因此我对笔尖套的评价不具备任何参考价值，看看图一乐就行</p>
<p>为什么要买很多笔尖套？因为容易破损，你想想，你在教室上着课，看着黑板，记着笔记，突然笔尖套就破了，你还忘带多余的笔尖套，这多蛋疼？</p>
<p>体验个人没有细细体验，但是鉴于材质与2B笔尖类似，暂时默认体验类似，此处待完善</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>另外还有往笔尖上贴各自胶带的，emm。。。看着就有点傻，不过这个自己完全没有试过，所以也不做评价，最近打算从网上买一个iPad笔尖各类笔尖套以及贴纸的试用套装，过一阵到了以后全都试试再完善一下</p>
<hr>
<p><strong><i class="fa fa-info-circle" aria-hidden="true"></i>   待完善的文章，内容尚不全面</strong></p>
]]></content>
      <categories>
        <category>评测</category>
      </categories>
      <tags>
        <tag>iPad</tag>
        <tag>Apple pencil</tag>
      </tags>
  </entry>
  <entry>
    <title>低廉的价格，低廉的体验————从小米小爱音箱Play到米家</title>
    <url>/p/aa9d.html</url>
    <content><![CDATA[<p>今年年初，为了配合寝室内的其他米家设备，我换掉了之前办手机卡送的天猫精灵音箱，取而代之的是小米小爱音箱Play，本篇评测不仅仅是对这个音箱进行评测，更多的是一年多以来在寝室使用米家设备的一些体验，如果你对小米小爱音箱其实并不是特别感兴趣但是你对米家智能设备有兴趣，那么你可以看看我是怎么吐槽米家这些破玩意的</p>
<a id="more"></a>

<p><strong><i class="fa fa-info-circle" aria-hidden="true"></i>   声明：</strong>我其实也算是半个米粉了，购买很多电子产品的时候都会优先考虑小米的产品，因此本篇评测可能说不上完全客观但是我绝对会有一说一，并且实际上这一段时间米家的体验非常糟糕，至于怎么糟糕，请看我慢慢道来</p>
<h2 id="本篇内涉及到的所有设备："><a href="#本篇内涉及到的所有设备：" class="headerlink" title="本篇内涉及到的所有设备："></a>本篇内涉及到的所有设备：</h2><p>米家空调网关，米家门窗感应器，小米音箱Play，iPhone11，米家智能蓝牙温湿度计，米家无线开关，飞利浦智能台灯，米家夜灯2</p>
<h2 id="音箱开箱"><a href="#音箱开箱" class="headerlink" title="音箱开箱"></a>音箱开箱</h2><p>这款小米小爱音箱是我以75元包邮在闲鱼上从个人卖家手中收的，全新未拆，生产日期是2020年6月，我觉得没差，跟其他渠道买的都一样</p>
<p>包装盒基本上就是一层纸壳子实际上对里面的产品没有多少保护作用，毕竟这个玩意的价格在这摆着，官网价格实际上也不过百，包装什么的廉价一点无所谓，拆开盒子，拿出主体，小爱音箱Play延续了小米音箱一贯的设计风格，实际上就是小爱音箱的缩小版，这个外观见仁见智吧，我个人认为说不是好看也说不上丑</p>
<p>之后，便是噩梦的开始</p>
<h2 id="配对"><a href="#配对" class="headerlink" title="配对"></a>配对</h2><p>这个破玩意死活连不上Wi-Fi，明明其他设备就是连的同一个Wi-Fi，但是小爱音箱Play一直无法通过米家app进行Wi-Fi的连接，我翻了翻说明书然后网上搜索了一下，从app Store下载了“小爱音箱app”才吧这个音箱连上Wi-Fi接入米家，这一方面体验巨差，鬼知道为什么连不上网，顺便一提我的青米智能插座也很久很久连不上Wi-Fi了，翻看说明书，从网上查资料都没办法重新配对，所以就交了智商税：拿买智能家居的钱买了普通家居</p>
<h2 id="小爱同学，打开温控"><a href="#小爱同学，打开温控" class="headerlink" title="小爱同学，打开温控"></a>小爱同学，打开温控</h2><p>连上Wi-Fi以后，我便迫不及待打开了这个音箱一个非常大的卖点，那就是蓝牙网关，这个可能是米家系列最便宜的蓝牙网关了，其他的蓝牙网关都是插座样式的，价格也在几十块钱不等，这个买网关还送音箱功能，岂不美哉？但是呢，蓝牙网关功能打开之后，音箱就没办法使用蓝牙模式了，也就是没办法通过蓝牙连接手机播放音乐，这个对我影响不大，毕竟这玩意音质肯定不如我iPad和耳机</p>
<p>我的寝室内有米家智能蓝牙温湿度计，这个温湿度计之前我买了触屏版小爱音箱就没办法连，然后我觉得是那个小爱音箱的问题并且实际上我买了那个音箱有点小后悔，我就给退了，时隔一年多我终于通过蓝牙把这玩意接入米家了！我终于可以随时在手机上看寝室的温湿度状况以及温湿度变化曲线了！然而这玩意的刷新率貌似。。。非常低，我从app中只能看到每小时的温度然后每小时的温度用“平滑曲线”连起来，一个小时一同步。。。我都无力吐槽了。。。如果对于“看温度”来说其实还是够了，但是呢，我总想搞点骚操作，我想通过这个温湿度计结合空调控制器实现室内恒温功能，但是呢，刚刚也将了，一个小时一同步温度，一个小时。。。我要么热死了要么冻死了，反正我就开了一次这个功能发现空调根本不会像我想象的那样智能开关，所以我也就没用了</p>
<p>然后呢我宿舍也没有什么其他的蓝牙的米家设备，其他的蓝牙设备还有个米家电动牙刷，没办法通过蓝牙传输刷牙数据</p>
<h2 id="小爱同学，放首凉凉"><a href="#小爱同学，放首凉凉" class="headerlink" title="小爱同学，放首凉凉"></a>小爱同学，放首凉凉</h2><p>起因是一天下午考试前，按照惯例临走前放！战！歌！没想到小爱跟我说：“对不起，没有凉凉”（没有《凉凉》这首歌/考试没有凉凉）把我们都整乐了，考完试我又去试了试小爱音箱的曲库，甚至连《Are you ok？》都没有，有的过年过节放的那种喜庆的歌也没有原曲，取而代之的是一些唱的很垃圾的翻唱，小米音乐药丸，此时我突然想起来能把曲库换成QQ音乐，我切乎后再次尝试曲库，本来还以为能白嫖会员，结果发现很多歌都需要会员，《凉凉》也只有试听版，不过曲库至少比小米音乐丰富一点</p>
<p>另外在放歌的时候，那个音质，低音不足，中音不行，高音也不行，说不上特别廉价到不能听，但是确实不是很好听，要买贵的小爱音箱肯定会好一点，但是前提是：你有QQ音乐会员</p>
<h2 id="小爱同学，空调制冷24度自动风"><a href="#小爱同学，空调制冷24度自动风" class="headerlink" title="小爱同学，空调制冷24度自动风"></a>小爱同学，空调制冷24度自动风</h2><p>米家这个空调网关一开始还好，疫情期间不在寝室并且我换了热点之后，网关里貌似自己存了一些自动化，导致某些特殊时间点比如7点，23点，24点等会执行我之前设置的自动化，这些东西具体设置的什么我已经忘了，并且米家app我已经全部清除了，但是这个空调网关内部的存储貌似并不会因此而清楚，迫于无奈也只能在自动化里面新设置几个特殊是简单+1分钟的关闭空调的指令</p>
<p>另外我用上小爱音箱Play之后，有些指令它不能正确执行，指令原本都执行完了，空调设置好了，它反手给我把空调关了，我：？？？？？并且反手关空调这种事情还不是偶然现象，出现的次数还是蛮多的，有时候还反手给我开一个暖风？我使用手机手动控制的时候从来没有出现按冷风出暖风的情况，因此应该不是红外信号的问题，在这里出现的问题绝对就是米家的问题</p>
<h2 id="小爱同学？小爱同学？"><a href="#小爱同学？小爱同学？" class="headerlink" title="小爱同学？小爱同学？"></a>小爱同学？小爱同学？</h2><p>我不知道是性能的原因还是什么玩意，小爱音箱Play有时候会卡，就是你叫他时候他回应一下，然后就卡机了，按按键也不管用，这就emm。。。很让人抓狂吧。。。</p>
<p>并且实际上用了这一阵，我并没有感觉到小爱多么智能，感觉跟几年前我主力机还是小米手机的时候并无区别，有些人能理解的口令依然无法很好的执行</p>
<h2 id="米家？狗都不用！"><a href="#米家？狗都不用！" class="headerlink" title="米家？狗都不用！"></a>米家？狗都不用！</h2><p>前一阵我用米家app深色模式，他们的工程师居然就直接把背景搞黑就整出来个深色模式，我经常在半夜点开一个设置或者功能找不到返回键，后来才发现，米家工程师只改了背景颜色，然而文字很多也都是黑色的，两者重叠文字就看不到了，米家团队建议把做深色模式iOS开发那个人开除咯，有这么敷衍的吗？到现在这个现象少一点了但是还有残余，比如这个台灯亮度设置，以及米家app深色模式打开后需要有操作，比如点开一个选项，深色模式才会启用</p>
<img src="/p/aa9d/mihome.png" class title="米家App内台灯控制页面">

<p>米家那些对于智能设备进行自动化运行的选项。。。几年了都，完全没改没进步，功能逻辑较少且设置并不方便快捷，并且你以为他会乖乖听话，但是实际上并不会，比如设定通过位置来进行自动化，位置经常有问题，我给了精确位置权限，并且米家在后台，也都没用，然后还有就是前面提到的温控，完全没法实现，还有一些稍微复杂一点的逻辑都搞不来，我寝室就这么几样东西都设置不来更何况设备更多的情况</p>
<p>小米貌似也对广告特别执着，特别喜欢给自己app通通加上广告，加上一些花里胡哨的购物的选项卡，很无语，用户有需要自然会去下载小米有品，你非要给米家植入这些玩意我感觉没必要并且还降低用户体验</p>
<h2 id="其他米家设备"><a href="#其他米家设备" class="headerlink" title="其他米家设备"></a>其他米家设备</h2><p>米家那个门窗感应器，额，我除了用它来看宿舍有没有查卫生（在我们上课时间门被打开）外没有啥用，本来想设置一些自动化，但是舍友老不关门并且门经常被打开关闭就很难设置，当然我知道这个是我自己的问题，所以这个玩意还是凑合的，但是价格有点小贵</p>
<p>米家无线开关：这个东西比较小，也很贵，一个差不多五六十我记得，之前是用来设置空调一些预设模式以及开关台灯，没有出现过错误操作，还算可以</p>
<p>米家温湿度计：价格老贵，比现在新出的那个小的贵多了，我记得要80左右吧，忘记了，然后数据跟音箱连接只能一小时一同步，就很难受，但是本身颜值还可以，传感器刷新率以及准确度也都可以，并且还可以从粘贴的地方方便得拿下来</p>
<p>米家夜灯2：我这个是非智能款，如果是智能款可以搭配当作人体传感器用，比单独买划算非常多，因我对我来说目前没必要就没换，值得一提的是，这个东西非常非常耐摔，我的米家夜灯2从双层床上铺摔下来少说几十次了，依然正常使用并且没有裂口，大概是跟圆润的设计脱不了干系，就是有时候蚊帐会误触，这个需要注意</p>
<p>飞利浦智能台灯：这个不是小米代工厂的东西，但是接入了米家，体验上尚可，就是个台灯也没什么太多好讲的</p>
<p>青米智能插座：这个玩意用一阵就连不上网了，并且能连上网的时候也不能对单独插口进行控制，只能全部开全部关，以及计算功率，因为我连不上网因此后面的功能我现在就都用不到了，不知道网络这个是米家app的问题还是产品本身的问题</p>
<p>米家空调网关：这个作为家庭中枢插在空调插座上，还是蛮好用的但是问题也是很多，之前也都讲过了：无法清除之前设置的自动化，配合音箱有时候瞎调节，这其中任何一个都是致命的，不知道米家团队在搞什么</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之我因为寝室限制，很多东西没买也没办法用，但是只是这几样的体验就并不是很好，我的寝室功能核心是小爱音箱以及对空调的控制，小爱音箱控制空调有问题，音乐曲库也很少，然后还卡死，然后还不好连Wi-Fi，空调网关那边之前残留的自动化没办法清除，这些问题除了音乐曲库由于版权问题可能不太好搞之外，其他都是完全可以解决并且都十分致命的问题，我不认为米家团队没有能力解决这类问题，因为时间跨度太久了，这些东西没搞好就是团队本身压根就不知道自己产品存在哪些问题或者压根不想做</p>
<p>由于米家团队的问题，我感觉未来十分渺茫，本来觉得米家应该拥有国内最多的智能家居，用的人很多，体验上一定不会很差，但是到现在我的体验真的不好，虽然平常一定程度上给我带来了便利，但是有问题的时候也是很糟心的，更何况问题并不少呢</p>
<p>这次评测写的比较乱吧，因为前一天晚上睡觉太晚了脑子也不是很清晰，所以凑合康吧，绝大多数问题我都写出来了，算是拔草吧，体验实在不行，除非你能保证自己拿到手设置好之后就不乱动了，大概就不会因为之前一些操作逻辑以及自动化把之后设置的东西打乱掉吧</p>
]]></content>
      <categories>
        <category>评测</category>
      </categories>
      <tags>
        <tag>小米</tag>
        <tag>米家</tag>
        <tag>小爱音箱Play</tag>
        <tag>智能家居</tag>
      </tags>
  </entry>
  <entry>
    <title>危险品押运员生活体验</title>
    <url>/p/631a1438.html</url>
    <content><![CDATA[<p>最近在家“里闲来无事”（我妈觉得我很闲），正好临近过年，年前就让我跟我爸出去拉货挣钱去，正好也算是让我体验体验生活，并且是往江苏跑，也不用担心中高风险区什么影响返校，毕竟学校就在江苏，我索性就跟着去了，一开始我想的是拿着笔电，在车上学习来着，后来嘛，就没学成……<del>不过钱还是赚了的，赚钱就好XD</del></p>
<a id="more"></a>

<blockquote>
<p><i class="fa fa-info-circle" aria-hidden="true"></i>   本篇初写于第一次行程后，所记录的为第一次行程，由于初一后还出车前往太仓，故将两篇汇总，引用栏内为第二次行程内容</p>
</blockquote>
<blockquote>
<p><i class="fa fa-info-circle" aria-hidden="true"></i>             由于替班工作地方不同，第一次与第二次行程时所使用的汽车不同，第一次为北奔重卡一未知型号手动挡汽车，第二次为中国一汽解放J6P自动挡汽车，本文涉及图片均为后者</p>
</blockquote>
<p>之前疫情期间在家闲来无事，正好自己刚考完驾照，于是有段时间我就每天自驾去隔壁区驾校学危险品押运员证，考证后半年多没用过，年前这一阵终于有机会出挣钱了！持证上岗！</p>
<img src="/p/631a1438/IMG_5582.jpeg" class title="危险品押运员证">

<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>工作第一天，上午我像往常一样在床上趴到差不多10点，然后刷刷B站，差不多到中午吃完饭就匆匆忙忙地准备走，我本来没以为会走这么急，没想到啊没想到，然后我妈那边，她问我拿不拿方便面，我说嗯，然后就没然后了，她的意思是提醒我让我自己拿，我的意思是我以为我妈会给我拿，然后就没拿，我也不好多说啥，反之也不是多么必要的东西，无所谓了，我爸那边，又是忘拿工作鞋，又是忘拿饼啥的，因为发现的时候已经离家很远了也懒得回去拿了</p>
<p>这次出来我拿了一些吃的，充电器，手机，iPad，笔电，单片机啥的，当时的雄心壮志是打算正好用这几天时间好好学习复习一下单片机，正好也能挣钱，一举两得，实际上车晃的要死，在车上别说用笔电了，我用手机看番都不舒服</p>
<p>我妈开车把我们送到了郊区停车场里，开上车，出发去滨州博兴的一个工厂拉货，第一次坐上公路上的“王者”，视野就是不一样，视野要高很多，并且由于车头跟驾驶室玻璃是平齐的，在对前方距离的判断可以比小车更精确一些，并且反光镜有两对，主驾驶和副驾驶各用一对，主驾驶用的差不多是副驾驶反光镜的两三倍大，车内很宽敞，驾驶室主驾驶副驾驶不是连在一起的，中间有一部分是高起来可以放一些杂物的，比如做饭的锅，桶装水，充电器，证件啥的，驾驶座后面是双层床，下面那一层比驾驶室与副驾驶中间那一部分还高一点点，同样上面也是队满了衣服被子还有一些杂物啥的，双层床的第二层一端由铰链固连在车壁上，另一端则是由两个安全带绳连在车顶上，还算牢固，平时开车的时候就把安全带一端插在车顶上，形成一个三角形区域减少开车时占据的车内的空间，设计的还算合理，然后在我副驾驶座位下还放着一个暖壶，用来盛开水，并且车内车外也有很多柜子可以放东西，总之就是比之前坐过的任何一种车都宽敞一些，刚上车还算舒服</p>
<img src="/p/631a1438/IMG_5285.jpeg" class title="主驾驶处反光镜">

<img src="/p/631a1438/IMG_5284.jpeg" class title="副驾驶处反光镜">

<blockquote>
<p>对比第一次行程，第二辆车就比第一次的好多了，车比北奔重卡那辆更宽敞，并且车头大概高半米，即便是我站在副驾驶的座位上头也距离车顶还有一小段距离，因此大概估计车内空间应该在2.3m—2.5m之间，第一辆车估计在1.9m左右，可以说第二辆车在高度上相当舒服了，并且，第二辆车的悬挂系统比第一辆好得多，在旅途过程中没有第一辆那么颠，不过由于第一次出车非常颠簸所以第二次我就没拿笔电，没想到第二辆车的悬挂系统完全允许我使用笔电，还有就是双层床不像是第一辆车那样用安全带吊着，而是使用了液压杆的设计，这个设计就非常棒了，收起放下二层床毫不费力并且驾驶室貌似还比第一辆车长一点，因为第一辆车放下双层床后会压迫到驾驶座，因此第一辆车在行车过程中无法使用上层床，而第二辆车就不会，大概也是因为第二辆车二层床小一点的缘故？我没有测量尺寸所以没办法对比，但是使用体验是绝对比第一辆车好</p>
</blockquote>
<img src="/p/631a1438/IMG_5282.jpeg" class title="折叠床">

<blockquote>
<p>再就是从司机角度来看：自动挡，毫无疑问，这意味着轻松，半挂车分为12个档位，并且半挂车平时也就是跑60km/h左右的样子，档位分的比较细，如果遇上红绿灯或者说堵车就非常难受，而自动挡就完全解决了这个烦恼，刚拿到车的时候我爸还不会开自动挡，因为他和我都没有开过自动挡的汽车，家里汽车是手动挡的，但是考虑到自动挡的档位分布图，大概就能判断出：R是倒车，N是驻车，D是行车，+-分别是加减档，而A/M根据常用缩写可以判断出是Automatic/Manual（自动/手动），也就是切换为A自动挡时，变速杆放在D行车档上就行，切换为M手动挡时，变速杆也是放在D行车上，但是可以通过+-来加减档，在实际操作后，果然就是这样，<del>那么这样我也会开自动挡半挂啦XD</del></p>
</blockquote>
<img src="/p/631a1438/IMG_5583.jpg" class title="变速杆">

<p>在车上睡了一个午觉后，到达工厂，但是拉货需要排号，那个工厂看起来也不小，并且来的车很多，下午到的，结果我们排到晚上才进去装货，装货的时候貌似工厂有规定，不允许带手机入内，貌似也不允许带水？反正不能带手机这个我理解，但是不能带水就很迷惑，车内小杯子还在，但是装水的大桶以及暖壶我爸都拿下来了让我在外面等着，然后我看外面其他正在等候的押运员也都是拿着大瓶小壶的，我也就懒得问了，跟我也没啥关系</p>
<p>进去装货的时候是司机进去装货，押运员在外面等候，工厂门口有押运员等候的小房间，里面看着有空调，但是貌似没开？因为感觉跟外面温度差不多，不过起码挡风，我就在里面畏畏缩缩等了一个多小时吧，鬼知道装货怎么这么慢，等装完以后也八点多了，干脆开车回家了，回到家吃晚饭拿上之前忘记拿的东西就尽快睡觉了，因为第二天早上要5点起床不早睡可起不来</p>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>虽然我平常早上起床起不来，但是有必要的事情要做的时候我还是很准时的，起床以后还是跟第一天中午一样我妈把我们送过去，然后我们开车正式出发</p>
<p>此次行程是去往无锡锡山，本来是要去景德镇的，但是嘛，由于一些原因不去了改成去无锡了，不过也行8，少去1天正好也赶在年前前一天回来，看了一下导航，全程大约七八百公里，按照大货车限速60再加上走下道红绿灯，要跑十几个小时，估摸着晚上大约能到扬州，到时候就在扬州睡觉，早上起来上高速</p>
<p>平日里坐惯了小轿车，半挂车明显比小轿车颠簸的多，看来小轿车悬挂比半挂车好得多，我原本以为半挂车重量比较大，同样颠簸的路段会更稳，没想到跟我想的正好相反，一路上真的巨颠簸，有些老国道省道都破烂不堪了，地面上坑坑洼洼的，跑几步颠一下，我干脆就先补觉吧，中途的时候经过一个包子店我爸下去买了点包子吃，这就是我们出来第一顿早餐了，平日里我是不吃早餐的，但是我还是吃了点，不吃也不大行，吃完我就继续睡</p>
<p>一觉睡起来已经是中午了，我们到了一个镇上，我爸说这个地方的烧鸡挺好，然后他就下去买了个烧鸡，我们在车上馏（蒸）了点饼就着吃，草草的解决了中午饭，继续启程，下午我也是昏昏沉沉，想拿笔电，又有点晕不想动，不拿笔电吧，又有点精神就看看手机，就这样在纠结中度过了一个下午，最终还是没能拿出笔电学习（</p>
<p>到了晚上在一个村旁的路边停下做饭，我爸拿了些芹菜炒了炒吃，味道肯定是不如家里的，但是不知道为啥在车上啥也不干我还有点饿，估计是一路颠簸，然后就跟那些瘦身机器是绑在身上震动差不多原理吧，一会功夫芹菜就被恰完了，洗洗锅继续上路</p>
<p>晚上按照计划，差不多9点半到达扬州，在路边停车的时候还因为太黑，没看到草丛里不知道哪来的一根铁杆子，把车后保险杠给淦弯了一点，不过还好就是丑了一点，尾灯没有什么影响。我在路边上个厕所然后漱漱口就准备上床睡觉，因为下铺放的杂物有点多，我懒得收拾，并且我爸在下铺可能会方便些，我就睡上铺了，从家走的时候我妈觉得车上的被子不干净，还给我拿了个睡袋让我睡在睡袋里，外面再盖上被子，会干净一点，我也就照做了，但是吧，说实话，睡睡袋真的不咋舒服，像我这种睡觉不怎么老实平常特别喜欢翻身并且还有抱抱枕习惯的人来说，睡袋里面那一点点空间完全就是把我束缚住了，怎么动都不方便，并且如果里面捂的比较闷热的话还没有办法像平常被子一样掀起来就能把热气放出去，所以睡睡袋挺难受的，这破玩意也就是拿着比较方便，真要睡觉还是盖被子好</p>
<p>白天睡了大半天的觉，晚上车停稳以后，我爸早早的就睡着了，我在被窝里看番顺便吃lex的瓜到11点多才睡觉，真正意义上的第一天就这么过去了，说实话，挺无聊的，基本上在车上能做的事情也就是玩手机，看看文字类信息（但是容易晕），看看短视频（因为比较颠簸，看视频体验比较差，长视频比如番剧不能很好地看到弹幕以及视频中的细节，如果我是专职押运员我肯定会去买个云台看视频）还有睡觉，睡觉还睡的我脖子疼，因为没有拿U形枕，并且副驾驶的座位被阉割的很严重：没有前后调节，没有高低调节，靠背角度调节有限，所以坐着也不咋舒服，根本没有办法很好的集中精力干其她的事情，所以说这项工作的前景很差，想要做专职押运员的话基本上以后也就这样了</p>
<blockquote>
<p>第二次行程本来说着去南通来着，但是鬼知道怎么回事是去太仓，而第二次行程由于是在过年期间，高速不允许上危化品车，所以要过江就必须走轮渡，走轮渡时上下坡起伏比较大，第一次上轮渡的时候用的是自动挡，速度快了汽车自动加档，导致中途憋火了，并且汽车还有一股浓浓的柴油没烧完的味道，当时可给我吓死了，因为停的地方正好在船与地面形成的V形坡的中间，我不知道这样会不会把挂车与牵引车中间的连接处搞断，车上拉的货是四氯乙烯，再加上那个柴油没烧充分的味道，巨TM恐怖好吧，不过还好，最后我爸还是平安把车开上去了，也算是有惊无险吧</p>
</blockquote>
<img src="/p/631a1438/IMG_5335.jpeg" class title="轮渡">

<blockquote>
<p>登上轮渡以后，我穿上外套去甲板上看风景，前边是高速公路通过长江的沪苏通长江公铁大桥，后边是南通延边的货运码头，左右两边有行驶过的货船与航道浮标，上边有点点星光，迎着江风，戴着耳机放一首最喜欢的歌曲，感叹人类工业文明的伟大</p>
</blockquote>
<img src="/p/631a1438/IMG_5343.jpeg" class title="长江（夜）">

<h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h1><p>因为昨天晚上撞到那个柱子的事情，我爸一晚上思来想去早上睡不着差不多4点多就醒了，哎，我也是服了，屁大点事纠结那么久，然后5点钟他就准时开车走了，我5点醒来以后本来想起床来着但是我还是跟在家一样：关了闹钟继续睡</p>
<p>一觉醒来已经是8点了，车停在了服务站，我就说之前怎么那么舒服，原来是上了高速后路面比较平整就不颠簸了，这一觉睡起来还真是爽，醒来以后我穿上衣服去给我爸装油，不知道为啥，我爸让我把油从车里卸出来，然后拿一个桶装起来再从上面倒回去，这个操作我是没看懂，咱也不知道为啥，咱也懒得问，反之倒了三桶油以后就完事了，上车继续出发</p>
<p>很快，上午大约9点我们就到了那个厂子，貌似是一个生产润滑油的厂？厂子比起之前装货的厂来说真是太小了，这个厂子是私营的，管理相对来说松一点，按理来说卸货是需要押运员全程盯着的，但是因为私营小厂嘛，我也就不用全程盯着，在车上看看手机，差不多半个小时就完事了，卸货前后都是要称重的，称完以后那边的负责人说少40kg，我第一反应就是少了就少呗，又不多，误差范围内嘛，但是按照人家的规定要扣钱，最后是扣了150块钱，真的坑啊，因为毕竟装车的时候用的称跟卸货的时候不一样，再加上这么远的运输，车内驾驶室啥的东西也有少许变动，这40kg相比于30多吨的货来说差不多也就是0.1%多，这还能算？不过扣钱毕竟不是扣我们的钱，跟我们关系也不大，所以也不必太理会，最后运费一共给了10050，本来应该是10200，因为扣去了150所以就这样啦，这样算的话也就是说差不多800kg的行程运30t多点的油运费是10200，这样我也就大致知道了这方面的运费</p>
<blockquote>
<p>第二次行程卸货之后是比之前多20kg的样子，在卸货之前我看到了车上的记事本，上面记载了之前日常工作的每一次的装货记录，基本上都是会多20-40kg，看来这就是跟地磅由很大关系，第一次去的时候真的坑，明明不是我们的原因，还是要扣，不过没扣我们的钱还好</p>
<p>第二次出行去的厂子还算蛮大的，在太仓工业园里面，工业园我是第一次去，里面全部都是工厂，工厂与工厂之间用道路分隔，整个区域布局非常整齐整洁，毕竟是专门为了搞工业开设的园区，我估摸着那些产业园科技园都是类似的布局</p>
</blockquote>
<p>返程还是需要走一段高速，因为毕竟要跨过长江，不走不行，高速路费也是蛮贵的，淮安大桥走过去要200块钱，大车跑1km大约要2块多，然后如果走隧道啥的都是按米算钱的，为了省钱能不走高速就不走高速，扬州到无锡这一段来回高速都要1k多，真的贵，但是体验也是真的好，高速最低速度60，没有红绿灯，路面平整，下道最高速60，还有红绿灯，其实最高速度无所谓，主要是红绿灯太费时间了，半挂车起步很慢，碰见一个红绿灯损失的不止是等红绿灯的时间，还有汽车启动加速的时间</p>
<blockquote>
<p>过江依然还是走轮渡，不过这次去通常轮渡，之前没过江的时候问过通常轮渡这边，说北往南不走，南往北可以走，我也不清楚这有什么区别，不过既然说了北往南不能走就只能绕道走通沙轮渡，这次回去自然就不绕道了，因为通常汽渡是离我们最近的，貌似也是长江离海最近的一个轮渡？</p>
</blockquote>
<img src="/p/631a1438/IMG_5389.jpeg" class title="长江北岸码头">

<h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h1><p>返程的话也就那样？没有什么好讲的，顺着原路回去就行了，回去以后先去找了个地方修车，后面那一点虽然完全不影响使用但是毕竟车不是自己的，修还是要修的，持证上岗拿到人生第一桶金：880元</p>
<blockquote>
<p>第二次回去拿工钱的时候出了点小插曲，一直联系不上老板，刚回去的时候老板说等那个人一起结，因为我们出去的时候是两辆车，我们先回来了让我们等他们，不过还是难以理解，我们又不认识，而且我们先完工了为啥让我们等他们？之前其实我们和那一辆车进度车差不多，但是卸货的时候他们早跑我们前面去了结果化验报告暂时找不到了就让我们先卸货了，我们卸完货那个司机才在自己口袋里找到了化验报告，我们自然不会等他们，就早走了，最后早一步回来</p>
<p>等到那辆车回来以后，老板直接联系不上了，当时我们以为要拖欠工资，那个司机就报警了，然后我们这就暂时把车上的行驶证车钥匙拿走了，第二天老板才告诉我们昨天喝醉了，让我们回去拿钱，我就懒得去了，让我爸自己去的，我爸回来告诉我另外那个司机不咋滴，态度不大好，因为这次出去涉及到目的地变更以及轮渡的问题，多跑了路程，并且这车是改装双油箱，我爸不会用，路上漏了好多油，回去的时候还加了200多块钱的油，但是那个司机，他开车习惯不好，踩油门踩的重，他加了800多块钱的油，我都惊了，800多块钱差不多一天白干，那个人心里很不平衡呗，不过因此我也知道开车踩油门不要太重，不然这个耗油真的太恐怖咯</p>
<p>这次行程因为是过年期间，工资自然高，这4天我就拿到了2000，这个假期用了一周时间挣了2880，还行叭，暑假有空再出去溜几圈挣点钱嘿嘿</p>
</blockquote>
<img src="/p/631a1438/IMG_5405.jpeg" class title="中国一汽解放J6P">

<hr>
<p><i class="fa fa-info-circle" aria-hidden="true"></i>   更新于2020/2/22</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>工作体验</tag>
      </tags>
  </entry>
  <entry>
    <title>不将就</title>
    <url>/p/3a76.html</url>
    <content><![CDATA[<p>事情源于前一阵子我与一位同学的对话，他其实是来拉我进他们机器人社团的，但是我那天晚上跟他聊了一晚上，从此我也得知了很多一些平时我大概接触不到的信息，并且我也确立了自己新的学习生活态度：<strong>不将就</strong></p>
<p>在我博客的个人简介中我提到过，我是汽车专业的学生，不过我的专业并不是汽车工程，或者是什么交通之类的，而是汽车服务工程，这个到底意味着什么我们大概其实也都并不是很清楚，但是我们知道，我们所学习的东西，只多不深，繁而杂，并且我通过之前我们的导学课程以及本专业同名课程中我也得知，这个专业大概就是：卖保险，卖车，保险公司检测之类的，本来专业对口的工作貌似就不是很好，并且我们这个还不仅仅是汽车服务工程，后面还有两个字：“师范”，这下子就更麻烦了，据班长的说法，我们要学习80%的汽车服务工程的课程，学习40%的教育学的课程，这下子也确实合理解释了为什么我们的课程这么多（这个学期大概有14门课程，而下个学期有15门课程），也就是说，本来我们的专业就学不精，这下加上个教育学，那就更杂了，并且最近通过去高职学校实训，我发现自己貌似并不想成为一名高职或者中职老师，因为那边的学生素质相对于普通高中的学生确实不足，其主要表现在对规则意识的缺失与对秩序的漠视，扯远了，这一方面我会在另一篇blog中详细提到，在此仅仅作为举例提一下下，总之我们的专业就是杂，并且包括我在内的大部分同学实际上都是被调剂过来的</p>
<p>那么问题就来了，既然在学校中有学习，那么就有考试，考试考的好的同学是抱有怎样的心态？而考试成绩差的同学又是抱有怎么样的心态？考试挂科的同学又是抱有怎么样的心态？</p>
<p><i class="fa fa-info-circle" aria-hidden="true"></i>    以下所有内容针对的专业为：冷门专业，就业前景并不好，且大多数学生都是被调剂的</p>
<h2 id="大部分成绩好的同学是在妥协，在将就"><a href="#大部分成绩好的同学是在妥协，在将就" class="headerlink" title="大部分成绩好的同学是在妥协，在将就"></a>大部分成绩好的同学是在妥协，在将就</h2><p>之前我也提到了，绝大多数我们这个专业的同学都是被调剂过来的，用数据来说话大概会更明确一些：我们2019级选择了这个专业的同学是个位数，而据说2020级选择这个专业的同学是0，这下就很伤脑筋了，这样一个大家都不喜欢的专业为什么有的人还在认真学习？这些人又是抱着怎么样的态度？</p>
<p>要知道，作为一个普通人，想要摆脱当下，改变自己是很难的，虽然很难，但是是完全没办法改变吗？不是的，但为什么绝大多数人没有选择改变？（至少我们班没有人选择转专业并且成功）那就是我们总是在为自己找理由，通过“努力学习”来为自己没有选择一个好专业找理由，这样即便是之后毕业了找不到工作，自己也可以理直气壮地说：我努力了，我找不到工作不是我的原因，是专业太烂了</p>
<p>从小学，初中，到高中，我们一直都是为了学习而学习，因为课程只有那些，它们就在那里，你学也要学，不学也要学，到了高中文理分科才有所选择，但是实际上区别并不大，因为选择的种类很少，绝大多数人肯定会：自己什么学的好就选择什么，到了大学情况就完全不一样了，每个学科的课程天差地别，整个大学课程分成了无数个大类，这些大类又分为无数个小类，小类又分成若干个种类，这对于绝大多数考生来说就很茫然了，在两年前我曾经也是，在选择专业上犯了愁，自己到底喜欢什么专业？什么专业就业前景好？然而我犯了一个巨大的错误：在选择专业上以学校为先，学科为后，因为自己高三一年都在摸鱼，导致高考成绩非常非常烂，只能压一本线：上一个二本的学校，我就选择了现在所在的学校，对于专业到底能不能选到自己喜欢的，貌似并不关心了</p>
<p>最终结果显而易见，我被调剂了，我的同学一部分人大概也是这样，绝大多数人包括我，接受了自己被调剂的命运，选择了来上学，还有相当一部分人，选择了复读，我们选择来上学的这部分人，依然秉持着之前学习的传统：有什么课，我们就上什么课，老师教什么，我们就学习什么，这有错吗？这没有错，但是却又错到了极点，因为你在做自己该做的事情，但是却又没有做自己想做的事情</p>
<p>我们总是按照课程表来安排自己的学习生活，既对自己的专业十分不满，又不打算去学习自己感兴趣的内容以此来改变现状，只懂得学习，却不懂得为什么学习，不懂得要学习什么，这就是在将就，即便是学习的再好又有什么用？如果你不是真的喜欢这个学科，你所谓的学习好也止步于大学阶段，兴趣是最好的老师，如果没有兴趣的支持，大概不会有所作为，并且因为专业本来就不好，大概也不会获得自己想要的生活</p>
<p>在与那位同学的对话中我得知，他是单招进来的，并且他在大一阶段学习成绩十分优秀：绩点在4以上（平均分90以上），对于这个的真实性，我保持无可置疑的态度，但是他很后悔：学习那么多东西有什么用呢？学的那么杂那么乱，又学不精，自己也不喜欢，因此他通过加入机器人社团做嵌入式来改变自己的现状，他成功了一半，到了现在，他已经是队长了，拿到过一些奖项，并且自己也有考验的目标，同时在他们社团的很多同学也都选择了考研或者转专业的方式来追求自己真正想要做的事情，这真的是很棒的选择</p>
<p>因此我学习的态度大概也会发生很大的变化：期末考试一定要过，但是并不打算好好学了，到了大二了，我貌似已经没有机会去选择转专业了，现在我将所有希望寄托于考研，通过考研达到一个更高的平台，去做自己喜欢做的东西，但愿我能够坚持下来</p>
<h2 id="学习成绩中等的学生鱼龙混杂"><a href="#学习成绩中等的学生鱼龙混杂" class="headerlink" title="学习成绩中等的学生鱼龙混杂"></a>学习成绩中等的学生鱼龙混杂</h2><p>一方面，这部分学生有像我这样以后打算搞其他东西所有不打算好好学，仅仅止步于期末考试不挂科的同学</p>
<p>另一方面绝大多数是一些同样秉持之前学习态度的同学，不过这类同学大概因为缺少了老师的管理因而放松，平时比较懒散但是上课该听还是听，导致学习成绩不那么理想，但是没挂科</p>
<h2 id="学习成绩很差的学生不但在将就，同时毫无上进心"><a href="#学习成绩很差的学生不但在将就，同时毫无上进心" class="headerlink" title="学习成绩很差的学生不但在将就，同时毫无上进心"></a>学习成绩很差的学生不但在将就，同时毫无上进心</h2><p>大学期末考试，大学生都懂，说难听点：有手就行，想要及格，只需要上课听一听，作业自己独立完成，期末来临的时候抓起来复习一下基本上就差不多了，但是还是有很多挂科的同学，每个人都是不同的，有的学科对于一些同学来讲大概有点难，这部分同学又没有努力学习的魄力，大概会有一些挂科，不过其实问题不是特别大，补考还是有机会过的，最可怕的是那些挂科门数特别多的同学，对此我并不打算大张旗鼓批判这部分同学，只能说，没有人管就真的放飞自我了，忘记了自己来大学是为了什么的，虽然大家来大学的目的都不同，但是基本上都有一个交集：拿到毕业证（有的人确实也不是想拿毕业证的，参考之前我看到过的一个新闻：一个学生因为偷拍女厕所被开除了，复读一年考上新的学校又因为偷拍女厕所被开除了，震撼我妈）挂科门数特别多纯是自己真的就没打算学了</p>
<h2 id="Never-settle"><a href="#Never-settle" class="headerlink" title="Never settle . . ."></a>Never settle . . .</h2><p>总之，在上面我大篇幅地批判了学习好的同学，他们并没有错，但是他们有错在在将就着学，将就着过，从来不为自己考虑自己想做什么，即便是在努力学习了依然像无头苍蝇一股脑的乱撞，这才是最为可悲的</p>
<p>恰逢高考刚刚过去，对于即将成为大一新生的同学们，我以我自己的经验与教训告诫：选择专业时尽量以专业为先，最好是选择自己感兴趣或者学起来轻松的专业，至于所谓的就业前景，实际上并不是那么重要，如果你真的喜欢这个学科，期望自己有所作为并且付诸实践的话，我不认为就业是很困难的事情</p>
<p>而对于已经在大学并且专业与我类似的同学们呢？对此因为我现在也仅仅是在探索，因为肯定无法给予帮助，我所知晓的大概就是跟我一样考研或者在校内通过一些社团，比赛等寻求出路</p>
<p>总之，好不容易到了大学，有了一次真真正正自己选择学习内容学习目标的时候，不要将就，不要妥协，不要被自己所谓的努力而感动，选择一条自己想走的路吧！即便路的那端深不可测，但总会有点点星光指引你前行！</p>
<hr>
<p><i class="fa fa-info-circle" aria-hidden="true"></i>    以上的内容仅为个人主观认识，难免会有错误或者你不认同的内容，如果你对我的所思所写无可置信，欢迎来<del>对线</del>辩论，另外因为写的比较急大概也没有太多时间梳理逻辑，逻辑上或许偶有错误，欢迎指正</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>奇思妙想</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>51单片机开发例程-3</title>
    <url>/p/904410e9.html</url>
    <content><![CDATA[<p>在这一章的内容中，将会学习到另一个运用非常广泛的元器件：数码管，数码管常用来表示16进制及以内的数字，因此可以显示我们要输入单片机的数字以及单片机输出的数字，在计算器，电子时钟以及一些可以调节简单参数的机械中都有数码管的广泛运用，因此熟练掌握数码管的使用是单片机学习过程中必不可少的</p>
<a id="more"></a>

<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>1.使用<code>STC89C52</code>的普中51-单核-A2单片机（本文以该单片机为样本）</li>
<li>2.能够正常下载驱动以及Keil等开发软件的Windows10.0系统PC</li>
<li>3.一根micro USB to USB A数据线</li>
</ul>
<h1 id="数码管显示数字"><a href="#数码管显示数字" class="headerlink" title="数码管显示数字"></a>数码管显示数字</h1><h2 id="数码管原理"><a href="#数码管原理" class="headerlink" title="数码管原理"></a>数码管原理</h2><p>在我们的单片机上有两个型号标注为<code>3461AS-1</code>的数码管，每个数码管都可以显示4位数字，单片机通过将这两个数码管靠近摆放且联结在一起来将数码管能够同时显示的位数相加达到8位</p>
<blockquote>
<p><a href="https://baike.baidu.com/item/led%E6%95%B0%E7%A0%81%E7%AE%A1">led数码管</a>（LED Segment Displays）是由多个发光二极管封装在一起组成“8”字型的<a href="https://baike.baidu.com/item/%E5%99%A8%E4%BB%B6">器件</a>，引线已在内部连接完成，只需引出它们的各个笔划，公共电极。led数码管常用段数一般为7段有的另加一个小数点，还有一种是类似于3位“+1”型。位数有半位，1，2，3，4，5，6，8，10位等等，led数码管根据LED的接法不同分为共阴和共阳两类，了解LED的这些特性，对编程是很重要的，因为不同类型的数码管，除了它们的硬件电路有差异外，编程方法也是不同的。图2是共阴和共阳极数码管的内部电路，它们的发光原理是一样的，只是它们的电源极性不同而已。颜色有红，绿，蓝，黄等几种。led数码管广泛用于仪表，时钟，车站，家电等场合。选用时要注意产品尺寸颜色，功耗，亮度，波长等。</p>
<p>——引用自<a href="https://baike.baidu.com/item/%E6%95%B0%E7%A0%81%E7%AE%A1/9903965?fr=aladdin">百度百科</a></p>
</blockquote>
<p>在单片机中，数码管的接法为<strong>共阴型</strong>，也就是说，数码管LED的负极接在一起，靠控制LED的正极来点亮数码管，共阳数码管与上述相反，因此，我们只需要给连接到数码管的管脚以高电平即可点亮数码管，重点来了，如何控制第几个数码管亮起以及数码管内显示怎样的图形数字呢？</p>
<img src="/p/904410e9/SMG.png" class title="数码管">

<p>通过原理图我们可以看到，<code>P0</code>端口通过芯片<code>74HC245</code>连接到了数码管的一极，而<code>P0</code>端口的8位正好对应数码管1位内的8个LED灯，这8个LED灯分别由构成了数字“8”的7个LED灯以及右下角的1个表示小数点的LED灯组成，我们将这8个<code>I/O</code>口称之为数码管的<strong>段选</strong>，由段选控制单个数码管所要显示的数字符号</p>
<blockquote>
<p>观察原理图我们可以看出，在<code>74HC245</code>芯片中输入与输出一一对应，那为什么还要通过这个芯片来控制数码管呢？这是由于单片机核心起的作用是控制作用，其输出的电流电压很小，只能驱动单个LED这样电流电压较小的元件，不足以驱动一些功耗相对较大的电子元件，比如数码管，电机等</p>
</blockquote>
<h2 id="74HC138"><a href="#74HC138" class="headerlink" title="74HC138"></a>74HC138</h2><p>那又怎样选择要使得哪个数码管被点亮呢？如果将每一条线都直接接入单片机的管脚上，我们可以通过控制对应 <code>I/O</code>口输出的高低电平来控制第几个数码管被点亮，这就是数码管的<strong>位选</strong>，虽然这种方法看起来可行，但是这种方法太占用<code>I/O</code>口了，我们的单片机一共才只有40个<code>I/O</code>口，像上面那种方法的话就要占用16个，为了尽可能的节约<code>I/O</code>口并且让我们学习到两种不同的信号输入输出的方法，单片机上还引入了一个芯片：<code>74HC138译码器</code></p>
<img src="/p/904410e9/74HC138.png" class title="74HC138译码器">

<p>138译码器通过ABC3个输入来达到Y0-Y7这8个输出的效果，我们可以简单理解为将2进制信号输出为10进制信号，3位2进制数字正好可以表示8个数字，按二进制数字算：其中高电平代表0，低电平代表1，查阅芯片手册我们可以得知译码器的信号判断规则，举个例子：输入A1B1C1时，化为二进制0b000，因此Y0输出0，其他输出1；输入A1B0C1时，化为二进制0b010，因此Y2输出0，其他输出1；输入A1B0C0时，化为二进制0b011，因此Y6输出0，其他输出1</p>
<img src="/p/904410e9/e61190ef76c6a7eff649c979fdfaaf51f3de6605.png" class title="译码器功能表">

<h2 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h2><p>知道了通过<strong>段选</strong>和<strong>位选</strong>来控制数码管显示什么显示哪一位，我们就可以开始编写程序了，按照正常思维逻辑，我们要先知道要选哪一位，再考虑显示什么，因此我们的程序从位选开</p>
<p>但是在开始前我们需要注意一个问题，数码管其实就是LED灯按照一定形状排列组合而成，LED灯具有二极管的单向导通性，如何确定那一端为正那一端为负呢，在这一章的最开始我们提到过，这个单片机是使用的共阴的数码管模块，负极接在一起，通过数码管的原理图可以看到，每个数码管还分出了一条线，由于每个数码管从下方（位选）输入8条线，而只从上方（段选）输出1条线，又数码管是共阴的，我们可以得知图示上方（位选）的线为低电平，下方（段选）的线为高电平时数码管被点亮</p>
<blockquote>
<p><i class="fa fa-info-circle" aria-hidden="true"></i>    我们在第一节的内容中曾经讲过通过typedef重新定义变量类型，因为重新定义后的变量名更加简略且易读，因此从本章节开始使用这一内容，但是需要注意重新定义后变量的长度</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8; <span class="comment">//代表8位正数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16; <span class="comment">//代表16位正数</span></span><br><span class="line">sbit SLA = P2^<span class="number">2</span>;</span><br><span class="line">sbit SLB = P2^<span class="number">3</span>;</span><br><span class="line">sbit SLC = P2^<span class="number">4</span>; <span class="comment">//定义译码管ABC三个输入</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  u8 LED; <span class="comment">//LED是要显示的数码管的位数</span></span><br><span class="line">  LED = <span class="number">3</span>; <span class="comment">//让从左到右第3个数码管亮起</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">switch</span>(LED)&#123;</span><br><span class="line">       <span class="keyword">case</span>(<span class="number">1</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//要显示第1位也就是要让如图LED8输出为0低电平，以下以此类推</span></span><br><span class="line">        <span class="keyword">case</span>(<span class="number">2</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">3</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">4</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">5</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">6</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">7</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">8</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行后我们发现第3个数码管的8个LED灯均亮起，说明程序正确无误，那么我们就要进行下一个环节，段码的选择</p>
<p>仔细观察图纸我们可以发现，段选对应的8个引脚在图上分别作了a,b,c,d,,e,f,g,dp的标注，同时在单个数码管的每个LED上也作了对应的标注，意思就是如果标注a的管脚输出了低电平就可以使得a被点亮，因此我们宏定义整个<code>P0</code>端口，通过16进制的方法对每个数字一一进行表示</p>
<p>为了快速读取<code>I/O</code>口与LED代号的关系，我们可以读图将其写出来</p>
<table>
<thead>
<tr>
<th>P0^0</th>
<th>P0^1</th>
<th>P0^2</th>
<th>P0^3</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>b</td>
<td>c</td>
<td>d</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>P0^4</th>
<th>P0^5</th>
<th>P0^6</th>
<th>P0^7</th>
</tr>
</thead>
<tbody><tr>
<td>e</td>
<td>f</td>
<td>g</td>
<td>dp</td>
</tr>
</tbody></table>
<p>以1为例子，要让数码管显示的数字为1，那么也就是说代号为b和c的LED灯输出高电平，也就是<code>P0^1``P0^2</code>输出高电平，那么<code>P0</code>端口就为<code>0b00000110</code>，换算为编译器能够使用的16进制就为：<code>0x06</code></p>
<p>以2为例子，要让数码管显示的数字为2，那么也就是说代号为a,b,g,e,d的LED灯输出高电平，也就是<code>P0^0``P0^1``P0^6``P0^4``P0^3</code>输出高电平，那么<code>P0</code>端口就为<code>0b01011011</code>，换算为编译器能够使用的16进制就为：<code>0x5b</code></p>
<p>其他的数字这里也就不单独推算了，最终要使得显示16进制数字那么也就一共有16个，这么多难以记忆的16进制数字如何简单快捷的调用呢，我们可以将其储存在数组中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u8 code SMG[]=&#123;</span><br><span class="line">  <span class="comment">/*我们编写的程序都是在单片机的RAM中运行的</span></span><br><span class="line"><span class="comment">  如果在数组变量类型后加code,那么可以让数组中存储的数据存储在ROM中*/</span></span><br><span class="line">  <span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line">  <span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line">  <span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>将上述数组并入之前写好的程序中并对需要的端口进行宏定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8; <span class="comment">//代表8位正数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16; <span class="comment">//代表16位正数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_DIG P0 <span class="comment">//宏定义数码管端口</span></span></span><br><span class="line">sbit SLA = P2^<span class="number">2</span>;</span><br><span class="line">sbit SLB = P2^<span class="number">3</span>;</span><br><span class="line">sbit SLC = P2^<span class="number">4</span>; <span class="comment">//定义译码管ABC三个输入</span></span><br><span class="line">u8 code SMG[]=&#123; <span class="comment">//在ROM中存储数码管段码的数组</span></span><br><span class="line">  <span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line">  <span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line">  <span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  u8 LED; <span class="comment">//LED是要显示的数码管的位数</span></span><br><span class="line">  LED = <span class="number">3</span>; <span class="comment">//让从左到右第3个数码管亮起</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">switch</span>(LED)&#123;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">1</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//要显示第1位也就是要让如图LED8输出为0低电平，以下以此类推</span></span><br><span class="line">        <span class="keyword">case</span>(<span class="number">2</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">3</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">4</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">5</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">6</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">7</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">8</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    GPIO_DIG = SMG[<span class="number">5</span>]; <span class="comment">//数码管显示数字5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行，第3个数码管上显示出了数字5，说明程序正确</p>
<h1 id="动态数码管显示数字"><a href="#动态数码管显示数字" class="headerlink" title="动态数码管显示数字"></a>动态数码管显示数字</h1><h2 id="动态显示原理"><a href="#动态显示原理" class="headerlink" title="动态显示原理"></a>动态显示原理</h2><p>完成刚刚的程序后，那么问题又来了，在我们平常看到的数码管中，都可以多个数字同时显示，并且数码管设计这么多位也不可能只显示一位，如何让数码管一次性显示多个数字呢？这里就要用到动态扫描显示的原理</p>
<p>所谓动态扫描显示即轮流向各位数码管送出字形码（段码）和相应的位码，利用发光管的余辉和人眼的视觉暂留作用，使人的感觉好像各位数码管同时都在显示，就好像我们平时使用的显示器每秒刷新60次，120次一样</p>
<h2 id="编写程序-1"><a href="#编写程序-1" class="headerlink" title="编写程序"></a>编写程序</h2><p>实现动态刷新，就需要一个循环函数将数码管一次次地执行，因为数码管有8位，所以我们循环的最小单位是8，也就是说我们刷新一次屏幕，循环函数要让上面的程序执行8次，因此我们采用for循环，而每次扫描后，我们需要清除段码，否则段码可能会被带入下一次循环中，因为下面示例的程序是要让第几个数码管显示数字几，那么直接把段码选择放到位码前面不就好了吗，实际上在运行过程中还是会产生影响，你可以试着运行一下，显示出来的数字是乱的，并且每一位实际显示的数字是<em>应该显示的数字</em>和<em>应该显示的数字+1</em>的叠加，至于为什么，在撰写这篇文章的时候我也不太清楚原因，大概是与寄存器有关，因此此处不做解答，如果有了解这一方面的同学可以给我发邮件或者电报一起讨论</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8; <span class="comment">//代表8位正数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16; <span class="comment">//代表16位正数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_DIG P0 <span class="comment">//宏定义数码管端口</span></span></span><br><span class="line">sbit SLA = P2^<span class="number">2</span>;</span><br><span class="line">sbit SLB = P2^<span class="number">3</span>;</span><br><span class="line">sbit SLC = P2^<span class="number">4</span>; <span class="comment">//定义译码管ABC三个输入</span></span><br><span class="line">u8 code SMG[]=&#123; <span class="comment">//在ROM中存储数码管段码的数组</span></span><br><span class="line">  <span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line">  <span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line">  <span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  u8 LED; <span class="comment">//LED是要显示的数码管的位数</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span>(LED = <span class="number">8</span>; LED &gt; <span class="number">0</span>; LED--)&#123; <span class="comment">//每次扫描循环执行8次，从右向左刷新，如果for循环内改为“LED = 1;LED &lt; 8;LED ++”为从左向右刷新，此处两种方法是等效的</span></span><br><span class="line">    <span class="keyword">switch</span>(LED)&#123;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">1</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//要显示第1位也就是要让如图LED8输出为0低电平，以下以此类推</span></span><br><span class="line">        <span class="keyword">case</span>(<span class="number">2</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">3</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">4</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">5</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">6</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">7</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">8</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    GPIO_DIG = SMG[LED]; <span class="comment">//第几个数码管显示数字几</span></span><br><span class="line">    GPIO_DIG = <span class="number">0x00</span>; <span class="comment">//消隐</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上述程序后我们发现，虽然数码管显示了我们需要的数字，但是亮度较低，这是因为单位时间内显示的时间太少，之前我们讲到过单片机运行每条指令都需要时间，我们可以看到在段选之后立马就是消隐，因此在扫描一次运行了好几条代码的时间中，真正显示的时间只有一条代码显示的时间，假设一共运行了10条代码，那么显示时间就是1/10，为了让数码管单位时间内显示的时间增加，我们就需要用到我们的老朋友：延时函数，我们进行延时100条代码的时间，那么显示时间就变成了101/110，亮度就会增加，但是随之刷新率也会降低，因此我们不但要高亮度也要兼顾刷新率</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8; <span class="comment">//代表8位正数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16; <span class="comment">//代表16位正数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_DIG P0 <span class="comment">//宏定义数码管端口</span></span></span><br><span class="line">sbit SLA = P2^<span class="number">2</span>;</span><br><span class="line">sbit SLB = P2^<span class="number">3</span>;</span><br><span class="line">sbit SLC = P2^<span class="number">4</span>; <span class="comment">//定义译码管ABC三个输入</span></span><br><span class="line">u8 code SMG[]=&#123; <span class="comment">//在ROM中存储数码管段码的数组</span></span><br><span class="line">  <span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line">  <span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line">  <span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>; <span class="comment">//延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  u8 LED; <span class="comment">//LED是要显示的数码管的位数</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span>(LED = <span class="number">8</span>; LED &gt; <span class="number">0</span>; LED--)&#123; <span class="comment">//每次扫描循环执行8次，从右向左刷新，如果for循环内改为“LED = 1;LED &lt; 8;LED ++”为从左向右刷新，此处两种方法是等效的</span></span><br><span class="line">    <span class="keyword">switch</span>(LED)&#123;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">1</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//要显示第1位也就是要让如图LED8输出为0低电平，以下以此类推</span></span><br><span class="line">        <span class="keyword">case</span>(<span class="number">2</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">3</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">4</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">5</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">6</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">7</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">8</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    GPIO_DIG = SMG[LED]; <span class="comment">//第几个数码管显示数字几</span></span><br><span class="line">    delay(<span class="number">100</span>); <span class="comment">//间隔一段时间扫描</span></span><br><span class="line">    GPIO_DIG = <span class="number">0x00</span>; <span class="comment">//消隐</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>&#123; <span class="comment">//延时函数</span></span><br><span class="line">  <span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样每隔一小段时间扫描一次，就能显著提升数码管亮度，但是为什么延时100呢，因为如果设置时间过短，亮度还是相对较低，如果设置较长，人眼就能看到明显闪烁，设置为200时依然能够依稀感知到闪烁，因此100在这个程序里是一个相对较好的延时时长，你可以尝试使用较高的延时时长或者在100延时下使用手机的慢动作模式以每秒240fps以上的录制帧率录制都可以看到数码管在从左向右依次刷新，这便是数码管的动态扫描显示</p>
<h1 id="动态数码管的显示函数"><a href="#动态数码管的显示函数" class="headerlink" title="动态数码管的显示函数"></a>动态数码管的显示函数</h1><p>因为数码管显示是单片机开发过程中的一个重要部分，我们不妨将其写成函数方便日后使用，由于这个函数的执行就已经在数码管上实现了数据的输出，所以我们不需要在函数中返回数值，但是我们要输入一个数字来让数码管显示这个数字，又因为数字需要在数码管上一位一位的显示，因此我们还要将数字的每一位分开来，并且数字不单单是正数，还有负数，小数，以及超出数码管显示范围的数字，我们要对这些数字一一进行处理，但是为了简单易懂，我们从正数开始</p>
<h2 id="动态数码管显示正整数"><a href="#动态数码管显示正整数" class="headerlink" title="动态数码管显示正整数"></a>动态数码管显示正整数</h2><p>按照我们生活中其他数码管设备的显示方式，不满8位的数字应该向右对齐，因此，应当把数码管扫描从左向右扫描改为从右向左扫描，接下来要在段码存储的数组<code>SMG</code>中加入空白项，使得当前数码管不显示任何内容，再将之前的代码mian函数中除了<code>while</code>循环的部分都移到了新函数<code>DigDisplay</code>中</p>
<p>对于函数<code>DigDisplay</code>我们要对其输入一个数字，使其显示我们输入的数字，我们编写此函数的目的是输出8位及以内的正整数，因此存储的数字也需要达到8个数字的长度，但是单片机核心是8bit核心，跟我们之前学习电脑时使用的64bit，32bit核心不同，8bit的数据类型所占字节数也与之前不一样</p>
<table>
<thead>
<tr>
<th>int</th>
<th>long</th>
<th>float</th>
<th>double</th>
</tr>
</thead>
<tbody><tr>
<td>2byte</td>
<td>4byte</td>
<td>4byte</td>
<td>8byte</td>
</tr>
<tr>
<td>-32768～32767</td>
<td>-2.1E+9～2.1E+9</td>
<td>-3.4E+38～3.4E+38</td>
<td>-1.8E+308～1.8E+308</td>
</tr>
</tbody></table>
<p>根据上述在8bit核心下数据类型所占字节的表格，我们可以得知要让数码管显示8位数字，需要选择4字节以上的数据类型，此处使用正整数，因此选用long</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8; <span class="comment">//代表8位正数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16; <span class="comment">//代表16位正数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_DIG P0 <span class="comment">//宏定义数码管端口</span></span></span><br><span class="line">sbit SLA = P2^<span class="number">2</span>;</span><br><span class="line">sbit SLB = P2^<span class="number">3</span>;</span><br><span class="line">sbit SLC = P2^<span class="number">4</span>; <span class="comment">//定义译码管ABC三个输入</span></span><br><span class="line">u8 code SMG[]=&#123; <span class="comment">//在ROM中存储数码管段码的数组</span></span><br><span class="line">  <span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line">  <span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line">  <span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>; <span class="comment">//延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>; <span class="comment">//动态数码管显示函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="comment">//主函数</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    DigDisplay(<span class="number">6</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>&#123; <span class="comment">//延时函数</span></span><br><span class="line">  <span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>&#123; <span class="comment">//动态数码管显示函数</span></span><br><span class="line">  <span class="keyword">char</span> LED; <span class="comment">//LED是要显示的数码管的位数</span></span><br><span class="line">  <span class="keyword">for</span>(LED = <span class="number">8</span>; LED &gt; <span class="number">0</span>; LED--)&#123; <span class="comment">//每次扫描循环执行8次，从右向左刷新，如果for循环内改为“LED = 1;LED &lt; 8;LED ++”为从左向右刷新，此处选用从右向左刷新</span></span><br><span class="line">    <span class="keyword">switch</span>(LED)&#123;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">1</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//要显示第1位也就是要让如图LED8输出为0低电平，以下以此类推</span></span><br><span class="line">        <span class="keyword">case</span>(<span class="number">2</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">3</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">4</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">5</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">6</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">7</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">8</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    GPIO_DIG = SMG[LED]; <span class="comment">//第几个数码管显示数字几</span></span><br><span class="line">    delay(<span class="number">100</span>); <span class="comment">//间隔一段时间扫描</span></span><br><span class="line">    GPIO_DIG = <span class="number">0x00</span>; <span class="comment">//消隐</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述程序，数码管所显示的还是之前的内容，如何向函数输入一个正整数使数码管显示我们输入的数字呢，我们首先要将输入的数字进行处理，将其每一位分开，在之前C语言学习中我们可以用取余和除法很容易实现这个内容，因为变量LED在进入循环之前用不到，我们可以利用LED来求得输入的数字长度来减少定义一个新变量，但是我们还需要考虑不足8位以及超出8位的问题，那么我们首先对数字的长度进行判断，如果数字太长就报警</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sbit beep = P1^<span class="number">5</span>; <span class="comment">//引入蜂鸣器表示输入数字错误</span></span><br><span class="line"><span class="keyword">if</span>(num &gt; <span class="number">99999999</span>)&#123; <span class="comment">//数字超长则触发蜂鸣器警报，程序在蜂鸣器中循环</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    beep = ~beep;</span><br><span class="line">    delay(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8; <span class="comment">//代表8位正数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16; <span class="comment">//代表16位正数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_DIG P0 <span class="comment">//宏定义数码管端口</span></span></span><br><span class="line">sbit beep = P1^<span class="number">5</span>; <span class="comment">//定义制蜂鸣器</span></span><br><span class="line">sbit SLA = P2^<span class="number">2</span>;</span><br><span class="line">sbit SLB = P2^<span class="number">3</span>;</span><br><span class="line">sbit SLC = P2^<span class="number">4</span>; <span class="comment">//定义译码管ABC三个输入</span></span><br><span class="line">u8 code SMG[]=&#123; <span class="comment">//在ROM中存储数码管段码的数组</span></span><br><span class="line">  <span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line">  <span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line">  <span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>; <span class="comment">//延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>; <span class="comment">//动态数码管显示函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="comment">//主函数</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    DigDisplay(<span class="number">114514</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>&#123; <span class="comment">//延时函数</span></span><br><span class="line">  <span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>&#123; <span class="comment">//动态数码管显示函数</span></span><br><span class="line">  <span class="keyword">long</span> LED = <span class="number">10</span>; <span class="comment">//LED是要显示的数码管的位数，同时作为除数求num长度</span></span><br><span class="line">  u8 numlong = <span class="number">1</span>; <span class="comment">//数字长度</span></span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">99999999</span>)&#123; <span class="comment">//数字超长则触发蜂鸣器警报</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;beep = ~beep;delay(<span class="number">100</span>);&#125;&#125;</span><br><span class="line">  <span class="keyword">while</span>(num / LED)&#123; <span class="comment">//求数字长度</span></span><br><span class="line">    LED *= <span class="number">10</span>;</span><br><span class="line">    numlong ++;&#125; </span><br><span class="line">  <span class="keyword">for</span>(LED = <span class="number">8</span>; LED &gt; <span class="number">8</span> - numlong; LED--)&#123; <span class="comment">//每次扫描循环执行8次</span></span><br><span class="line">    <span class="comment">//为了让高于输入数字位数的数码管不显示，因此我们要将数字长度带入循环，使得刷新完输入数字所在位数即停止，那么未扫描到的数码管就会不显示数字</span></span><br><span class="line">    <span class="keyword">switch</span>(LED)&#123;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">1</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//要显示第1位也就是要让如图LED8输出为0低电平，以下以此类推</span></span><br><span class="line">        <span class="keyword">case</span>(<span class="number">2</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">3</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">4</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">5</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">6</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">7</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">8</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    GPIO_DIG = SMG[num % <span class="number">10</span>]; <span class="comment">//第几个数码管显示数字几</span></span><br><span class="line">    num /= <span class="number">10</span>; <span class="comment">//数字减位</span></span><br><span class="line">    delay(<span class="number">100</span>); <span class="comment">//间隔一段时间扫描</span></span><br><span class="line">    GPIO_DIG = <span class="number">0x00</span>; <span class="comment">//消隐</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译执行上述代码，我们可以看到数码管上显示了我们输入的数字：114514，因此该程序实现了我们的需求，上述函数主要是添加了对输入数字的长度检测以及对输入数字的逐位分离，这些内容都非常简单，但是如何整合进函数中需要一定思考，仔细研究上述代码，待研究透彻后即可进入下一步，其实这一步是该函数最为复杂的一步，之后的负数以及小数都是对原函数稍加修改，大同小异</p>


<h2 id="动态数码管显示负数"><a href="#动态数码管显示负数" class="headerlink" title="动态数码管显示负数"></a>动态数码管显示负数</h2><p>我们实现了正数的显示，那么负数只需要判断是否为负数然后显示的时候加一个负号即可，并且由于负号的存在，数码管显示的位数就只有7位了，这一点需要注意</p>
<p>那么开始添加代码，首先先判断输入的数字是否为负数，如果是那么输出它的绝对值，并且将位数控制在7位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8; <span class="comment">//代表8位正数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16; <span class="comment">//代表16位正数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_DIG P0 <span class="comment">//宏定义数码管端口</span></span></span><br><span class="line">sbit beep = P1^<span class="number">5</span>; <span class="comment">//定义制蜂鸣器</span></span><br><span class="line">sbit SLA = P2^<span class="number">2</span>;</span><br><span class="line">sbit SLB = P2^<span class="number">3</span>;</span><br><span class="line">sbit SLC = P2^<span class="number">4</span>; <span class="comment">//定义译码管ABC三个输入</span></span><br><span class="line">u8 code SMG[]=&#123; <span class="comment">//在ROM中存储数码管段码的数组</span></span><br><span class="line">  <span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line">  <span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line">  <span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>; <span class="comment">//延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>; <span class="comment">//动态数码管显示函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="comment">//主函数</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    DigDisplay(<span class="number">-114514</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>&#123; <span class="comment">//延时函数</span></span><br><span class="line">  <span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>&#123; <span class="comment">//动态数码管显示函数</span></span><br><span class="line">  <span class="keyword">long</span> LED = <span class="number">10</span>; <span class="comment">//LED是要显示的数码管的位数，同时作为除数求num长度</span></span><br><span class="line">  u8 numlong = <span class="number">1</span>; <span class="comment">//数字长度</span></span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">99999999</span> || num &lt; <span class="number">-999999</span>)&#123; <span class="comment">//数字超长则触发蜂鸣器警报</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;beep = ~beep;delay(<span class="number">100</span>);&#125;&#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(num &lt; <span class="number">0</span>)&#123;num *= <span class="number">-1</span>;&#125; <span class="comment">//如果数字小于0则取绝对值</span></span><br><span class="line">  <span class="keyword">while</span>(num / LED)&#123; <span class="comment">//求数字长度</span></span><br><span class="line">    LED *= <span class="number">10</span>;</span><br><span class="line">    numlong ++;&#125; </span><br><span class="line">  <span class="keyword">for</span>(LED = <span class="number">8</span>; LED &gt; <span class="number">8</span> - numlong; LED--)&#123; <span class="comment">//每次扫描循环执行8次</span></span><br><span class="line">    <span class="comment">//为了让高于输入数字位数的数码管不显示，因此我们要将数字长度带入循环，使得刷新完输入数字所在位数即停止，那么未扫描到的数码管就会不显示数字</span></span><br><span class="line">    <span class="keyword">switch</span>(LED)&#123;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">1</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//要显示第1位也就是要让如图LED8输出为0低电平，以下以此类推</span></span><br><span class="line">        <span class="keyword">case</span>(<span class="number">2</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">3</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">4</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">5</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">6</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">7</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">8</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    GPIO_DIG = SMG[num % <span class="number">10</span>]; <span class="comment">//第几个数码管显示数字几</span></span><br><span class="line">    num /= <span class="number">10</span>; <span class="comment">//数字减位</span></span><br><span class="line">    delay(<span class="number">100</span>); <span class="comment">//间隔一段时间扫描</span></span><br><span class="line">    GPIO_DIG = <span class="number">0x00</span>; <span class="comment">//消隐</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们要将判断出的正负以变量的形式代入扫描，使负数扫描的次数比数字的长度多一次，并且在多的那一次中加入负号，负号的段码我们保存在之前的数组中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8; <span class="comment">//代表8位正数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16; <span class="comment">//代表16位正数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_DIG P0 <span class="comment">//宏定义数码管端口</span></span></span><br><span class="line">sbit beep = P1^<span class="number">5</span>; <span class="comment">//定义制蜂鸣器</span></span><br><span class="line">sbit SLA = P2^<span class="number">2</span>;</span><br><span class="line">sbit SLB = P2^<span class="number">3</span>;</span><br><span class="line">sbit SLC = P2^<span class="number">4</span>; <span class="comment">//定义译码管ABC三个输入</span></span><br><span class="line">u8 code SMG[]=&#123; <span class="comment">//在ROM中存储数码管段码的数组</span></span><br><span class="line">  <span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line">  <span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line">  <span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,<span class="number">0x40</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>; <span class="comment">//延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>; <span class="comment">//动态数码管显示函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="comment">//主函数</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    DigDisplay(<span class="number">-114514</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>&#123; <span class="comment">//延时函数</span></span><br><span class="line">  <span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>&#123; <span class="comment">//动态数码管显示函数</span></span><br><span class="line">  <span class="keyword">long</span> LED = <span class="number">10</span>; <span class="comment">//LED是要显示的数码管的位数，同时作为除数求num长度</span></span><br><span class="line">  u8 numlong = <span class="number">1</span>; <span class="comment">//数字长度</span></span><br><span class="line">  u8 PosNeg = <span class="number">1</span>; <span class="comment">//该变量为0时代表数字为负数</span></span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">99999999</span> || num &lt; <span class="number">-999999</span>)&#123;<span class="keyword">while</span>(<span class="number">1</span>)&#123;beep = ~beep;delay(<span class="number">100</span>);&#125;&#125;  <span class="comment">//数字超长则触发蜂鸣器警报</span></span><br><span class="line">  <span class="keyword">if</span>(num &lt; <span class="number">0</span>)&#123;num *= <span class="number">-1</span>;PosNeg = <span class="number">0</span>;numlong ++;&#125; <span class="comment">//如果数字小于0则取绝对值，将数字为负数的信息传入扫描循环，并且多扫描一次以显示负号</span></span><br><span class="line">  <span class="keyword">while</span>(num / LED)&#123; <span class="comment">//求数字长度</span></span><br><span class="line">    LED *= <span class="number">10</span>;</span><br><span class="line">    numlong ++;&#125; </span><br><span class="line">  <span class="keyword">for</span>(LED = <span class="number">8</span>; LED &gt; <span class="number">8</span> - numlong; LED--)&#123; <span class="comment">//每次扫描循环执行8次</span></span><br><span class="line">    <span class="comment">//为了让高于输入数字位数的数码管不显示，因此我们要将数字长度带入循环，使得刷新完输入数字所在位数即停止，那么未扫描到的数码管就会不显示数字</span></span><br><span class="line">    <span class="keyword">switch</span>(LED)&#123;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">1</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//要显示第1位也就是要让如图LED8输出为0低电平，以下以此类推</span></span><br><span class="line">        <span class="keyword">case</span>(<span class="number">2</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">3</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">4</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">5</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">6</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">7</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">8</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(PosNeg == <span class="number">0</span> &amp;&amp; LED == <span class="number">1</span> + numlong)&#123;GPIO_DIG = SMG[<span class="number">16</span>];&#125; <span class="comment">//负数最后一位显示负号</span></span><br><span class="line">    <span class="keyword">else</span>&#123;GPIO_DIG = SMG[num % <span class="number">10</span>];&#125; <span class="comment">//第几个数码管显示数字几</span></span><br><span class="line">    num /= <span class="number">10</span>; <span class="comment">//数字减位</span></span><br><span class="line">    delay(<span class="number">100</span>); <span class="comment">//间隔一段时间扫描</span></span><br><span class="line">    GPIO_DIG = <span class="number">0x00</span>; <span class="comment">//消隐</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态数码管显示小数"><a href="#动态数码管显示小数" class="headerlink" title="动态数码管显示小数"></a>动态数码管显示小数</h2><p>过了很久我才回来写这一部分，更新这一部分的时候已经是五一期间了，举例我最早创建这个文档已经过去三个月了，因为期间大部分时间我在摸鱼没怎么更新，并且数码管显示小数暂时没有实际应用到以及显示小数会遇到各种各样的问题，比如：小数点后要精确到多少位，小数点怎么放，以及小数超过显示位数（比如0.000000008）等等，这些问题挺杂的，在当时我要一个个解决起来并不容易，再加上用的不多，就告一段落了，现在回来填坑吧</p>
<p>具体写的步骤呢？我不太打算写的很详细了，因为如果你是初学者，学到第三节，除非你有较好的C语言功底，不然你是写不出来这玩意的，如果你想要深入了解学习，那么你最好自己写一遍，我都能写出来你凭什么写不出来？并且我写的并不是最优解，运行效率以及内存占用上可能有点不是很好，之后我可能会优化的，不过那是之后的事情了哈哈</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8; <span class="comment">//代表8位正数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16; <span class="comment">//代表16位正数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_DIG P0 <span class="comment">//宏定义数码管端口</span></span></span><br><span class="line">sbit beep = P1^<span class="number">5</span>; <span class="comment">//定义制蜂鸣器</span></span><br><span class="line">sbit SLA = P2^<span class="number">2</span>;</span><br><span class="line">sbit SLB = P2^<span class="number">3</span>;</span><br><span class="line">sbit SLC = P2^<span class="number">4</span>; <span class="comment">//定义译码管ABC三个输入</span></span><br><span class="line">u8 code SMG[]=&#123; <span class="comment">//在ROM中存储数码管段码的数组</span></span><br><span class="line">  <span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line">  <span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line">  <span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,</span><br><span class="line">  <span class="number">0x40</span>,<span class="number">0x80</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>; <span class="comment">//延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>; <span class="comment">//动态数码管显示函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="comment">//主函数</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    DigDisplay(<span class="number">-114514</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>&#123; <span class="comment">//延时函数</span></span><br><span class="line">  <span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>&#123; <span class="comment">//动态数码管显示函数</span></span><br><span class="line">  <span class="keyword">long</span> LED = <span class="number">10</span>; <span class="comment">//LED是要显示的数码管的位数，同时作为除数求num长度</span></span><br><span class="line">  u8 numlong = <span class="number">1</span>; <span class="comment">//数字长度</span></span><br><span class="line">  u8 PosNeg = <span class="number">1</span>; <span class="comment">//该变量为0时代表数字为负数</span></span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">99999999</span> || num &lt; <span class="number">-999999</span>)&#123;<span class="keyword">while</span>(<span class="number">1</span>)&#123;beep = ~beep;delay(<span class="number">100</span>);&#125;&#125;  <span class="comment">//数字超长则触发蜂鸣器警报</span></span><br><span class="line">  <span class="keyword">if</span>(num &lt; <span class="number">0</span>)&#123;num *= <span class="number">-1</span>;PosNeg = <span class="number">0</span>;numlong ++;&#125; <span class="comment">//如果数字小于0则取绝对值，将数字为负数的信息传入扫描循环，并且多扫描一次以显示负号</span></span><br><span class="line">  <span class="keyword">while</span>(num / LED)&#123; <span class="comment">//求数字长度</span></span><br><span class="line">    LED *= <span class="number">10</span>;</span><br><span class="line">    numlong ++;&#125; </span><br><span class="line">  <span class="keyword">for</span>(LED = <span class="number">8</span>; LED &gt; <span class="number">8</span> - numlong; LED--)&#123; <span class="comment">//每次扫描循环执行8次</span></span><br><span class="line">    <span class="comment">//为了让高于输入数字位数的数码管不显示，因此我们要将数字长度带入循环，使得刷新完输入数字所在位数即停止，那么未扫描到的数码管就会不显示数字</span></span><br><span class="line">    <span class="keyword">switch</span>(LED)&#123;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">1</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//要显示第1位也就是要让如图LED8输出为0低电平，以下以此类推</span></span><br><span class="line">        <span class="keyword">case</span>(<span class="number">2</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">3</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">4</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">5</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">6</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">7</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">8</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(PosNeg == <span class="number">0</span> &amp;&amp; LED == <span class="number">1</span> + numlong)&#123;GPIO_DIG = SMG[<span class="number">16</span>];&#125; <span class="comment">//负数最后一位显示负号</span></span><br><span class="line">    <span class="keyword">else</span>&#123;GPIO_DIG = SMG[num % <span class="number">10</span>];&#125; <span class="comment">//第几个数码管显示数字几</span></span><br><span class="line">    num /= <span class="number">10</span>; <span class="comment">//数字减位</span></span><br><span class="line">    delay(<span class="number">100</span>); <span class="comment">//间隔一段时间扫描</span></span><br><span class="line">    GPIO_DIG = <span class="number">0x00</span>; <span class="comment">//消隐</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<p><i class="fa fa-info-circle" aria-hidden="true"></i>   更新于2020/2/23</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>单片机</tag>
        <tag>STC89C52</tag>
        <tag>74HC138</tag>
        <tag>74HC245</tag>
      </tags>
  </entry>
  <entry>
    <title>51单片机开发例程-5</title>
    <url>/p/3359.html</url>
    <content><![CDATA[<p>在这一章我们又要学习到一种重要的信息输出方法：8x8LED点阵模块，之前学习到的数码管虽然用处广泛，但是由于其LED数量较少且有固定的摆放方式，所以可以显示的信息非常有限，只能显示数字，部分字母还有一些极其简单的符号，如果要显示复杂的图形信息，就需要用到点阵模块</p>
<a id="more"></a>

<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>1.使用<code>STC89C52</code>的普中51-单核-A2单片机（本文以该单片机为样本）</li>
<li>2.能够正常下载驱动以及Keil等开发软件的Windows10.0系统PC</li>
<li>3.一根micro USB to USB A数据线</li>
<li>4.用跳线帽将<code>J24</code>处的<code>GND</code>与<code>OE</code>引脚进行短接</li>
</ul>
<blockquote>
<p>跳线帽：</p>
<p>跳线帽是一个可活动的部件，外层是绝缘塑料，内部是导电材料，可以插在跳线针上，将两根跳线针进行短接。通过跳线帽连接不同的跳线针，可以改变主板的电路，从而达到不同的使用目的</p>
</blockquote>
<img src="/p/3359/tiaoxianmao.png" class title="跳线帽">

<h1 id="点亮LED点阵的一个点"><a href="#点亮LED点阵的一个点" class="headerlink" title="点亮LED点阵的一个点"></a>点亮LED点阵的一个点</h1><h2 id="LED点阵原理"><a href="#LED点阵原理" class="headerlink" title="LED点阵原理"></a>LED点阵原理</h2><p>LED点阵由于增加了LED的数量并且所有LED都按同一间距进行矩形排列，因此不但可以显示数码管可以显示的数字和字母，还可以显示一些较为简单的图形和汉字，大大增加了数据输出的形式和内容</p>
<img src="/p/3359/leddianzhen.png" class title="LED点阵原理图">

<p>通过观察原理图我们我们可以得知想要点亮一个LED灯只需要对二极管阳极输入高电平，对阴极输入低电平就可以点亮二极管，跟之前点亮LED模块一样（实际上所有LED都是这个原理），但是如果要同时点亮多个二级管呢？8x8LED点阵并没有采用数码管那样共阴共阳的解法，而是引出了8+8个管脚，其实，虽然看起来原理并不相同，但是我们所讲的数码管并不是单个工作的而是多个并联在一起的，因此实际上也原理差不多。LED的8+8管脚分别对应之前数码管的段选和位选，因此采用同样的动态扫描原理即可实现多个LED灯同时点亮</p>
<h2 id="74HC595"><a href="#74HC595" class="headerlink" title="74HC595"></a>74HC595</h2><p>LED点阵需要的<code>I/O</code>口比之前的数码管还要多，为了节省<code>I/O</code>口，我们同样需要用到一个可以扩展<code>I/O</code>口的芯片，在之前的数码管显示中我们使用了一个译码器来对单片机<code>I/O</code>口进行扩展，译码器可以实现3向输入8向输出，而在LED点阵中我们使用一个新的芯片来实现<code>I/O</code>口的扩展与对LED点阵的控制，我们在此使用<strong>位移缓存器</strong>：<code>74HC595</code></p>
<img src="/p/3359/595.png" class title="74HC595芯片原理图">

<blockquote>
<p>74HC595是一个8位串行输入、并行输出的位移缓存器：并行输出为三态输出。在SCK 的上升沿，串行数据由SDL输入到内部的8位位移缓存器，并由Q7’输出，而并行输出则是在LCK的上升沿将在8位位移缓存器的数据存入到8位并行输出缓存器。当串行数据输入端OE的控制信号为低使能时，并行输出端的输出值等于并行输出缓存器所存储的值。</p>
<p>——引用自<a href="https://baike.baidu.com/item/74HC595/9886491?fr=aladdin">百度百科</a></p>
</blockquote>
<p><strong><i class="fa fa-info-circle" aria-hidden="true"></i>  声明：</strong>我在学习的时候发现此部分的教学视频以及教学文档与实际资料并不匹配，并且实际开发板资料内容极其有限，所以导致没有数电模电相关知识的同学很难理解这一部分的内容，我通过分析示例程序代码，查看开发板实际原理图及资料中的文件，通过网络对相关内容搜索，咨询大佬等方式，大概也许可能了解了该芯片的基础使用方法，由于这一部分内容涉及到的东西较多，我本人<strong>能力有限</strong>所以我会以自己的理解<strong>尽可能简单直观的描述这个芯片的功能</strong></p>
<p>不同于之前原理较为简单的译码器，译码器通过3个输入来控制8个输出，3个输出管脚正好对应3位二进制，因此很容易就能得知怎样的输入对应怎样的输出，即便是理解能力不行或者压根没想理解的也可以通过芯片手册中对应管脚输入输出的表哥来找到自己需要的控制方法。位移缓存器实现了1个输入来控制8+1个输出，那么如此高效的扩展<code>I/O</code>口的方法是怎样实现的呢？</p>
<p>实际上，在本例程中使用到的单个595芯片是有3个输入的管脚的，但是这三个输入不同于译码器的三个输入，这三个管脚分别对应：11脚 RCK 存储寄存器 时钟引脚；12脚 SCK 移位寄存器 时钟引脚；14脚 DS 串行数据 输入引脚。我对以上词汇重要部分中间打了个空格，便于理解，那么我们按他的工作顺序讲起：</p>
<blockquote>
<p>14脚（DS）：串行数据输入引脚</p>
<p>这个引脚便是595芯片真正用来输入数据的引脚，之前我们的学习中可以得知<code>I/O</code>口用来传递的信息只有高低电平仅此而己，也就是对应二进制1和0，如果输出大于1的数据呢？假如我对单片机一个<code>I/O</code>口输出7，那么实际输出的就是这个数字二进制的第一位，也就是0b0111的第一位，也就是1，对应<code>I/O</code>口的高电平；输出6，其二进制是0b0110，取第一位0，对应<code>I/O</code>口的低电平</p>
<p>知道了上述的内容，我们得知<code>I/O</code>口可以输出一个数字二进制的一位，实现输出完整的数字也就是二进制的多个位，那么我们就需要用到595芯片内部的结构：寄存器</p>
</blockquote>
<blockquote>
<p>寄存器：顾名思义，就是将数据寄存在芯片中，从DS输入的数据将依次存储在寄存器中，原理有点像入栈，也就是先入后出，我这么说肯定是很抽象了，那么看图！要使得数据一位一位地存储在寄存器中，我们就要让二进制数字从左向右每一位都依次成为最右位（第一位），并且由于先入的数据会被存储在最后一位，我们要将数据最后一位移到第一位</p>
</blockquote>
<img src="/p/3359/dongtai.GIF" class title="动态示意图">

<blockquote>
<p>知道了硬件上的原理，那么从软件层面来看，以<code>0b11010111</code>我们要使用移位运算符先将最后一位移到第一位，即：<code>SER = dat &gt;&gt; 7;</code>也就是将<code>0b11010111</code>右移7位变为<code>0b00000001</code>，此时取的<code>SER</code>的最后一位就是原数据<code>dat</code>的第一位</p>
<p>然后按照从后往前的顺序，我们就该取倒数第二位，也就是将原数据左移一位<code>dat &lt;&lt; 1</code>，将<code>0b11010111</code>变为<code>0b10101110</code>，之后再取移位后的倒数第一位即可，以此类推，595寄存器最多寄存8位数字，因此我们只需要一个<code>for</code>循环将以上的代码循环8次即可</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*SER为实际向DS输入的数据，dat为想要向DS输入的原始数据*/</span></span><br><span class="line"><span class="keyword">for</span>(u8 a = <span class="number">0</span>; a &lt; <span class="number">8</span>; a++)&#123;</span><br><span class="line">  SER = dat &gt;&gt; <span class="number">7</span>; <span class="comment">//将最后一位移位变为第一位</span></span><br><span class="line">  dat &lt;&lt;= <span class="number">1</span>; <span class="comment">//从右向左依次移位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>12脚（SCK）移位寄存器时钟引脚：</p>
<p>我们知道了寄存器会一位一位地存储DS口输入的数据，那芯片又是怎么知道什么时候该从DS取数据呢？这个时候我们就需要通过SCK向芯片输入一个上升沿（从低电平变为高电平的过程）来告诉芯片该取数据了。首先，我们要向SCK脚输出高电平，以防止抖动导致的意外取值，之后向SCK输出低电平间隔一段时间后输出高电平让芯片知道该在此时取DS的值，那么问题又来了，我们为什么要在高低电平之间加入一段延时呢？这个延时又该是多少呢？</p>
<p>从SCK脚的名字“时钟引脚”可以知道，向这个引脚输入的高低电平的时间间隔相当于我们现实中的时钟，起一个时间参考作用，虽然你输入一个上升沿就可以告诉芯片该在什么时候取DS的值，但是芯片的工作频率也是有极限的，举个例子：我告诉你现在该完成数学作业，你知道了自己该完成数学作业，但是你完成的速度是有极限的，假如你一个小时才能完成，而我半个小时后告诉你现在要完成英语作业，那么就会出问题，因为你还没有完成手头的工作而新的工作就被分配下来了，但是如果我在两个小时后才告诉你现在要完成英语作业，那么就没问题，因为你一个小时就完成了，剩下的一个小时干嘛？歇着呗！通过读芯片手册我们可以知道该移位寄存器的移位频率为100MHz，因为有8位位移，那么平摊下来每一位的移位频率为100/8=12.5MHz，向SCK输入上升沿的频率就不能超12.5MHz，但是！这个参数只是设计参数，实际芯片制造商不同实际参数也不同，通过查询我使用的单片机上的芯片<code>NXP 74HC595D HYC23HK UnL1418L</code>的实际最大移位频率只有30MHz，那么根据上式计算出来移位频率就只有3.75MHz了</p>
<p>问题又又又来了，我怎么知道我在输入低电平和高电平之间的那段延时延时了多久呢？此时我们就可以引入一个新的头文件<code>#include &lt;intrins.h&gt;</code>，这个头文件中包含了一个我们需要的函数：<code>_nop_()</code>，这个函数代表的含义就是延时一个机器周期，而一个机器周期也就是十二个时钟周期，我们只需要知道单片机上晶振的频率那么就可以知道这个函数延时的时长了，不管是什么品牌的学习单片机上所使用的晶振基本上都是11.0592MHz的，其实在单片机的实际使用中基本上都是1.2MHz或者12MHz，但是由于学习使用的单片机上有串口烧录的电路，这其中的原理我在撰写这篇文章时尚不明确，反正就是因为有烧录的电路所以需要使用到11.0592MHz的晶振，那么运行一个机器周期的频率也就是0.9216MHz，因此我们只需要延时一个机器周期即可</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*SCK为实际向SCK输入的数据*/</span></span><br><span class="line">SCK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(u8 a = <span class="number">0</span>; a &lt; <span class="number">8</span>; a++)&#123;</span><br><span class="line">  SER = dat &gt;&gt; <span class="number">7</span>;</span><br><span class="line">  dat &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  SCK = <span class="number">0</span>;_nop_();SCK = <span class="number">1</span>; <span class="comment">//约1MHz的频率输入上升沿</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>11脚（RCK）存储寄存器时钟引脚：</p>
<p>经过这一系列操作，我们已经实现了上面GIF图中的操作，但是寄存器分为两部分，一部分就是刚刚所使用的移位寄存器，另外一部分就是存储寄存器，存储寄存器的原理跟移位寄存器有一部分相同又有一部分不相同，不相同的是移位寄存器是一位一位地将一个引脚中的数据依次输入到移位寄存器的8位中，而存储寄存器是一次性将移位寄存器内的数据一一对应地输入到存储寄存器中；相同的是两者都需要一个上升沿来告诉芯片什么时候该取数据</p>
<p>由于存储寄存器是一次性将移位寄存器中的数据“复制粘贴”进去，因此也就不需要一个循环8次的for循环了，只需要在移位寄存器将数据全部输入后给一个上升沿就好了，代码跟上一步类似不再过多赘述</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*RCK为实际向RCK输入的数据*/</span></span><br><span class="line">SCK = <span class="number">1</span>;</span><br><span class="line">RCK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(u8 a = <span class="number">0</span>; a &lt; <span class="number">8</span>; a++)&#123;</span><br><span class="line">  SER = dat &gt;&gt; <span class="number">7</span>;</span><br><span class="line">  dat &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  SCK = <span class="number">0</span>; _nop_(); SCK = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">RCK = <span class="number">0</span>; _nop_(); RCK = <span class="number">1</span>; <span class="comment">//约1MHz的频率输入上升沿</span></span><br></pre></td></tr></table></figure>
<p>那么以上就是<code>74HC595</code>芯片的大致用法原理了，我们将上述的代码稍微修改一下封装成一个函数方便调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HC595SendByte</span> <span class="params">(u8 dat)</span></span>&#123; <span class="comment">//要按二进制输出的数据dat</span></span><br><span class="line"><span class="comment">/*RCK为实际向RCK输入的数据，SCK为实际向SCK输入的数据</span></span><br><span class="line"><span class="comment">SER为实际向DS输入的数据，dat为想要向DS输入的原始数据*/</span></span><br><span class="line">SCK = <span class="number">1</span>;</span><br><span class="line">RCK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(u8 a = <span class="number">0</span>; a &lt; <span class="number">8</span>; a++)&#123;</span><br><span class="line">  SER = dat &gt;&gt; <span class="number">7</span>;<span class="comment">//将最后一位移位变为第一位</span></span><br><span class="line">  dat &lt;&lt;= <span class="number">1</span>; <span class="comment">//从右向左依次移位</span></span><br><span class="line">  SCK = <span class="number">0</span>; _nop_(); SCK = <span class="number">1</span>; <span class="comment">//约1MHz的频率输入上升沿</span></span><br><span class="line">&#125;</span><br><span class="line">RCK = <span class="number">0</span>; _nop_(); RCK = <span class="number">1</span>; <span class="comment">//约1MHz的频率输入上升沿</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h2><p>上面已经将<code>74HC595</code>芯片的使用封装在函数中了，它实际占用了3个<code>I/O</code>口来控制LED点阵的8个引脚（即段选或位选），那么LED点阵的另外8个引脚在我使用的普中科技51单核A2开发板上是直接连接到单片机核心通过单片机核心的<code>I/O</code>口进行控制的，但是实际上这种控制方法并不好，因为我们知道刚刚学到的<code>74HC595</code>芯片能够大大帮助我们节省<code>I/O</code>口，因此我们可以将两个<code>74HC595</code>芯片串联来实现大大节约<code>I/O</code>口的目的，如何串联？且等我先按照实际开发板电路正确点亮单片机后再从原理上细细讲解</p>
<p>编写程序现在已经非常简单了，先输入程序的大体框架，将该使用的函数写入，该定义的变量进行定义，这些全部写好后，我们需要在<code>main</code>函数中需要写的东西就很少了，要点亮一个点，只需要向段选和位选发送相应的高低电平即可，另外需要注意，LED点阵的显示原理也是需要靠动态刷新实现的，因此与动态数码管一样需要一个<code>for</code>循环来实现每次的刷新，所要显示的内容以数组形式存储在程序中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_P0 P0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8;</span><br><span class="line">sbit SCK = P3^<span class="number">6</span>; <span class="comment">//位定义移位寄存器时钟</span></span><br><span class="line">sbit RCK = P3^<span class="number">5</span>; <span class="comment">//位定义存储寄存器时钟</span></span><br><span class="line">sbit SER = P3^<span class="number">4</span>; <span class="comment">//位定义串行输入</span></span><br><span class="line">u8 LEDduan[<span class="number">8</span>] = &#123;<span class="number">0x7f</span>&#125;; </span><br><span class="line">u8 LEDwei[<span class="number">8</span>] = &#123;<span class="number">0x80</span>&#125;; <span class="comment">//定义变量段选和位选</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span> <span class="params">(u16 i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HC595SendByte</span> <span class="params">(u8 dat)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  u8 i;</span><br><span class="line">  <span class="comment">/*位选0b1000000，段选0b0111111，也就是点亮第1行第1列的点*/</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">    GPIO_P0 = LEDwei[i]; <span class="comment">//位选</span></span><br><span class="line">    HC595SendByte(LEDduan[i]); <span class="comment">//段选</span></span><br><span class="line">    delay(<span class="number">200</span>); <span class="comment">//刷新间隔</span></span><br><span class="line">    HC595SendByte(<span class="number">0x00</span>); <span class="comment">//消隐</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span> <span class="params">(u16 i)</span></span>&#123;<span class="keyword">while</span>(i --);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HC595SendByte</span> <span class="params">(u8 dat)</span></span>&#123;</span><br><span class="line">u8 a;  </span><br><span class="line">SCK = <span class="number">1</span>;</span><br><span class="line">RCK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(a = <span class="number">0</span>; a &lt; <span class="number">8</span>; a++)&#123;</span><br><span class="line">  SER = dat &gt;&gt; <span class="number">7</span>;</span><br><span class="line">  dat &lt;&lt;= <span class="number">1</span>; </span><br><span class="line">  SCK = <span class="number">0</span>; _nop_(); SCK = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line">RCK = <span class="number">0</span>; _nop_(); RCK = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于LED点阵的在该单片机上的电路设计，因此想要点亮LED点阵的一个点，也需要使用到动态刷新的方法来让LED点阵只点亮一个点，如果不使用动态刷新的方法一次性就会点亮一列，因此在实际应用中，像学习用单片机上这种段选接单片机核心，位选接移位寄存器的方法是极其不妥当的，一方面占用的<code>I/O</code>口达到了惊人的11个，另一方面控制起来并不方便，并且由于动态刷新的存在，LED点阵的亮度也会相应的随着刷新间隔的减少而降低，因此该部分电路仅供学习了解原理，现实中正常设计项目并不会这么使用</p>
<h1 id="LED点阵显示图形"><a href="#LED点阵显示图形" class="headerlink" title="LED点阵显示图形"></a>LED点阵显示图形</h1><h2 id="图形显示原理"><a href="#图形显示原理" class="headerlink" title="图形显示原理"></a>图形显示原理</h2><p>显示原理依然是动态刷新，之前我们学习数码管的时候，只需要算出每个数字或者字母的段选和位选，将其存储在数组中方便调用，因此数码管的组合有限，基本上就是16个数字字母加小数点和加减符号什么的，常用的顶多也就是20种左右的组合方式，想要使用什么字符直接调用数组中的数据内容即可，但是LED点阵具有64个LED点，并且可以自由组合，因此组合方式大大增加，如果自己需要某一个图形，一个个计算段选和位选显然是极其麻烦的，因此我们就需要使用到一个辅助我们在LED点阵上进行绘图的软件：文字取模软件</p>
<p>按照本单片机的电路排布方法，我们选择<code>新建图像</code>-<code>8X8</code>-<code>模拟动画</code>-<code>放大格点</code>-<code>参数设置</code>-<code>纵向取模</code>，之后我们就可以在格子中点点进行作图了，作图好之后点击<code>取模方法</code>-<code>C51格式</code>-<code>点阵生成区</code>，直接把生成的段选码复制到程序中相应的数组中即可，而位选码由于每次扫描都是按顺序依次扫描，因此位选码绝大多数情况下都是恒定的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> LEDwei[<span class="number">8</span>] = &#123;<span class="number">0x7f</span>,<span class="number">0xbf</span>,<span class="number">0xdf</span>,<span class="number">0xef</span>,<span class="number">0xf7</span>,<span class="number">0xfb</span>,<span class="number">0xfd</span>,<span class="number">0xfe</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>我以汉字“电”为例进行取模，取模完成后如下图，我们将这些段选和位选代码加入到之前的程序中去，我们就可以按照这种方法在8X8LED点阵中显示自己画出的简易图像了</p>
<img src="/p/3359/qvmo.png" class title="文字取模软件">

<h2 id="编写程序-1"><a href="#编写程序-1" class="headerlink" title="编写程序"></a>编写程序</h2><p>没什么好讲的，直接复制进去就完事了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_P0 P0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8;</span><br><span class="line">sbit SCK = P3^<span class="number">6</span>; </span><br><span class="line">sbit RCK = P3^<span class="number">5</span>; </span><br><span class="line">sbit SER = P3^<span class="number">4</span>; </span><br><span class="line">u8 LEDduan[<span class="number">8</span>] = &#123;<span class="number">0x7c</span>,<span class="number">0x54</span>,<span class="number">0x54</span>,<span class="number">0xff</span>,<span class="number">0x55</span>,<span class="number">0x55</span>,<span class="number">0x7d</span>,<span class="number">0x02</span>&#125;; </span><br><span class="line">u8 LEDwei[<span class="number">8</span>] = &#123;<span class="number">0x7f</span>,<span class="number">0xbf</span>,<span class="number">0xdf</span>,<span class="number">0xef</span>,<span class="number">0xf7</span>,<span class="number">0xfb</span>,<span class="number">0xfd</span>,<span class="number">0xfe</span>&#125;; <span class="comment">//定义变量段选和位选</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span> <span class="params">(u16 i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HC595SendByte</span> <span class="params">(u8 dat)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  u8 i;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">    GPIO_P0 = LEDwei[i]; <span class="comment">//位选</span></span><br><span class="line">    HC595SendByte(LEDduan[i]); <span class="comment">//段选</span></span><br><span class="line">    delay(<span class="number">200</span>); </span><br><span class="line">    HC595SendByte(<span class="number">0x00</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span> <span class="params">(u16 i)</span></span>&#123;<span class="keyword">while</span>(i --);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HC595SendByte</span> <span class="params">(u8 dat)</span></span>&#123;</span><br><span class="line">u8 a;  </span><br><span class="line">SCK = <span class="number">1</span>;</span><br><span class="line">RCK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(a = <span class="number">0</span>; a &lt; <span class="number">8</span>; a++)&#123;</span><br><span class="line">  SER = dat &gt;&gt; <span class="number">7</span>;</span><br><span class="line">  dat &lt;&lt;= <span class="number">1</span>; </span><br><span class="line">  SCK = <span class="number">0</span>; _nop_(); SCK = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line">RCK = <span class="number">0</span>; _nop_(); RCK = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="74HC595知识补充"><a href="#74HC595知识补充" class="headerlink" title="74HC595知识补充"></a>74HC595知识补充</h1><p>在上面的内容中我们学习到了595芯片的大致上的用法，但是我在最前面提到了一句“位移缓存器实现了1个输入来控制8+1个输出”，刚刚的使用中只实现了8位输出，那么那个多出来的1位输出是干什么的呢？多出来的一位输出在我使用的单片机中并没有接入电路，但是他又非常重要的作用，有了这第9位输出，才能实现595芯片的串联</p>
<p>上面的GIF图也很形象地显示出移位寄存器的工作原理了，那就是一位位地将DS的数据输入，由于刚刚只使用到了8位数据因此第9位我压根也就没画，但是，如果我们要向DS输入两个8位数据也就是十六位数据呢？从最先进入的数据开始，他们会被新来的数据一位位地挤到第9位，由于存储寄存器只有8位，因此被挤到第9位的数据不被该寄存器（存储寄存器）输出，那么这些数据去了哪里呢？如果这一输出引脚没有接入电路，那么被挤到第9位的数据便会被舍弃，如果接入电路了呢？那么就会直接输出，不经过存储寄存器</p>
<p>此时，我们便可以将这第9位数据输入到一个新的595芯片的DS引脚上，新的595芯片的两个时钟输入与上一个595芯片并联，那么，被上一个寄存器挤出的数据就会重新一位一位的输入到新的寄存器中并完成之前同样的操作：8位内的数据复制给存储寄存器，被挤出的第9位如果没有接新的电路则被舍弃，这样，我们便实现了通过3个<code>I/O</code>口控制惊人的16个引脚，并且你还可以再接一个，再接一个，“理论上”可以无限地串联下去，但是实际上受芯片工作频率的限制，如果你接的芯片太多，那么程序运行的效率会大大降低，因此不能接太多了</p>
<p>按照上面的操作，如果我们将段选和位选引脚都通过595芯片控制，那么上面显示汉字“电”的程序便会变为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_P0 P0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8;</span><br><span class="line">sbit SCK = P3^<span class="number">6</span>; </span><br><span class="line">sbit RCK = P3^<span class="number">5</span>; </span><br><span class="line">sbit SER = P3^<span class="number">4</span>; </span><br><span class="line">u8 LEDduan[<span class="number">8</span>] = &#123;<span class="number">0x7c</span>,<span class="number">0x54</span>,<span class="number">0x54</span>,<span class="number">0xff</span>,<span class="number">0x55</span>,<span class="number">0x55</span>,<span class="number">0x7d</span>,<span class="number">0x02</span>&#125;; </span><br><span class="line">u8 LEDwei[<span class="number">8</span>] = &#123;<span class="number">0x7f</span>,<span class="number">0xbf</span>,<span class="number">0xdf</span>,<span class="number">0xef</span>,<span class="number">0xf7</span>,<span class="number">0xfb</span>,<span class="number">0xfd</span>,<span class="number">0xfe</span>&#125;; <span class="comment">//定义变量段选和位选</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span> <span class="params">(u16 i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HC595SendByte</span> <span class="params">(u8 duan,u8 wei)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  u8 i;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;<span class="number">8</span>; i++)&#123;</span><br><span class="line">      HC595SendByte (LEDduan[i],LEDwei[i]); <span class="comment">//同时输入段选和位选</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span> <span class="params">(u16 i)</span></span>&#123;<span class="keyword">while</span>(i --);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HC595SendByte</span> <span class="params">(u8 duan,u8 wei)</span></span>&#123; <span class="comment">//输入段选和位选数据</span></span><br><span class="line"><span class="comment">/*由于之前该函数是控制段选，因此要注意是输入段选还是位选的先后顺序*/</span></span><br><span class="line">u8 a;  </span><br><span class="line">SCK = <span class="number">1</span>;</span><br><span class="line">RCK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(a = <span class="number">0</span>; a &lt; <span class="number">8</span>; a++)&#123; <span class="comment">// 之前该芯片控制段选，因此先输入位选，位选数据被挤到下一个芯片中</span></span><br><span class="line">  SER = wei &gt;&gt; <span class="number">7</span>;</span><br><span class="line">  wei &lt;&lt;= <span class="number">1</span>; </span><br><span class="line">  SCK = <span class="number">0</span>; _nop_(); SCK = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">for</span>(a = <span class="number">0</span>; a &lt; <span class="number">8</span>; a++)&#123;</span><br><span class="line">  SER = duan &gt;&gt; <span class="number">7</span>;</span><br><span class="line">  duan &lt;&lt;= <span class="number">1</span>; </span><br><span class="line">  SCK = <span class="number">0</span>; _nop_(); SCK = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line">RCK = <span class="number">0</span>; _nop_(); RCK = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察上述程序，main函数内的程序内容被大大简化，并且这样写还有一个非常大的优势就是可以实现LED点阵的动态显示，因为在基础寄存器中的数据在下一次更新或者关机前是不会发生变化的，因此在程序执行其他内容时依然能够保持上一次数据更新所显示的数据，由于本人目前手中单片机硬件限制，因此无法实验可行性，不过可以使用单片机仿真软件进行验证，而我在撰写该文章时并不是很习惯使用仿真软件，因此对于LED点阵动态显示内容暂时告一段落，实际上不使用两个<code>74HC595</code>芯片也是可以实现动态显示的但是有点麻烦</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这一部分大概是我从学习单片机以来最困难的一部分了，因为电子参考资料不全且正确，我手中也没有单片机相关教学的书籍（图书馆肯定有，但是我懒得去借），并且网上的资料也很有限，大面上知识是这个样子，但是一些小细节并没有文章作明确的讲解和说明，因此我了解的知识也是很混乱的，并且由于不习惯使用仿真器以及单片机电路设计的缺陷，我在本章不太好实现图形的动态显示，但是之后我对这部分知识了解透彻之后会回来更新的</p>
<p>这一部分设计知识较多较繁杂，我脑子也是有点乱的，虽然程序写的没问题，但是其中的知识点我想肯定还是有点问题的，如果你有什么疑惑或者发现了错误请及时与我联系</p>
<p>另外，这一次在程序框内我仅保留了更新的代码的注释，之前那样每次添加代码依然保留之前注释有点过于杂乱了，并且读者也很难抓住重点与更新了什么代码，所以之后大概都会像本篇一样啦</p>
<p><strong>特别鸣谢：</strong> <em>@tetrachino</em></p>
<hr>
<p><strong>参考资料：</strong></p>
<p>[1] 跳线帽图片：<a href="https://zhidao.baidu.com/question/60558299.html">https://zhidao.baidu.com/question/60558299.html</a></p>
<p>[2] 74HC595芯片原理参考1：<a href="https://arduino.nxez.com/2016/12/20/74hc595-chip-principle-and-arduino-use-example.html">https://arduino.nxez.com/2016/12/20/74hc595-chip-principle-and-arduino-use-example.html</a></p>
<p>[3] 74HC595芯片原理参考2：<a href="https://blog.csdn.net/ReCclay/article/details/78245642">https://blog.csdn.net/ReCclay/article/details/78245642</a></p>
<p>[4] 74HC595D芯片手册：<a href="https://wenku.baidu.com/view/11a43fa1f524ccbff12184c6.html">https://wenku.baidu.com/view/11a43fa1f524ccbff12184c6.html</a></p>
<p><i class="fa fa-refresh" aria-hidden="true"></i>   更新于2020/5/1</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>单片机</tag>
        <tag>STC89C52</tag>
        <tag>74HC595</tag>
      </tags>
  </entry>
  <entry>
    <title>互联网将人们联系到一起，但是人们究竟是成为了朋友还是成为了仇人？</title>
    <url>/p/492.html</url>
    <content><![CDATA[<p><i class="fa fa-info-circle" aria-hidden="true"></i>   <strong>撰写此文章时没有经过冷静期，存在有大量主观臆断，留存作为日后反思</strong></p>
<p>我最近在思考，自从我们有了互联网，我们究竟是成为了朋友还是仇人？或许是我不善社交的缘故，我感觉到很多很不好的感觉，整个事件的起因大概也就是最近推上闹的沸沸扬扬的关于那两个“学中文的外国人”的事情吧，因为整件事情不同于以往设计政治的事情，在对政治方面，我一直在回避很多问题，因此我的关注基本上都是：与我政治见解相似或者不相差甚远，或者虽然政治见解有所偏差但是其本身有对我来说过硬的技术知识的网友，不过最近的这件事情我看到了部分我关注的网友站到了我的另一方面，即便是我没有公开发表立场，但这仍然让我有点难过</p>
<p>整个事件的起因是源于一个人对另外三个人发出疑似政治间谍的质疑，我看过了他本人的原文，他本人的话语个人不是太相信，因为猜想的有些激进与片面了，但是因此才引起了这一波双方的对立</p>
<p>第一个韩国人，自称是14岁初中生，但是我很久之前貌似是看到过说自己是小学生来着？忘记了，也可能是我记错了，不过这都不重要，重要的是其被关注者数量较大，且关注者数量极少，这让我有点不适，因为这种行为完全与我的网络社交理念背离，给我一种“极度以自我为中心，不想了解其他人，高高在上”的感觉，并且此事一出，下面的“天狗”行为有点溢出（实际上在此之前也是），这位被关注量较多的根本原因无非两点：1.她是学习中文的外国人，中推圈对这类人一般都抱有友好的态度 2.她是女性，这一点很重要，因为我刚上推的时候也关注过很多学习中文的外国人，他们的关注数都比较少，并且关注量与被关注量接近1:1，部分风趣幽默或者能够引起共同话题的人这个比例会低一些，这些人几乎都是男性，回到这件事情上，试想一下如果当事人是男性，那么结果会怎样？结果是这种事情根本不会发生，因为如果是男性，并且没有互fo进行互相交流互动的话，被关注量绝对不会那么多，也不会出现这类事情被推向风口浪尖</p>
<p>第二位日本人，对于她我了解的并不多，但是与上面那一位相仿，都是：极少的关注量，极高的被关注量，是学习中文的外国人，是女性，发生的事情与刚刚的也相仿，首先这样的行为就在我这不引起好感，并且根据聊天截图可以看到，这位在私人聊天中的言语有点让人反感，她的人设貌似也就是这样，并且她的中文貌似很好？能够在合适的场景下使用俚语与紧跟时事的网络用语，因为上面的这些所以被怀疑了，对此我觉得无法得出所谓“间谍”的判断，仅仅是人设层面我不喜欢而已</p>
<p>我讨厌的仅仅是上面的社交理念以及人们对待不同人群的态度，不过我貌似更不喜欢后者，但是这无所谓，毕竟不是所有人都招人喜欢的，也不是所有人都能看谁都顺眼，并且我个人也不咋讨人喜欢哈哈，对于这两位仅仅发表自己的一点真实想法，仅此而已，我选择从博客发表也是因为这两位不可能看到这里，避免了误伤对其本人的伤害同样也因为释放了我自己内心的想法而轻松一点，实际上真正让我不适的是下方评论区的人们，这些人我不知道是真的为了安慰别人还是仅仅因为她们是女性满足自己某些精神方面的快感，因为事实表明女性网友出事除非是有官方实锤不然为其说话的人远高于男性，很多都让我感到不适，相对而言较有素质的人群会发表一些相对文明的语言，但是也有不少人在双方都无明确证据的时候互相骂了起来，有的骂的就比较难听了，并且最近貌似事情也不少，我的timeline充满了争吵与不信任，这导致我有点烦，我不知道自己是出于“嫉妒”的心理还是“愤怒”的心理，但是这都让我感到不适，并且我不敢直接发表自己的看法，我不希望自己也被卷入其中，因此我也就无法得知自己到底是这件事情上到底是“相对正确”还是“相对错误”，究竟是“我错了”还是“我没错”</p>
<p>第三位的话，之前我跟他互fo过，但是现在他的言论与思想让我极其不适，不管是任何方面，都让我感到不适，不过依然还是有许多我关注的网友关注了他，对于他的各种言论，我不作评判，但是他下面的评论区也是妖魔鬼怪最多的</p>
<p>“言论自由”是一把双刃剑，一方面让大家畅所欲言，一方面让大家成为仇人（虽然没有言论自由的地方也并不影响大家成为仇人），不过后者我觉得大概更多的是人们自身的问题，自从人类通过使用虚构的东西来让能够实现合作的人群突破150人以来，人们就活在“虚拟的世界”中，因此当网络这种虚拟的世界真正出现后，大家便理所当然的将他当作了现实，有的人说“网络虚拟，交心不宜”，但现实中更何况不是如此呢？人们共同生活共同合作，其原因并不是他们一出生就相识，因而你所看到的其他人实际上也可能在隐瞒自己的内心，在你的视野之外他们可能是另外一个人，在之前人们会为了自己的信仰而出征，而进行种族屠杀，那么为什么就不能在网络上口诛笔伐呢？网络仅仅是提供了便利的条件，就像玩家们游玩fps游戏时不必真正前往战场一样，因此也就没有了那么多的顾虑</p>
<p>从古至今，人们发生争吵的理由有的是信仰，那是因为他们的信仰在他们自身看来是真实的，是至高无上的；也有的是财富，那是因为财富能给他们带来真真切切的物质便利；也有的是自己喜欢的明星，那是因为他们所喜欢的明星能给他们带来他们认为最好的影视作品；也有的是自己使用设备的厂商，那是因为他们认为自己使用的产品与使用者的素质相关；而如今，人们却能够为了根本就没鸟过自己的人发生争吵，这真的是荒谬至极，虽然这其中夹杂了不少政治上的因素，但是这依然不能被我视而不见</p>
<p>趋利避害是所有生物的本能，如今，我也决定避害，我不愿看到人们因为荒谬的理由发生争吵，更不愿为了荒谬的理由与人发生争吵，岁月并不静好，但为什么还在为了这样的事情而争吵呢？</p>
<p><del>淦，写着写着电脑崩溃了，下面写的一段都没了，还要重新写</del></p>
<p>今天有感而发吧，行文与逻辑可能不是很通顺，因为我是想到什么就写了什么，然后呢，这篇文章大概也不会有人看，即便是有看的大概也是来我博客翻教程偶然看到的哈哈，不过人总要抱点希望的，如果人失去了希望活着也就没有意义了，如果你是看到我已经很久不使用之前的账号了因此来翻博客或者去关注我新号了，那么非常感谢你，感谢你能让我在你的社交圈留下印象！</p>
<p>具体联系方式的话旧号个人简介我也留啦，或者说你可以通过本网站的PC端向我发送电子邮件或者电报，新号我将遵循个人刚刚学习到的一些社交上的理念，新号的被关注量大概不会超过200，原则上在150以内吧，不过估计现实中能有20个就不错啦，因为其实也没跟太多人关系比较好，之前有几个因为各种原因有的失踪了，有的退推了，有的加了别的联系方式，新号我大概也不会去关注太多之前认识的网友，我大概会主动加几个自己认为值得信任并且一些思想我想对认同或者之前给我过许多帮助的推油，不过也都是随缘，偶尔看一眼会加几个吧，没加也不代表什么，我懒得一次性全加上，并且这次决定是我一时决定，我需要一段时间冷静期来思考，如果加新号通过了的话说明我一定不会对你有太多意见。。。</p>
<p>那么暂时就到此为止吧：2019.2——2021.5｜382关注｜1228被关注</p>
<p>不管怎样，感谢陪伴</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>奇思妙想</tag>
        <tag>社交</tag>
      </tags>
  </entry>
  <entry>
    <title>51单片机开发例程-7</title>
    <url>/p/f2d8.html</url>
    <content><![CDATA[<p>之前我们都是学习通过单片机核心来控制外部的各种电路，这次我们要学习单片机内部的一个很重要的系统：中断系统，通过中断系统，我们可以使得单片机可以在运行过程中优先执行比起现在正在执行的程序更重要的程序，并且在该内容中我们也将学习到定时器以及串口等内容</p>
<a id="more"></a>

<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>1.使用<code>STC89C52</code>的普中51-单核-A2单片机（本文以该单片机为样本）</li>
<li>2.能够正常下载驱动以及Keil等开发软件的Windows10.0系统PC</li>
<li>3.一根micro USB to USB A数据线</li>
</ul>
<h1 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h1><h2 id="中断系统概念"><a href="#中断系统概念" class="headerlink" title="中断系统概念"></a>中断系统概念</h2><p>对于单片机来讲，中断是指的CPU在执行处理某一个事件A的时候，发生了另外一个事件B（<strong>中断源</strong>），请求CPU去迅速处理事件B（<strong>中断发生</strong>），于是CPU立刻暂停现在正在执行的事件A（<strong>中断相应</strong>）转去处理事件B（<strong>中断服务</strong>），待CPU将事件B处理完毕后，再返回来，继续处理事件A被中断时的事件（<strong>中断返回</strong>）</p>
<p>如果上面的叙述对你来说有点难以理解，那么我们可以从日常生活中的事件来举例，假如你正在做饭，锅正在灶台上烧水，而你现在正在切菜，但是你发现水烧开了（<strong>中断发生</strong>），于是你立即放下手中的刀（<strong>中断相应</strong>）去调小火或者加入要煮的东西（<strong>中断服务</strong>），当你调小火或者加入要煮的东西后，你便返回去继续去切菜（<strong>中断返回</strong>），并且你是继续上次的进度继续切菜而不是重新开始切</p>
<img src="/p/f2d8/zhongduan.png" class title="中断程序流程图">

<p>当然，中断源可能并不只一个，在我们的51单片机上一共有6个<code>I/O</code>口控制的5个中断源，这些中断源从上到下编号分别为0-4，中断也存在优先级并且与此处编号排序相同，这部分的内容我会在之后的部分细讲，在此一代而过</p>
<p>中断是为了使单片机具有对外部或内部随机发生的事件实时处理而设置的，中断功能的存在很大程度上提高了单片机处理外部或内部事件的能力，并且也是单片机的重要功能之一，是学习单片机必须掌握的内容</p>
<h1 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h1><h2 id="外部中断介绍"><a href="#外部中断介绍" class="headerlink" title="外部中断介绍"></a>外部中断介绍</h2><p>首先请看单片机核心的原理图，我们不难发现，在一些单片机的<code>I/O</code>口上，除了被称之为<code>Pnum^num</code>之外，有的还被赋予了特殊的附加功能，比如<code>P3^2</code>和<code>P3^3</code>分别被定义了INT0和INT1的功能，那么这两个功能便是单片机的外部中断</p>
<img src="/p/f2d8/Core.png" class title="单片机核心">

<p>外部中断是单片机实时处理外部事件的机制，这里的内外部指的就是单片机内外部，但是我们注意到，单片机的<code>P3^2</code>和<code>P3^3</code>口是连接到独立按键上的，那么为什么之前独立按键没有出现所谓“中断”的情况呢？那是因为中断系统也是需要“开启”的</p>
<img src="/p/f2d8/zhongduan1.png" class title="外部中断结构图">

<p>两个外部中断其实除了优先级不同差别并不大，在此以优先级最高的外部中断0作为例子进行讲解，观察上面的外部中断结构图，先不要管其他的元素，我们看到，要使得INT0接通，首先要经过TCON的控制，通过控制IT0来选择外部中断激发的模式，一种是下降沿有效，一种是低电平有效，也就是一种是从高电平变为低电平才有效，另一种是只要是低电平就有效，这两种控制方法根据自己实际的程序来选择，一会我会选择一个实例程序来演示</p>
<blockquote>
<p>INT0对应的是P3^2口的附加功能，可由IT0（TCON.0）选择其为低电平有效还是下降沿有效，当CPU检测到P3^2引脚上出现有效的中断信号时，中断标志IE0（TCON.1）置1，向CPU申请中断</p>
<p>INT1对应的是P3^3口的附加功能，可由IT1（TCON.2）选择其为低电平有效还是下降沿有效，当CPU检测到P3^3引脚上出现有效的中断信号时，中断标志IE1（TCON.3）置1，向CPU申请中断</p>
<p>——STC89C52中文芯片手册</p>
</blockquote>
<p>之后要经过两个开关：EX0和EA，其中EA的开关将5个中断都连接了起来，他的作用就像是我们家庭电路中的总电闸，把总电闸关掉其他用电器不管怎么样打开关闭自然都是没电的，而EX0就像是插排的开关，必须要打开插排开关，插在插排上的用电器才会通电，而有的用电器上也有开关，这就像是刚刚讲过的IT0的控制，必须给一个下降沿或者低电平来“打开开关”，用电器才会正常工作，那么梳理一下思路，我们要让台式电脑工作，就必须保证你家电源的电闸闭合（EA），然后按下插排开关（EX0），然后按下电脑的开机键（IT0），那么你的电脑才能正常工作，不过有些中断也不太一样，比如你看结构图中的定时器中断T0和T1，这两个中断其余的部分和外部中断一样，但是没有IT0（IT1）的这样一个开关，那么这个定时器中断就好像是你的手机充电器，充电器上没有开关，只要总电闸和插排打开了插上手机就能充电</p>
<p>知道了外部中断由3级开关进行控制，要使用外部中断，我们就要把他们都打开，其中IE的两个开关是由一个中断允许寄存器进行控制的</p>
<img src="/p/f2d8/zdyxjcq.png" class title="中断允许寄存器">

<p>这个部分按照这个图直接给IE赋值就可以了，但是需要注意：直接给IE赋值即可，无需定义，并且赋值需要在函数内进行赋值，不能在函数外进行赋值，查看上面的图我们可以知道要将外部寄存器的这两个开关打开，只需要在函数内加一句<code>IE = 0x81;</code>即可</p>
<img src="/p/f2d8/zdqqjcq.png" class title="中断请求寄存器">

<p>这个是用来选择是下降沿有效还是上升沿有效的，因为不像IE需要打开开关，我们调用IE会方便一些，这个只需要打开一个开关即可，因此我们只需要给对应的变量赋值就好：<code>IT0 = 1;</code>（下降沿有效）或者<code>IT0 = 0;</code>（低电平有效）</p>
<h2 id="外部中断测试"><a href="#外部中断测试" class="headerlink" title="外部中断测试"></a>外部中断测试</h2><p>我们把该打开的开关打开了，然后也把中断请求的类型选择好了，接下来就拿一个程序来测试，我们在此选择之前写过的数码管显示正整数的程序，原代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8; </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_DIG P0 </span></span><br><span class="line">sbit beep = P1^<span class="number">5</span>; </span><br><span class="line">sbit SLA = P2^<span class="number">2</span>;</span><br><span class="line">sbit SLB = P2^<span class="number">3</span>;</span><br><span class="line">sbit SLC = P2^<span class="number">4</span>; </span><br><span class="line">u8 code SMG[]=&#123; </span><br><span class="line">  <span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line">  <span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line">  <span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    DigDisplay(<span class="number">114514</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>&#123; </span><br><span class="line">  <span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>&#123; </span><br><span class="line">  <span class="keyword">long</span> LED = <span class="number">10</span>; </span><br><span class="line">  u8 numlong = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">99999999</span>)&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;beep = ~beep;delay(<span class="number">100</span>);&#125;&#125;</span><br><span class="line">  <span class="keyword">while</span>(num / LED)&#123; </span><br><span class="line">    LED *= <span class="number">10</span>;</span><br><span class="line">    numlong ++;&#125; </span><br><span class="line">  <span class="keyword">for</span>(LED = <span class="number">8</span>; LED &gt; <span class="number">8</span> - numlong; LED--)&#123; </span><br><span class="line">    <span class="keyword">switch</span>(LED)&#123;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">1</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">2</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">3</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">4</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">5</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">6</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">7</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">8</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    GPIO_DIG = SMG[num % <span class="number">10</span>]; </span><br><span class="line">    num /= <span class="number">10</span>; </span><br><span class="line">    delay(<span class="number">100</span>);</span><br><span class="line">    GPIO_DIG = <span class="number">0x00</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用外部中断0进行控制，主函数一直执行数码管动态显示的函数，然后如果外部中断发生那么我们就让数字+1，原程序中的注释我已经全部删除因此请仔细查阅下面代码的注释：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8; </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_DIG P0 </span></span><br><span class="line">sbit beep = P1^<span class="number">5</span>; </span><br><span class="line">sbit SLA = P2^<span class="number">2</span>;</span><br><span class="line">sbit SLB = P2^<span class="number">3</span>;</span><br><span class="line">sbit SLC = P2^<span class="number">4</span>; </span><br><span class="line">u8 code SMG[]=&#123; </span><br><span class="line">  <span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line">  <span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line">  <span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>; </span><br><span class="line">u16 number = <span class="number">0</span>; <span class="comment">//重新定义一个全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  IE = <span class="number">0x81</span>; <span class="comment">//打开“两个开关”</span></span><br><span class="line">  IT0 = <span class="number">1</span>; <span class="comment">//选择控制类型为下降沿有效</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    DigDisplay(number); <span class="comment">//数码管显示这个全局变量的值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EX_INT0</span><span class="params">()</span> interrupt 0 <span class="comment">//外部中断函数</span></span></span><br><span class="line"><span class="function"></span>&#123;number ++;&#125; <span class="comment">//执行中断则给全局变量number+1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>&#123; </span><br><span class="line">  <span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>&#123; </span><br><span class="line">  <span class="keyword">long</span> LED = <span class="number">10</span>; </span><br><span class="line">  u8 numlong = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">99999999</span>)&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;beep = ~beep;delay(<span class="number">100</span>);&#125;&#125;</span><br><span class="line">  <span class="keyword">while</span>(num / LED)&#123; </span><br><span class="line">    LED *= <span class="number">10</span>;</span><br><span class="line">    numlong ++;&#125; </span><br><span class="line">  <span class="keyword">for</span>(LED = <span class="number">8</span>; LED &gt; <span class="number">8</span> - numlong; LED--)&#123; </span><br><span class="line">    <span class="keyword">switch</span>(LED)&#123;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">1</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">2</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">3</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">4</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">5</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">6</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">7</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">8</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    GPIO_DIG = SMG[num % <span class="number">10</span>]; </span><br><span class="line">    num /= <span class="number">10</span>; </span><br><span class="line">    delay(<span class="number">100</span>);</span><br><span class="line">    GPIO_DIG = <span class="number">0x00</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行，按下连接到外部中断0的按键K3，你会发现数码管显示的数字增加了1，这便是单片机成功执行中断程序的结果，那么如果我们把控制类型改为低电平有效呢？因为代码占用太多篇幅了我不再展示了，只需要改一改数字就行，改完后按下按键K3你会发现数码管数字飞快跳动，快到数码管显示都跟不上了，这就是因为按下K3时一直在低电平，然后程序也就一直在给数字+1，因此在这样一个程序中要使得按下一次开关数字+1就要使用上升沿有效的控制类型，这样一来程序就不用每次数码管刷新都要重新检测一下按键有没有被按下了</p>
<p>不过上述程序有一个致命缺陷，那就是：按键没有消抖！你可以试试，按不了几下数字就会跳，并且你不动的时候，数字也会随机增加1，因此我们要将外部中断0函数进行按键消抖的处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sbit K3 = P3^<span class="number">2</span>; <span class="comment">//位定义按键K3</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EX_INT0</span><span class="params">()</span> interrupt 0 <span class="comment">//外部中断函数</span></span></span><br><span class="line"><span class="function"></span>&#123;delay(<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">if</span>(K3 == <span class="number">0</span>)number ++;&#125; <span class="comment">//执行中断则给全局变量number+1</span></span><br></pre></td></tr></table></figure>
<p>这样一来就不会因为按键抖动而导致数字乱跳啦</p>
<p>另外，细心的人大概注意到了，这个外部中断函数居然是在main函数之后的，并且在main函数内没有进行调用，这是因为这个函数是由单片机内部中断系统自动进行调用执行，因此不需要写在main函数内，甚至也不需要写在main函数之前</p>
<p>根据上面的知识我们可以写出另外一个外部中断：外部中断1的使用，通过查阅芯片手册我们可以将外部中断1连接的按键K4设定为减1然后加入到上面的程序中，具体原因我也不作过多解释啦自己看一看我上面贴出来了的芯片手册的重要内容即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8; </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_DIG P0 </span></span><br><span class="line">sbit beep = P1^<span class="number">5</span>; </span><br><span class="line">sbit SLA = P2^<span class="number">2</span>;</span><br><span class="line">sbit SLB = P2^<span class="number">3</span>;</span><br><span class="line">sbit SLC = P2^<span class="number">4</span>;</span><br><span class="line">sbit K3 = P3^<span class="number">2</span>; <span class="comment">//位定义按键K3</span></span><br><span class="line">sbit K4 = P3^<span class="number">3</span>; <span class="comment">//位定义按键K3</span></span><br><span class="line">u8 code SMG[]=&#123; </span><br><span class="line">  <span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line">  <span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line">  <span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>; </span><br><span class="line">u16 number = <span class="number">0</span>; <span class="comment">//重新定义一个全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  IE = <span class="number">0x81</span>; <span class="comment">//打开“两个开关”</span></span><br><span class="line">  IT0 = <span class="number">1</span>; <span class="comment">//选择控制类型为下降沿有效</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    DigDisplay(number); <span class="comment">//数码管显示这个全局变量的值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EX_INT0</span><span class="params">()</span> interrupt 0 <span class="comment">//外部中断函数0</span></span></span><br><span class="line"><span class="function"></span>&#123;delay(<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">if</span>(K3 == <span class="number">0</span>)number ++;&#125; <span class="comment">//执行中断则给全局变量number+1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EX_INT1</span><span class="params">()</span> interrupt 2 <span class="comment">//外部中断函数1，其序号为3</span></span></span><br><span class="line"><span class="function"></span>&#123;delay(<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">if</span>(K4 == <span class="number">0</span>)number --;&#125; <span class="comment">//执行中断则给全局变量number+1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>&#123; </span><br><span class="line">  <span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>&#123; </span><br><span class="line">  <span class="keyword">long</span> LED = <span class="number">10</span>; </span><br><span class="line">  u8 numlong = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">99999999</span>)&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;beep = ~beep;delay(<span class="number">100</span>);&#125;&#125;</span><br><span class="line">  <span class="keyword">while</span>(num / LED)&#123; </span><br><span class="line">    LED *= <span class="number">10</span>;</span><br><span class="line">    numlong ++;&#125; </span><br><span class="line">  <span class="keyword">for</span>(LED = <span class="number">8</span>; LED &gt; <span class="number">8</span> - numlong; LED--)&#123; </span><br><span class="line">    <span class="keyword">switch</span>(LED)&#123;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">1</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">2</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">3</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">4</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">5</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">6</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">7</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">8</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    GPIO_DIG = SMG[num % <span class="number">10</span>]; </span><br><span class="line">    num /= <span class="number">10</span>; </span><br><span class="line">    delay(<span class="number">100</span>);</span><br><span class="line">    GPIO_DIG = <span class="number">0x00</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="定时器-计数器中断"><a href="#定时器-计数器中断" class="headerlink" title="定时器/计数器中断"></a>定时器/计数器中断</h1><h2 id="定时器-计数器中断介绍"><a href="#定时器-计数器中断介绍" class="headerlink" title="定时器/计数器中断介绍"></a>定时器/计数器中断介绍</h2><p>上面我们了解了中断系统以及外部中断，外部中断由于其没有复杂的电路结构因此较为简单，而定时器/计数器由于其内部存在两个寄存器并且其有多个工作方式以及功能，所以这部分内容难度相比外部中断大大增加，定时器/计数器中断对于单片机也是非常重要的，学会了这个中断系统便可以在自己的单片机上对时间进行精确控制，所以该部分务必理解透彻</p>
<p>在正式讲解之前我们需要复习一下时序的有关知识：</p>
<blockquote>
<p>震荡周期：为CPU提供定时信号的震荡源的周期，也就是晶振的周期</p>
<p>状态周期：2个震荡周期，也就是时钟周期</p>
<p>机器周期：6个状态周期（12个震荡周期）</p>
<p>指令周期：完成1条指令需要的时间，以机器周期为单位</p>
</blockquote>
<p>定时器/计数器为什么叫这个名字呢？顾名思义，它有两种功能，一种功能是可以定时，另一种功能是可以计数，那么直接在单片机CPU中执行我们之前学习过的<code>delay(time);</code>延时函数不就可以定时了吗？直接声明一个新的变量给它赋值不就可以计数了吗？如果在一些实际应用中真的可以这么用那么也就不会存在定时器/计数器了，实际上，你在单片机中延时的时长并不一定是你想要的时长，并且CPU还可能要执行其他指令，在延时函数内CPU是不会执行你写的其他程序的，比如说你要用单片机做一个时钟，通过计算每个延时函数延时多久那么CPU确实是知道自己的时间是几点，但是前提是没法执行数码管的显示程序，所以你也看不到现在时间到底是几点，时钟做出来就是为了给人看的，因此这样也就行不通了，那么计数呢，计数也会占用其他程序指令的执行时间，一些简单的计数何不交给计数器呢？定时器/计数器最大的好处就在于：它是<strong>与CPU相互独立的</strong>，也就是说，CPU在执行数码管的显示程序的同时，定时器在独立定时，这样我们不但可以让CPU知道自己的时间是准的，并且可以通过数码管显示出来，而计数器也是同理</p>
<p>因此，有了定时器/计数器这样一个结构，可以大大增加单片机的效率，一些简单的重复计时或者计数的工作可以交给定时器/计数器去做，CPU去执行那些相对复杂的程序，这样单片机就会既高效又准确</p>
<h2 id="定时器-计数器原理"><a href="#定时器-计数器原理" class="headerlink" title="定时器/计数器原理"></a>定时器/计数器原理</h2><img src="/p/f2d8/dsjsqjiegou.png" class title="定时&#x2F;计数器结构">

<p>相较于外部中断，定时器/计数器内部结构要复杂一些，单片机内部有两个可编程的定时器/计数器T0和T1，它们的原理实质上都是16位的加1计数器，这个计数器由高8位和低8位两个寄存器THx和TLx组成，它随着计数器的输入脉冲进行自加1，也就是每输入一个脉冲，计数器就加1，这样一来，如果输入的脉冲是晶振输出的脉冲，那便是定时器，如果输入的脉冲是其他进行计数部分的脉冲，那便是计数器，当计数器的所有位全部为1时，再输入一个脉冲就会使计数器溢出归0，溢出会向CPU发送相应的中断请求，CPU收到中断请求那就说明定时器定时时间已到，计数器所计数值已满，并且由于溢出才会发送中断请求，那么如果你设定计数99，当CPU收到中断请求时实际上已经计数100了，因此这个需要注意，别看这个数字很小，但是在长时间的叠加后会形成可观的误差</p>
<h3 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h3><p>这个寄存器在刚刚的外部中断中讲过，外部中断只是使用了这8位寄存器中的4位，那么剩下的4位就是来控制计数/计时器的了</p>
<img src="/p/f2d8/tcon.png" class title="定时&#x2F;计数器控制寄存器">

<p>4位寄存器控制2个定时/计数器，因此实际上也就只有两种功能：</p>
<blockquote>
<p>TF0（TCON.5）是T0溢出中断请求标志位，也就是该计数溢出时硬件自动将TF0置1，CPU相应中断后TF0恢复0，简单来说就是CPU通过该位的高低电平来判断是否有中断发生，不仅仅是CPU自身，我们也可以通过软件查询这一位的高低电平，并且给它赋值</p>
<p>TR0（TCON.4）运行控制位，说人话就是开关，当它是1时，定时/计数器0开始工作，反之不工作</p>
<p>另外两位同理，只不过是控制的对象换成了T1</p>
</blockquote>
<h3 id="工作方式寄存器"><a href="#工作方式寄存器" class="headerlink" title="工作方式寄存器"></a>工作方式寄存器</h3><p>这个寄存器用于设置定时/计数器的工作方式，与之前外部中断的那些寄存器是差不多的，通过给这个寄存器赋值来选择自己需要的工作方式，同样地：TMOD一共8位，高4位用于控制T1，低4位用于控制T0，这4位所控制的功能都是一样的，不同的在于控制的定时/计数器不一样</p>
<img src="/p/f2d8/tmod.png" class title="定时&#x2F;计数器工作方式寄存器">

<blockquote>
<p>GATE 门控位：用于控制定时器的启动是否受外部中断源信号的影响，当GATE=0时，定时/计数器不受外部中断源信号影响，但是当GATE=1时，要启动定时/计数器，不仅仅要将TCON中的开关打开，还需要外部中断INT0/1引脚也为1时才可以，也就是此时要定时/计数器工作，不但要打开它们对应的开关，还需要有外部中断，对于初学者后者几乎不使用，如果现在看不懂那么请暂时跳过</p>
<p>C/T 定时/计数模式选择位：低电平为定时模式，高电平为计数模式</p>
<p>M1和M0 工作方式设置位：通过这两位可以选择定时/计数器的四种工作方式</p>
</blockquote>
<img src="/p/f2d8/gzfs.png" class title="定时&#x2F;计数器工作方式">

<h3 id="定时器工作方式"><a href="#定时器工作方式" class="headerlink" title="定时器工作方式"></a>定时器工作方式</h3><p>这一部分涉及到一些门电路，能看懂就看懂看不懂其实也没有太大关系，因为这都是单片机内部的结构，我们没办法像外部芯片那样接几个电阻电容就能搞出一些骚操作来，在简单的实际应用中知道如何使用往往比知道原理更为重要</p>
<p>这一部分我在学习的时候也没打算理解透彻，因此我就直接复制手册的内容：</p>
<h4 id="方式0"><a href="#方式0" class="headerlink" title="方式0"></a>方式0</h4><p>方式0为13位计数，由TL0的低5位(高3位未用)和TH0的8位组成，TL0 的低 5 位溢出时向 TH0 进位，TH0 溢出时，置位 TCON 中的 TF0 标志，向 CPU 发出中断请求，其结构图如下所示:</p>
<img src="/p/f2d8/t0.png" class title="工作方式0结构图">

<p>门控位 GATE 具有特殊的作用。当 GATE=0 时，经反相后使或门输出为 1，此 时仅由 TR0 控制与门的开启，与门输出 1 时，控制开关接通，计数开始;当 GATE=1时，由外中断引脚信号控制或门的输出，此时控制与门的开启由外中断引脚信号 和 TR0 共同控制。当 TR0=1 时，外中断引脚信号引脚的高电平启动计数，外中断 引脚信号引脚的低电平停止计数。这种方式常用来测量外中断引脚上正脉冲的宽 度。计数模式时，计数脉冲是 T0 引脚上的外部脉冲。计数初值与计数个数的关 系为:X=2(13)-N。其中 2(13)表示 2 的 13 次方</p>
<h4 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h4><p>方式 1 的计数位数是 16 位，由 TL0 作为低 8 位，TH0 作为高 8 位，组成了 16 位加 1 计数器。其结构图如下所示:</p>
<img src="/p/f2d8/t1.png" class title="工作方式1结构图">

<p>计数初值与计数个数的关系为:X=2(16)-N</p>
<h4 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h4><p>方式 2 为自动重装初值的 8 位计数方式。工作方式 2 特别适合于用作较精确的脉冲信号发生器。其结构图如下所示:</p>
<img src="/p/f2d8/t2.png" class title="工作方式2结构图">

<p>计数初值与计数个数的关系为:X=2(8)-N</p>
<h4 id="方式3"><a href="#方式3" class="headerlink" title="方式3"></a>方式3</h4><p>方式 3 只适用于定时/计数器 T0， 定时器 T1 处于方式 3 时相当于 TR1=0， 停止计数。工作方式 3 将 T0 分成为两个独立的 8 位计数器 TL0 和 TH0。其 结构如下所示:</p>
<img src="/p/f2d8/t3.png" class title="工作方式3结构图">

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这几种工作方式中应用较多的是方式 1 和方式 2。定时器中通常使用定时器，方式 1，串口通信中通常使用方式 2</p>
<h1 id="基于定时器的计时器"><a href="#基于定时器的计时器" class="headerlink" title="基于定时器的计时器"></a>基于定时器的计时器</h1><h2 id="定时器配置"><a href="#定时器配置" class="headerlink" title="定时器配置"></a>定时器配置</h2><p>知道了上面各个寄存器的作用之后我们就可以开始配置定时器了，我们以16位定时器0为例：把计时器的开关打开<code>TR0 = 1;</code>，因为我们在该程序中并不需要外部中断的控制，因此<code>GATE = 0;</code>，选择定时模式<code>C/T = 0;</code>，选择16位定时<code>M1 = 0;M0 = 1;</code>我们可以看到对TMOD的配置比较多，因此我们直接对整个TMOD赋值，此时建议使用或运算符，这样有什么好处呢？我们只需要给想打开的位赋值1，不需要打开或者不知道的位赋值0，这样会很方便，并且不会影响其他位，因为已经赋值1的位在与0进行或运算后依然是1，举个例子：假如我们在之前已经打开了定时/计数器1，它的配置是<code>TMOD = 0x10</code>;其功能我们都已经写好了，但是之后我们又需要到定时器0，此时如果我们直接赋值<code>TMOD = 0x01;</code>那么之前打开的T1就会被关闭，此时我们需要的赋值就是<code>TMOD = 0x11;</code>要知道T1是怎么配置的还需要去翻前面的代码才能知道，但是如果我们直接给一个或运算进行赋值<code>TMOD |= 0x01</code>就不会影响T1的功能，位运算我也不细讲了之前学过C语言都会<del>懂得都懂</del></p>
<p><strong><i class="fa fa-info-circle" aria-hidden="true"></i></strong>   这边需要提醒一下，在之前的内容中虽然没有讲到，但是<strong>中断的不能频繁的开关，这样会引起时序问题！</strong>具体实例：<a href>51单片机传感器</a></p>
<p>上面配置好了以后定时器还不能正常工作，因为“总电闸”还有“插排开关”还没有打开，为了方便我在这里再放一下前面的图：</p>
<img src="/p/f2d8/zhongduan.png" class title="中断程序流程图">

<p>那么上面用来打开各种开关切换各种模式的代码汇总一下用函数封装便是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer0Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  TMOD |= <span class="number">0x01</span>; <span class="comment">//切换到16位定时器0</span></span><br><span class="line">  EA = <span class="number">1</span>; <span class="comment">//打开&quot;总电闸开关&quot;</span></span><br><span class="line">  ET0 = <span class="number">1</span>; <span class="comment">//打开“插排开关”</span></span><br><span class="line">  TR0 = <span class="number">1</span>; <span class="comment">//打开“电器开关”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还忘记了一件事！那就是我们使用的计时器，计时的时间是多少？之前我们讲到过寄存器存满溢出后发生中断，那么只需要对计时寄存器进行赋值使得它开始运行到溢出时恰巧是我们需要的时间，那么我们开始计算：</p>
<p>16位寄存器能够存储的数据是2^16 == 65535，但是我们之前讲到过，存满后再加1位才溢出，那么也就相当于寄存器数据为65536时数据溢出，以我的单片机为例子，在室温27摄氏度左右的时候单片机晶振1指令时间为：1/（11.018398MHz / 12） == 12 / 11.018398MHz == 1.089087542us，那么要使得计时10ms，那么寄存器需要计数大约9182次，那么我们就给寄存器一个初始值 65536 - 9182 == 56354 == 0xdc22，通过我们按高低位分别给两个寄存器赋值即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer0Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  TMOD |= <span class="number">0x01</span>;</span><br><span class="line">  TH0 = <span class="number">0xdc</span>; </span><br><span class="line">  TL0 = <span class="number">0x22</span>; <span class="comment">//初始化寄存器</span></span><br><span class="line">  EA = <span class="number">1</span>; </span><br><span class="line">  ET0 = <span class="number">1</span>; </span><br><span class="line">  TR0 = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于10进制到16进制的转换，对于128以内的数据我们还很容易处理，一旦数据过大建议使用计算器，Win10自带的计算器就有程序员模式：</p>
<img src="/p/f2d8/win10jsq.png" class title="计算器程序员模式">

<p>如果我们每次都这样算，那太麻烦了！在开发工具里面有可以直接输入晶振频率，定时时长以及定时器工作方式就可以求的初始值的工具：</p>
<img src="/p/f2d8/jsq.png" class title="计时器工具">

<p>值得一提的是，定时时长越长，定时约精确，因为小数点后的数字变少了，但是实际定时时长要根据自己需求，不能盲目求定时精确</p>
<h2 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h2><p>只控制一个破灯泡来定时闪烁不够直观，我们又需要用到我们的老朋友，数码管显示函数，因为在很多应用中都需要用到之前所写的函数，其实自己重新写也不是不可以，但是没必要，直接把自己写好的调用一些要方便的多，我所写的功能都封装在了函数中放在了文件中，使用时只需要调用文件然后调用函数即可，具体内容可以在我的GitHub中找到：51FunctionLibrary</p>
<p>数码管显示的函数，定时器初始化的函数我们都写好了，现在我们首先将中断内的程序写好然后将他们组合起来，计时器每次计时完毕后不会自动恢复原状，你需要在计时完成后重新对寄存器进行赋值，此处我们计时间隔一样，因此赋值也相同，另外计时器中断内的程序请尽量精简，不要把大块的内容扔在中断程序内，并且中断程序的开头最好就是对寄存器的赋值，以免其他程序运行占用时间</p>
<p>值得一提的是，interrupt后的数字是中断序号，这个不要错了，错了就完全不一样了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer0</span><span class="params">()</span> interrupt 1</span>&#123;</span><br><span class="line">  TL0 = <span class="number">0x22</span>;</span><br><span class="line">  TH0 = <span class="number">0xdc</span>; <span class="comment">// 重新初始化定时器</span></span><br><span class="line">  second ++; <span class="comment">//每完成计时给外部变量+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么将上面的函数拼装之后根据所需的需求进行稍加修改，程序就完成了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8; </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_DIG P0 </span></span><br><span class="line">sbit beep = P1^<span class="number">5</span>; </span><br><span class="line">sbit SLA = P2^<span class="number">2</span>;</span><br><span class="line">sbit SLB = P2^<span class="number">3</span>;</span><br><span class="line">sbit SLC = P2^<span class="number">4</span>; </span><br><span class="line">u8 code SMG[]=&#123; </span><br><span class="line">  <span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,</span><br><span class="line">  <span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,</span><br><span class="line">  <span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer0Init</span><span class="params">()</span></span>; <span class="comment">//初始化定时器</span></span><br><span class="line"><span class="keyword">long</span> time = <span class="number">0</span>; <span class="comment">//数码管显示的数字</span></span><br><span class="line">u16 second = <span class="number">0</span>; <span class="comment">//秒</span></span><br><span class="line">u8 minute = <span class="number">0</span>; <span class="comment">//分钟</span></span><br><span class="line">u8 hour = <span class="number">0</span>; <span class="comment">//小时</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  Timer0Init(); <span class="comment">//初始化定时器</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(second &gt;= <span class="number">6000</span>)&#123;second = <span class="number">0</span>; minute += <span class="number">1</span>;&#125; <span class="comment">//秒进位到分</span></span><br><span class="line">    <span class="keyword">if</span>(minute &gt;= <span class="number">60</span>)&#123;minute = <span class="number">0</span>; hour += <span class="number">1</span>;&#125; <span class="comment">//分进位到时</span></span><br><span class="line">    time = (hour * <span class="number">1000000</span>) + (minute * <span class="number">10000</span>) + second; <span class="comment">//显示换算</span></span><br><span class="line">    DigDisplay(time); <span class="comment">//数码管显示</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer0</span><span class="params">()</span> interrupt 1</span>&#123; <span class="comment">// 16位中断0</span></span><br><span class="line">  TL0 = <span class="number">0x22</span>;</span><br><span class="line">  TH0 = <span class="number">0xdc</span>; <span class="comment">// 重新初始化定时器</span></span><br><span class="line">  second ++; <span class="comment">//每完成计时给外部变量+1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 time)</span></span>&#123; </span><br><span class="line">  <span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">(<span class="keyword">long</span> num)</span></span>&#123; </span><br><span class="line">  <span class="keyword">long</span> LED = <span class="number">10</span>; </span><br><span class="line">  u8 numlong = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">99999999</span>)&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;beep = ~beep;delay(<span class="number">100</span>);&#125;&#125;</span><br><span class="line">  <span class="keyword">while</span>(num / LED)&#123; </span><br><span class="line">    LED *= <span class="number">10</span>;</span><br><span class="line">    numlong ++;&#125; </span><br><span class="line">  <span class="keyword">for</span>(LED = <span class="number">8</span>; LED &gt; <span class="number">8</span> - numlong; LED--)&#123; </span><br><span class="line">    <span class="keyword">switch</span>(LED)&#123;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">1</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">2</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">3</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">4</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">5</span>): SLA = <span class="number">1</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">6</span>): SLA = <span class="number">0</span>;SLB = <span class="number">1</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">7</span>): SLA = <span class="number">1</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">8</span>): SLA = <span class="number">0</span>;SLB = <span class="number">0</span>;SLC = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    GPIO_DIG = SMG[num % <span class="number">10</span>]; </span><br><span class="line">    num /= <span class="number">10</span>; </span><br><span class="line">    delay(<span class="number">100</span>);</span><br><span class="line">    GPIO_DIG = <span class="number">0x00</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer0Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  TMOD |= <span class="number">0x01</span>;</span><br><span class="line">  TH0 = <span class="number">0xdc</span>; </span><br><span class="line">  TL0 = <span class="number">0x22</span>; </span><br><span class="line">  EA = <span class="number">1</span>; </span><br><span class="line">  ET0 = <span class="number">1</span>; </span><br><span class="line">  TR0 = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过简单拼装就完成了，因此，越往后学习越需要用到之前的函数，程序的模块化非常重要，一方面大大增加了写程序时的效率，一方面大大增加了可读性，另一方面易于维护，可以说好处多多，因此从现在开始使用函数吧！</p>
<p>通过与手机的计时器对比，大约5-6分钟误差就会有1秒，这是因为晶振的震荡频率与温度关系密切，并且本程序还有可供优化的空间，在学习完温度传感器后我会再次讲起。虽然有一定误差，但是在一定范围内精度也是肉眼可观的，总比延时函数来的精确</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这部分内容比较多，实际上其实并不是特别难，刚开始学起记不住各种功能很正常，需要使用的时候翻看文档或者封装成函数即可，中断用起来不算特别困难，但是其能够实现的功能非常多，需要自己进行思考然后根据所需要的情况进行灵活运用组合，十分考验逻辑性，可以说下限非常低上限比较高就是了，因为中断是计算机的一个重要机制，在很多实例中我们都可以看到它们的身影，因此本章务必将使用方法了解透彻</p>
<p><i class="fa fa-refresh" aria-hidden="true"></i>   更新于2020/5/15</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>单片机</tag>
        <tag>中断系统</tag>
      </tags>
  </entry>
  <entry>
    <title>51单片机传感器-1</title>
    <url>/p/4301.html</url>
    <content><![CDATA[<p>本篇的标题不同于其他的51单片机开发基础文章，没错，这个是新坑，主要用于介绍单片机中用到的各种传感器，要学习这部分内容需要你有一定的单片机开发基础，并且拥有相应的传感器或者使用仿真器，这部分会一一以51单片机为基础讲解我从某宝上买到的45个传感器以及开关，因为套件刚到就使用到了这一传感器，所以也从这个传感器开始讲起，而这部分内容用到的正是我们在高中物理就接触过的：霍尔元件</p>
<a id="more"></a>

<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>1.使用<code>STC89C52</code>的普中51-单核-A2单片机（本文基于51单片机撰写）</li>
<li>2.能够正常下载驱动以及Keil等开发软件或者能够正常使用Proteus仿真软件的Windows10.0系统PC</li>
<li>3.一根micro USB to USB A数据线</li>
<li>4.三根母对母杜邦线</li>
<li>5.3144霍尔磁力传感器</li>
<li>6.一块磁铁</li>
</ul>
<h1 id="霍尔磁力传感器"><a href="#霍尔磁力传感器" class="headerlink" title="霍尔磁力传感器"></a>霍尔磁力传感器</h1><h2 id="霍尔元件简介"><a href="#霍尔元件简介" class="headerlink" title="霍尔元件简介"></a>霍尔元件简介</h2><p>简单点来说，霍尔元件就是一个检测磁场的传感器，我们生活中很多地方都能用到它，比如手机或者iPad那些关盖息屏的手机壳，门窗感应器等，好处也是非常多，那到底有什么好处呢，看下面：</p>
<blockquote>
<p>霍尔元件是一种基于霍尔效应的磁传感器。用它们可以检测磁场及其变化，可在各种与磁场有关的场合中使用。霍尔元件具有许多优点，它们的结构牢固，体积小，重量轻，寿命长，安装方便，功耗小，频率高（可达1MHZ），耐震动，不怕灰尘、油污、水汽及盐雾等的污染或腐蚀</p>
<p>——引用自<a href="https://baike.baidu.com/item/%E9%9C%8D%E5%B0%94%E5%85%83%E4%BB%B6/5120044?fr=aladdin">百度百科</a></p>
</blockquote>
<p><a href="https://www.51dzw.com/embed/embed_128565.html">[1]</a> 霍尔元件不仅仅在外观上有区别，在功能上也有所区分：一种是开关霍尔传感器，一种是线性霍尔传感器，它们有什么区别？开关霍尔传感器输出端输出的是高低电平，输出的波形是方波，也就是数字电路中所说的数字量，而线性霍尔传感器当给其施加的磁场逐渐增强时，其输出的电压会逐渐增大，也就是模拟电路中的模拟量，在实际使用中，我们更多地使用线性霍尔传感器，因为开关霍尔传感器常常因为温度等原因使得设定值漂移，灵敏度下降，并且开关霍尔传感器能做的事情比线性霍尔传感器少，那为何不用后者呢？</p>
<h2 id="3114线性霍尔磁力传感器"><a href="#3114线性霍尔磁力传感器" class="headerlink" title="3114线性霍尔磁力传感器"></a>3114线性霍尔磁力传感器</h2><p><i class="fa fa-info-circle" aria-hidden="true"></i>   首先要提醒下，<strong>不同芯片传感器的引脚功能是不一定相同的</strong>，一定要搞清楚引脚的功能，查阅正确的芯片手册，或者问购买的商家，不要自己瞎接线，不仅仅是这个霍尔传感器，其他的芯片传感器也是同理！<strong>自己瞎接线后果很严重！轻则烧集成电路，烧电阻，重则电容爆炸！</strong></p>
<img src="/p/4301/hall0.png" class title="3144线性霍尔传感器">

<p>霍尔元件的原理很简单，就是利用霍尔效应：当磁场作用于载流金属导体或者半导体中的电子时，产生横向电位差的物理现象，我们通过放大器将这个电位差放大输出，这就是最基本的霍尔传感器原理</p>
<img src="/p/4301/hall.png" class title="线性霍尔传感器原理图">

<p>绝大多数的霍尔传感器都具有三个引脚，分别是：GND，VCC和GPIO，前两者一个是接地，一个是按照芯片手册接入传感器正确的工作电压，后者是传感器的输出引脚，在本示例中我所使用的是3144霍尔传感器，其引脚定义图如下，从左到右分别是：接地，接3.3V电源，输出，因此我们只需要按照这个接入单片机即可，接入单片机核心的引脚只需要接输出即可</p>
<img src="/p/4301/hallio.png" class title="3144霍尔传感器引脚定义图">

<p>因为刚刚我们讲过，该传感器是线性传感器，那么实际上输出引脚输出的是一个波形，单片机如何判断呢？51单片机使用的是<a href="http://www.51hei.com/bbs/dpj-135738-1.html">[2]</a><strong>TTL电平：采用5V电源，输出高电平Uoh≥2.4V，输出低电平Uol≤0.4V，输入高电平Uih≥2.0V，输入低电平Uil≤0.8V</strong>，也就是说线性霍尔传感器输出的模拟量会被转换成数字量，因此也就不必担心线性霍尔传感器的使用问题了</p>
<h1 id="通过磁力点亮LED灯"><a href="#通过磁力点亮LED灯" class="headerlink" title="通过磁力点亮LED灯"></a>通过磁力点亮LED灯</h1><p>如果上面的理论知识对你来说还是太抽象的话，下面这样一个简单的程序示例就能让你很快了解到线性霍尔磁力传感器的使用方法了</p>
<p>我们刚刚讲到，对于线性霍尔传感器，单片机使用的TTL电平会对其起一个转化作用，我们就用下面这样一个简单的小程序来验证一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit Hall = P1^<span class="number">0</span>; <span class="comment">//将霍尔元件的输出端插到单片机P1^0口上</span></span><br><span class="line">sbit LED = P2^<span class="number">0</span>; <span class="comment">//LED灯</span></span><br><span class="line">sbit K1 = P3^<span class="number">1</span>; <span class="comment">//按键1</span></span><br><span class="line">sbit K2 = P3^<span class="number">0</span>; <span class="comment">//按键2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(Hall == <span class="number">1</span>)LED = <span class="number">0</span>; <span class="comment">//输出1时灯亮</span></span><br><span class="line">      <span class="keyword">else</span> LED = <span class="number">1</span>; <span class="comment">//输出0时灯灭</span></span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>你会发现你把传感器相应的那一面靠近磁铁相应的一极LED灯就会亮起，那么你就学会了霍尔传感器最基本的使用方法啦</p>
<h1 id="通过磁力检测门的开关"><a href="#通过磁力检测门的开关" class="headerlink" title="通过磁力检测门的开关"></a>通过磁力检测门的开关</h1><p>只检测门的开关那就过于简单了，跟上面LED灯一模一样，因此我们要实现的功能是：检测门的开关，如果门关着，那么什么都不会发生，如果门打开了一段时间没关，那么蜂鸣器响起，提醒关门，如果门关上了，蜂鸣器停止提示声</p>
<p>具体写的过程大概就是：检测门开启关闭，如果关闭，计时器清零，如果开启，开始计时，计时达到设定时间进入蜂鸣器循环，如果此时检测到门关闭那么跳出蜂鸣器循环，程序重新开始判断</p>
<p>然后呢，一步步写的过程我也懒得写了，代码做的详细的注释，值得注意的是代码调用了<code>51FunctionLibrary</code>中的函数，当然这个函数并不是必要的，而是调试过程中使用的，用于显示计时器是否开始工作，开工作后计时了多少，毕竟单片机不像直接写程序那么容易调试，当然你用仿真器的话这个貌似也并不是很需要XD</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;51FunctionLibrary.h&quot;</span></span></span><br><span class="line">sbit LED1 = P2^<span class="number">0</span>; <span class="comment">//调试用的LED</span></span><br><span class="line">sbit Hall = P1^<span class="number">0</span>; <span class="comment">//霍尔元件I/O</span></span><br><span class="line">sbit K1 = P3^<span class="number">1</span>;	 <span class="comment">//调试用复位开关</span></span><br><span class="line">u16 ms = <span class="number">0</span>;</span><br><span class="line">u8 timesecond = <span class="number">10</span>; <span class="comment">//设定从未关闭车门到报警的时间（秒）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer0Init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 delaytime)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    LED1 = Hall; <span class="comment">//调试用，可删</span></span><br><span class="line">    <span class="keyword">if</span>(Hall == <span class="number">0</span>)&#123; <span class="comment">//如果车门关闭 </span></span><br><span class="line">	    TR0 = <span class="number">0</span>;	<span class="comment">//关闭定时器</span></span><br><span class="line">		  ms = <span class="number">0</span>;  <span class="comment">//重置计时</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123; <span class="comment">//如果车门开启</span></span><br><span class="line">	  <span class="keyword">if</span>(ms == <span class="number">0</span>)Timer0Init(); <span class="comment">//如果计时为0那么开启定时器并输入参数</span></span><br><span class="line">	&#125;</span><br><span class="line">	DigDisplay(ms);	<span class="comment">//调试用数码管显示计时时长</span></span><br><span class="line">	<span class="keyword">if</span>(ms &gt;= <span class="number">100</span>*timesecond)&#123; <span class="comment">//如果时间达到设定时间</span></span><br><span class="line">	  ms = <span class="number">0</span>;	<span class="comment">//重置计时</span></span><br><span class="line">	  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	    beep = ~beep;delay(<span class="number">100</span>); <span class="comment">//蜂鸣器响起</span></span><br><span class="line">	    <span class="keyword">if</span>(K1 == <span class="number">0</span> || Hall == <span class="number">0</span>)<span class="keyword">break</span>;&#125;	<span class="comment">//如果按下按键K1或者关闭车门重置</span></span><br><span class="line">	  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer0</span><span class="params">()</span> interrupt 1</span>&#123; <span class="comment">//定时器中断</span></span><br><span class="line">  TL0 = <span class="number">0x22</span>;</span><br><span class="line">  TH0 = <span class="number">0xdc</span>;</span><br><span class="line">  ms ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer0Init</span><span class="params">()</span></span>&#123; <span class="comment">//开启16位定时器中断0并设定参数</span></span><br><span class="line">  ms ++; <span class="comment">//让ms不等于1，那么该函数就不会连续运行</span></span><br><span class="line">  TMOD |= <span class="number">0x01</span>;</span><br><span class="line">  TH0 = <span class="number">0xdc</span>; </span><br><span class="line">  TL0 = <span class="number">0x22</span>; </span><br><span class="line">  EA = <span class="number">1</span>; </span><br><span class="line">  ET0 = <span class="number">1</span>; </span><br><span class="line">  TR0 = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的程序运行起来没有问题，但是理论有大问题：频繁开关中断，因为上面的程序过于简单，只用到了一个中断，在我之前讲中断的那一节里面讲到，中断是有优先级的，<strong>频繁开关中断会导致时序冲突</strong>，因此代码需要对中断部分进行修改：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;51FunctionLibrary.h&quot;</span></span></span><br><span class="line">sbit LED1 = P2^<span class="number">0</span>; <span class="comment">//调试用的LED</span></span><br><span class="line">sbit Hall = P1^<span class="number">0</span>; <span class="comment">//霍尔元件I/O</span></span><br><span class="line">sbit K1 = P3^<span class="number">1</span>;	 <span class="comment">//调试用复位开关</span></span><br><span class="line">u16 ms = <span class="number">0</span>;</span><br><span class="line">u8 timesecond = <span class="number">10</span>; <span class="comment">//设定从未关闭车门到报警的时间（秒）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer0Init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 delaytime)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer0start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Timer0Init();</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    LED1 = Hall; <span class="comment">//调试用，可删</span></span><br><span class="line">    <span class="keyword">if</span>(Hall == <span class="number">0</span>)&#123; <span class="comment">//如果车门关闭 </span></span><br><span class="line">      ms = <span class="number">0</span>;  <span class="comment">//重置计时</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123; <span class="comment">//如果车门开启</span></span><br><span class="line">	  <span class="keyword">if</span>(ms == <span class="number">0</span>)timer0start(); <span class="comment">//如果计时为0那么开启定时器</span></span><br><span class="line">	&#125;</span><br><span class="line">	DigDisplay(ms);	<span class="comment">//调试用数码管显示计时时长</span></span><br><span class="line">	<span class="keyword">if</span>(ms &gt;= <span class="number">100</span>*timesecond)&#123; <span class="comment">//如果时间达到设定时间</span></span><br><span class="line">	  ms = <span class="number">0</span>;	<span class="comment">//重置计时</span></span><br><span class="line">	  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	    beep = ~beep;delay(<span class="number">100</span>); <span class="comment">//蜂鸣器响起</span></span><br><span class="line">	    <span class="keyword">if</span>(K1 == <span class="number">0</span> || Hall == <span class="number">0</span>)&#123;</span><br><span class="line">		  <span class="keyword">break</span>;ms = <span class="number">0</span>;	<span class="comment">//如果按下按键K1或者关闭车门重置</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;	</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer0</span><span class="params">()</span> interrupt 1</span>&#123; <span class="comment">//定时器中断</span></span><br><span class="line">  timer0start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer0Init</span><span class="params">()</span></span>&#123; <span class="comment">//开启16位定时器中断0并设定参数</span></span><br><span class="line">  TMOD |= <span class="number">0x01</span>; </span><br><span class="line">  EA = <span class="number">1</span>; </span><br><span class="line">  ET0 = <span class="number">1</span>; </span><br><span class="line">  TR0 = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer0start</span><span class="params">()</span></span>&#123;</span><br><span class="line">  TL0 = <span class="number">0x22</span>;</span><br><span class="line">  TH0 = <span class="number">0xdc</span>;</span><br><span class="line">  ms ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哈哈哈上面的其实也是有点问题的，因此计时器开了就是开了，如果你在计时器中断内对计时器的寄存器进行了赋值，那么除非是计时器关了或者机器关了，不然计时器都是一直在运行的，因此上面判断到车门开启就调用time0start就完全没有意义了，因此这个需要删除，而在else内只有这一条语句，因此对应的else也可以删除，然后在程序后面判断到达到时间后无需急着让ms为0，进入进入了蜂鸣器的循环，ms在循环内毫无意义，因此只需要跳出这个循环的时候给ms赋值0就可以了，最终修改的程序如下，以我的代码风格貌似这个程序没办法再精简了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;51FunctionLibrary.h&quot;</span></span></span><br><span class="line">sbit LED1 = P2^<span class="number">0</span>; <span class="comment">//调试用的LED</span></span><br><span class="line">sbit Hall = P1^<span class="number">0</span>; <span class="comment">//霍尔元件I/O</span></span><br><span class="line">sbit K1 = P3^<span class="number">1</span>;	 <span class="comment">//调试用复位开关</span></span><br><span class="line">u16 ms = <span class="number">0</span>;</span><br><span class="line">u8 timesecond = <span class="number">10</span>; <span class="comment">//设定从未关闭车门到报警的时间（秒）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer0Init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 delaytime)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer0start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">TMOD |= <span class="number">0x01</span>; <span class="comment">//开启16位计时器中断0</span></span><br><span class="line">EA = <span class="number">1</span>; </span><br><span class="line">ET0 = <span class="number">1</span>; </span><br><span class="line">TR0 = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    LED1 = Hall; <span class="comment">//调试用，可删</span></span><br><span class="line">    <span class="keyword">if</span>(Hall == <span class="number">0</span>)&#123; <span class="comment">//如果车门关闭 </span></span><br><span class="line">      ms = <span class="number">0</span>;  <span class="comment">//重置计时</span></span><br><span class="line">	&#125; <span class="comment">//如果车门打开，继续计时，车门非开即关，因此无需多余操作</span></span><br><span class="line">	DigDisplay(ms);	<span class="comment">//调试用数码管显示计时时长</span></span><br><span class="line">	<span class="keyword">if</span>(ms &gt;= <span class="number">100</span>*timesecond)&#123; <span class="comment">//如果时间达到设定时间</span></span><br><span class="line">	  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	    beep = ~beep;delay(<span class="number">100</span>); <span class="comment">//蜂鸣器响起</span></span><br><span class="line">	    <span class="keyword">if</span>(K1 == <span class="number">0</span> || Hall == <span class="number">0</span>)&#123;</span><br><span class="line">		  ms = <span class="number">0</span>;<span class="keyword">break</span>;	<span class="comment">//如果按下按键K1或者关闭车门重置</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;	</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer0</span><span class="params">()</span> interrupt 1</span>&#123; <span class="comment">//定时器中断</span></span><br><span class="line">  TL0 = <span class="number">0x22</span>;</span><br><span class="line">  TH0 = <span class="number">0xdc</span>;</span><br><span class="line">  ms ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="通过霍尔元件进行测速"><a href="#通过霍尔元件进行测速" class="headerlink" title="通过霍尔元件进行测速"></a>通过霍尔元件进行测速</h1><p>不知道你有没有用过或者见到过自行车上的测速表，在使用的时候需要在轮毂上安装一个磁铁，然后探测端绑到自行车前架上，与轮毂上磁铁对应，这一车轮每转一圈，传感器就能探测到磁铁的磁性因此也就知道了车轮转了一圈，结合车轮的半径数据，码表上就能显示出正确的车速，这个传感器便是霍尔传感器</p>
<p>如何知道车速呢？我们需要设定一个检测时间，检测在这个时间内车轮的转的圈数，然后进行计算才能得到在这一段时间内的平均速度，如果检测的时间够短，那么这段时间内的平均速度就可以近似的视为瞬时速度，但是考虑到如果你只转了9/10圈的话码表显示的速度依然是0，因此检测的时间越长，检测出的速度越准确，但是也就越不是“瞬时速度”，因此我们要在这两者之间进行权衡，究竟是“更直观”还是“更准确”？或者说两者都要？这就类似于之前的数码管，刷新的太快亮度会变低，刷新的太慢眼睛就能看到明显的频闪，因此在此我们取刷新时间为3秒，这个时间不会太快而导致测不准，也不至于太慢，实际上这个时间是以自行车为基准的，因为汽车的速度相比自行车要快，所以如果是汽车那么检测时间可以缩短</p>
<p>在这个程序中有三个进程，一个是必要的显示，这里使用动态数码管，一个是计时，对检测时间进行计时，还有一个是检测到车轮转过就加1的计数器</p>
<p>首先是动态数码管，我们直接将其放入主函数，计时使用计时中断，计数则使用外部中断，并且外部中断选择下降沿有效，因为当车轮转过时，转过的时间还远小于指令周期，如果选择低电平有效则会多次计数，车轮转过电平由高到低再到高，这其中只会有一次下降沿，因此我们选择下降沿有效</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;51FunctionLibrary.h&quot;</span></span></span><br><span class="line">sbit LED1 = P2^<span class="number">0</span>; <span class="comment">//调试用的LED</span></span><br><span class="line">sbit Hall = P3^<span class="number">2</span>; <span class="comment">//霍尔元件I/O</span></span><br><span class="line">sbit K1 = P3^<span class="number">1</span>;	 <span class="comment">//调试用复位开关</span></span><br><span class="line">u8 ms = <span class="number">0</span>;</span><br><span class="line">u8 wheelcount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> speed = <span class="number">0</span>; <span class="comment">//速度（m/h）</span></span><br><span class="line"><span class="keyword">float</span> wheeldiam = <span class="number">0.635</span>; <span class="comment">//轮毂的直径（m）26寸轮毂==0.635m直径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer0Init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 delaytime)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer0start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Timer0Init();</span><br><span class="line">IE |= <span class="number">0x81</span>; <span class="comment">//打开外部中断0</span></span><br><span class="line">IT0 = <span class="number">1</span>;  <span class="comment">//下降沿有效</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  DigDisplay(speed); </span><br><span class="line">  <span class="keyword">if</span>(ms &gt;= <span class="number">300</span>)&#123;  <span class="comment">//如果达到指定时间那么进入</span></span><br><span class="line">  speed = <span class="number">3.1416</span> * wheeldiam * wheelcount * <span class="number">3600</span> / <span class="number">3</span>; <span class="comment">//速度赋值</span></span><br><span class="line">  wheelcount = <span class="number">0</span>; <span class="comment">//重置计数</span></span><br><span class="line">  ms = <span class="number">0</span>;&#125; <span class="comment">//重置计时</span></span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EX_INTO</span><span class="params">()</span> interrupt 0</span>&#123; <span class="comment">//探测计数外部中断</span></span><br><span class="line">  wheelcount ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer0</span><span class="params">()</span> interrupt 1</span>&#123; <span class="comment">//定时器中断</span></span><br><span class="line">  TL0 = <span class="number">0x22</span>;</span><br><span class="line">  TH0 = <span class="number">0xdc</span>;</span><br><span class="line">  ms ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的程序非常简陋但是足以写出测速的原理和实现的方法了，当然，本程序在理论上还存在很大的缺陷，实际上虽然我们的测速时间是3秒，但是刷新时间并不一定是3秒，如果你细心的话可能会发现，你的车停下后速度不会立刻变成0，而是在几秒甚至十几秒内快速下降，最后变成0，并且起步的时候也是同理，速度会慢慢增大而不是在你开始骑的3秒后突然增大，因此我们可以对程序稍加改进，这样一来既保证了准确性又保证了刷新频率</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;51FunctionLibrary.h&quot;</span></span></span><br><span class="line">sbit LED1 = P2^<span class="number">0</span>; <span class="comment">//调试用的LED</span></span><br><span class="line">sbit Hall = P3^<span class="number">2</span>; <span class="comment">//霍尔元件I/O</span></span><br><span class="line">sbit K1 = P3^<span class="number">1</span>;	 <span class="comment">//调试用复位开关</span></span><br><span class="line">u8 ms1 = <span class="number">0</span>;</span><br><span class="line">u8 ms2 = <span class="number">100</span>;</span><br><span class="line">u8 ms3 = <span class="number">200</span>;</span><br><span class="line">u8 wheelcount1 = <span class="number">0</span>;</span><br><span class="line">u8 wheelcount2 = <span class="number">0</span>;</span><br><span class="line">u8 wheelcount3 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> speed = <span class="number">0</span>; <span class="comment">//速度（m/h）</span></span><br><span class="line"><span class="keyword">float</span> wheeldiam = <span class="number">0.635</span>; <span class="comment">//轮毂的直径（m）26寸轮毂==0.635m直径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer0Init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 delaytime)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer0start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Timer0Init();</span><br><span class="line">IE |= <span class="number">0x81</span>; <span class="comment">//打开外部中断0</span></span><br><span class="line">IT0 = <span class="number">1</span>;  <span class="comment">//下降沿有效</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  DigDisplay(speed); </span><br><span class="line">  <span class="keyword">if</span>(ms1 &gt;= <span class="number">300</span>)&#123;  <span class="comment">//如果达到指定时间那么进入</span></span><br><span class="line">    speed = <span class="number">3.1416</span> * wheeldiam * wheelcount1 * <span class="number">3600</span> / <span class="number">3</span>; <span class="comment">//速度赋值</span></span><br><span class="line">    wheelcount1 = <span class="number">0</span>; <span class="comment">//重置计数</span></span><br><span class="line">    ms1 = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="comment">//重置计时</span></span><br><span class="line">  <span class="keyword">if</span>(ms2 &gt;= <span class="number">300</span>)&#123;  <span class="comment">//如果达到指定时间那么进入</span></span><br><span class="line">    speed = <span class="number">3.1416</span> * wheeldiam * wheelcount2 * <span class="number">3600</span> / <span class="number">3</span>; <span class="comment">//速度赋值</span></span><br><span class="line">    wheelcount2 = <span class="number">0</span>; <span class="comment">//重置计数</span></span><br><span class="line">    ms2 = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="comment">//重置计时</span></span><br><span class="line">  <span class="keyword">if</span>(ms3 &gt;= <span class="number">300</span>)&#123;  <span class="comment">//如果达到指定时间那么进入</span></span><br><span class="line">    speed = <span class="number">3.1416</span> * wheeldiam * wheelcount3 * <span class="number">3600</span> / <span class="number">3</span>; <span class="comment">//速度赋值</span></span><br><span class="line">    wheelcount3 = <span class="number">0</span>; <span class="comment">//重置计数</span></span><br><span class="line">    ms3 = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="comment">//重置计时</span></span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EX_INTO</span><span class="params">()</span> interrupt 0</span>&#123; <span class="comment">//探测计数外部中断</span></span><br><span class="line">  wheelcount1 ++;</span><br><span class="line">    wheelcount2 ++;</span><br><span class="line">      wheelcount3 ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer0</span><span class="params">()</span> interrupt 1</span>&#123; <span class="comment">//定时器中断</span></span><br><span class="line">  TL0 = <span class="number">0x22</span>;</span><br><span class="line">  TH0 = <span class="number">0xdc</span>;</span><br><span class="line">  ms1 ++;</span><br><span class="line">  ms2 ++;</span><br><span class="line">  ms3 ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为这个程序我暂时还没有实际应用到所以暂时不做优化啦，反正大致上就是这么个意思，逻辑上是没有问题的，这样也就保证了刷新的速度和准确性，但是如果检测时间太长还是会失去瞬时性，但是生活中大多数的测速都是通过平均速度来代替瞬时速度的，毕竟真正意义上瞬时速度貌似是没办法测的吧，这就涉及到物理层面了，不再赘述</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>开了个新坑，过程中遇到了太多阻碍了，一是开发资料的不足，另外是自己知识的盲区，所以导致这一部分虽然内容很少但是浪费了很多时间，希望我单片机课设的时候能抽到这个吧哈哈哈，即便是没有抽到，我在这一部分学习的内容中帮助到了在做课设的学长，也收到了dalao的帮助，填补了一部分之前知识的漏洞，收获也算是颇丰吧</p>
<p><strong>特别鸣谢：@sorakage_33</strong></p>
<p><i class="fa fa-info-circle" aria-hidden="true"></i>   本文还未与函数库同步21/5/15</p>
<hr>
<p><strong>参考资料：</strong></p>
<p>[1] 开关霍尔传感器与线性霍尔传感器：<a href="https://www.51dzw.com/embed/embed_128565.html">https://www.51dzw.com/embed/embed_128565.html</a></p>
<p>[2]TTL电平与CMOS电平：<a href="http://www.51hei.com/bbs/dpj-135738-1.html">http://www.51hei.com/bbs/dpj-135738-1.html</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>单片机</tag>
        <tag>STC89C52</tag>
        <tag>霍尔元件</tag>
      </tags>
  </entry>
</search>
